[
  {
    "schema": "extensions",
    "name": "pg_stat_statements",
    "sql_definition": " SELECT pg_stat_statements.userid,\n    pg_stat_statements.dbid,\n    pg_stat_statements.toplevel,\n    pg_stat_statements.queryid,\n    pg_stat_statements.query,\n    pg_stat_statements.plans,\n    pg_stat_statements.total_plan_time,\n    pg_stat_statements.min_plan_time,\n    pg_stat_statements.max_plan_time,\n    pg_stat_statements.mean_plan_time,\n    pg_stat_statements.stddev_plan_time,\n    pg_stat_statements.calls,\n    pg_stat_statements.total_exec_time,\n    pg_stat_statements.min_exec_time,\n    pg_stat_statements.max_exec_time,\n    pg_stat_statements.mean_exec_time,\n    pg_stat_statements.stddev_exec_time,\n    pg_stat_statements.rows,\n    pg_stat_statements.shared_blks_hit,\n    pg_stat_statements.shared_blks_read,\n    pg_stat_statements.shared_blks_dirtied,\n    pg_stat_statements.shared_blks_written,\n    pg_stat_statements.local_blks_hit,\n    pg_stat_statements.local_blks_read,\n    pg_stat_statements.local_blks_dirtied,\n    pg_stat_statements.local_blks_written,\n    pg_stat_statements.temp_blks_read,\n    pg_stat_statements.temp_blks_written,\n    pg_stat_statements.blk_read_time,\n    pg_stat_statements.blk_write_time,\n    pg_stat_statements.temp_blk_read_time,\n    pg_stat_statements.temp_blk_write_time,\n    pg_stat_statements.wal_records,\n    pg_stat_statements.wal_fpi,\n    pg_stat_statements.wal_bytes,\n    pg_stat_statements.jit_functions,\n    pg_stat_statements.jit_generation_time,\n    pg_stat_statements.jit_inlining_count,\n    pg_stat_statements.jit_inlining_time,\n    pg_stat_statements.jit_optimization_count,\n    pg_stat_statements.jit_optimization_time,\n    pg_stat_statements.jit_emission_count,\n    pg_stat_statements.jit_emission_time\n   FROM pg_stat_statements(true) pg_stat_statements(userid, dbid, toplevel, queryid, query, plans, total_plan_time, min_plan_time, max_plan_time, mean_plan_time, stddev_plan_time, calls, total_exec_time, min_exec_time, max_exec_time, mean_exec_time, stddev_exec_time, rows, shared_blks_hit, shared_blks_read, shared_blks_dirtied, shared_blks_written, local_blks_hit, local_blks_read, local_blks_dirtied, local_blks_written, temp_blks_read, temp_blks_written, blk_read_time, blk_write_time, temp_blk_read_time, temp_blk_write_time, wal_records, wal_fpi, wal_bytes, jit_functions, jit_generation_time, jit_inlining_count, jit_inlining_time, jit_optimization_count, jit_optimization_time, jit_emission_count, jit_emission_time);"
  },
  {
    "schema": "extensions",
    "name": "pg_stat_statements_info",
    "sql_definition": " SELECT pg_stat_statements_info.dealloc,\n    pg_stat_statements_info.stats_reset\n   FROM pg_stat_statements_info() pg_stat_statements_info(dealloc, stats_reset);"
  },
  {
    "schema": "public",
    "name": "active_loadings",
    "sql_definition": " SELECT loadings.loading_id,\n    loadings.loading_responsible,\n    loadings.loading_section,\n    loadings.loading_start,\n    loadings.loading_finish,\n    loadings.loading_rate,\n    loadings.loading_created,\n    loadings.loading_updated,\n    loadings.loading_task,\n        CASE\n            WHEN (loadings.loading_finish < CURRENT_DATE) THEN 'Завершена'::text\n            WHEN (loadings.loading_start > CURRENT_DATE) THEN 'Будущая'::text\n            ELSE 'Текущая'::text\n        END AS time_status\n   FROM loadings\n  WHERE (loadings.loading_status = 'active'::loading_status_type);"
  },
  {
    "schema": "public",
    "name": "archived_loadings",
    "sql_definition": " SELECT loadings.loading_id,\n    loadings.loading_responsible,\n    loadings.loading_section,\n    loadings.loading_stage,\n    loadings.loading_start,\n    loadings.loading_finish,\n    loadings.loading_rate,\n    loadings.loading_created,\n    loadings.loading_updated,\n    loadings.loading_task,\n    'Архивная'::text AS time_status\n   FROM loadings\n  WHERE (loadings.loading_status = 'archived'::loading_status_type);"
  },
  {
    "schema": "public",
    "name": "v_budgets_full",
    "sql_definition": " SELECT b.budget_id,\n    b.entity_type,\n    b.entity_id,\n    b.name,\n    b.description,\n    b.total_amount,\n    b.is_active,\n    b.parent_budget_id,\n    b.created_by,\n    b.created_at,\n    b.updated_at,\n    pb.name AS parent_name,\n    pb.entity_type AS parent_entity_type,\n    pb.entity_id AS parent_entity_id,\n    pb.total_amount AS parent_total_amount,\n    COALESCE(( SELECT jsonb_agg(jsonb_build_object('part_id', bp.part_id, 'part_type', bp.part_type, 'custom_name', bp.custom_name, 'percentage', bp.percentage, 'fixed_amount', bp.fixed_amount, 'calculated_amount', bp.calculated_amount, 'requires_approval', bp.requires_approval, 'approval_threshold', bp.approval_threshold, 'color', bp.color, 'spent_amount', COALESCE(exp.spent_amount, (0)::numeric), 'remaining_amount', (COALESCE(bp.fixed_amount, (0)::numeric) - COALESCE(exp.spent_amount, (0)::numeric)), 'spent_percentage',\n                CASE\n                    WHEN (COALESCE(bp.fixed_amount, (0)::numeric) > (0)::numeric) THEN round(((COALESCE(exp.spent_amount, (0)::numeric) / bp.fixed_amount) * (100)::numeric), 2)\n                    ELSE (0)::numeric\n                END) ORDER BY\n                CASE bp.part_type\n                    WHEN 'main'::budget_part_type THEN 1\n                    WHEN 'premium'::budget_part_type THEN 2\n                    ELSE 3\n                END) AS jsonb_agg\n           FROM (budget_parts bp\n             LEFT JOIN ( SELECT budget_expenses.part_id,\n                    sum(budget_expenses.amount) AS spent_amount\n                   FROM budget_expenses\n                  WHERE ((budget_expenses.status)::text = 'approved'::text)\n                  GROUP BY budget_expenses.part_id) exp ON ((exp.part_id = bp.part_id)))\n          WHERE (bp.budget_id = b.budget_id)), '[]'::jsonb) AS parts,\n    COALESCE(( SELECT sum(be.amount) AS sum\n           FROM budget_expenses be\n          WHERE ((be.budget_id = b.budget_id) AND ((be.status)::text = 'approved'::text))), (0)::numeric) AS total_spent,\n    (b.total_amount - COALESCE(( SELECT sum(be.amount) AS sum\n           FROM budget_expenses be\n          WHERE ((be.budget_id = b.budget_id) AND ((be.status)::text = 'approved'::text))), (0)::numeric)) AS remaining_amount,\n        CASE\n            WHEN (b.total_amount > (0)::numeric) THEN round(((COALESCE(( SELECT sum(be.amount) AS sum\n               FROM budget_expenses be\n              WHERE ((be.budget_id = b.budget_id) AND ((be.status)::text = 'approved'::text))), (0)::numeric) / b.total_amount) * (100)::numeric), 2)\n            ELSE (0)::numeric\n        END AS spent_percentage,\n    ( SELECT count(*) AS count\n           FROM budget_expenses be\n          WHERE ((be.budget_id = b.budget_id) AND ((be.status)::text = 'pending'::text))) AS pending_expenses_count,\n    ( SELECT count(*) AS count\n           FROM budgets child\n          WHERE ((child.parent_budget_id = b.budget_id) AND (child.is_active = true))) AS children_count\n   FROM (budgets b\n     LEFT JOIN budgets pb ON ((pb.budget_id = b.parent_budget_id)));"
  },
  {
    "schema": "public",
    "name": "v_cache_budgets",
    "sql_definition": " SELECT b.budget_id,\n    b.entity_type,\n    b.entity_id,\n    b.name,\n    b.total_amount,\n    b.is_active,\n    b.parent_budget_id,\n    b.created_at,\n    b.updated_at,\n    main_part.part_id AS main_part_id,\n    COALESCE(NULLIF(main_part.fixed_amount, (0)::numeric), NULLIF(main_part.calculated_amount, (0)::numeric),\n        CASE\n            WHEN (main_part.percentage IS NOT NULL) THEN round(((b.total_amount * main_part.percentage) / (100)::numeric), 2)\n            ELSE NULL::numeric\n        END) AS main_amount,\n    COALESCE(main_spent.amount, (0)::numeric) AS main_spent,\n    premium_part.part_id AS premium_part_id,\n    COALESCE(NULLIF(premium_part.fixed_amount, (0)::numeric), NULLIF(premium_part.calculated_amount, (0)::numeric),\n        CASE\n            WHEN (premium_part.percentage IS NOT NULL) THEN round(((b.total_amount * premium_part.percentage) / (100)::numeric), 2)\n            ELSE NULL::numeric\n        END) AS premium_amount,\n    COALESCE(premium_spent.amount, (0)::numeric) AS premium_spent,\n    COALESCE(total_spent.amount, (0)::numeric) AS total_spent,\n    (b.total_amount - COALESCE(total_spent.amount, (0)::numeric)) AS remaining_amount,\n        CASE\n            WHEN (b.total_amount > (0)::numeric) THEN round(((COALESCE(total_spent.amount, (0)::numeric) / b.total_amount) * (100)::numeric), 2)\n            ELSE (0)::numeric\n        END AS spent_percentage,\n    pb.name AS parent_name,\n    pb.total_amount AS parent_total_amount\n   FROM ((((((budgets b\n     LEFT JOIN budgets pb ON ((pb.budget_id = b.parent_budget_id)))\n     LEFT JOIN budget_parts main_part ON (((main_part.budget_id = b.budget_id) AND (main_part.part_type = 'main'::budget_part_type))))\n     LEFT JOIN budget_parts premium_part ON (((premium_part.budget_id = b.budget_id) AND (premium_part.part_type = 'premium'::budget_part_type))))\n     LEFT JOIN ( SELECT budget_expenses.budget_id,\n            sum(budget_expenses.amount) AS amount\n           FROM budget_expenses\n          WHERE ((budget_expenses.status)::text = 'approved'::text)\n          GROUP BY budget_expenses.budget_id) total_spent ON ((total_spent.budget_id = b.budget_id)))\n     LEFT JOIN ( SELECT budget_expenses.part_id,\n            sum(budget_expenses.amount) AS amount\n           FROM budget_expenses\n          WHERE ((budget_expenses.status)::text = 'approved'::text)\n          GROUP BY budget_expenses.part_id) main_spent ON ((main_spent.part_id = main_part.part_id)))\n     LEFT JOIN ( SELECT budget_expenses.part_id,\n            sum(budget_expenses.amount) AS amount\n           FROM budget_expenses\n          WHERE ((budget_expenses.status)::text = 'approved'::text)\n          GROUP BY budget_expenses.part_id) premium_spent ON ((premium_spent.part_id = premium_part.part_id)))\n  WHERE (b.is_active = true);"
  },
  {
    "schema": "public",
    "name": "v_cache_projects",
    "sql_definition": " SELECT p.project_id,\n    p.project_name,\n    p.project_status,\n    p.project_description,\n    p.project_created,\n    p.project_updated,\n    p.project_manager AS manager_id,\n    pm.first_name AS manager_first_name,\n    pm.last_name AS manager_last_name,\n    concat(pm.first_name, ' ', pm.last_name) AS manager_name,\n    p.project_lead_engineer AS lead_engineer_id,\n    ple.first_name AS lead_engineer_first_name,\n    ple.last_name AS lead_engineer_last_name,\n    concat(ple.first_name, ' ', ple.last_name) AS lead_engineer_name,\n    p.client_id,\n    c.client_name,\n    st.stage_id,\n    st.stage_name,\n    o.object_id,\n    o.object_name,\n    o.object_responsible,\n    s.section_id,\n    s.section_name,\n    s.section_responsible,\n    s.section_start_date,\n    s.section_end_date,\n    s.section_status_id,\n    ss.name AS section_status_name,\n    ss.color AS section_status_color,\n    sr.first_name AS section_responsible_first_name,\n    sr.last_name AS section_responsible_last_name,\n    concat(sr.first_name, ' ', sr.last_name) AS section_responsible_name,\n    ( SELECT (count(*))::integer AS count\n           FROM decomposition_stages ds\n          WHERE (ds.decomposition_stage_section_id = s.section_id)) AS decomposition_stages_count,\n    ( SELECT (count(*))::integer AS count\n           FROM loadings l\n          WHERE ((l.loading_section = s.section_id) AND (l.loading_status = 'active'::loading_status_type))) AS active_loadings_count\n   FROM ((((((((projects p\n     LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n     LEFT JOIN profiles ple ON ((p.project_lead_engineer = ple.user_id)))\n     LEFT JOIN clients c ON ((p.client_id = c.client_id)))\n     LEFT JOIN stages st ON ((st.stage_project_id = p.project_id)))\n     LEFT JOIN objects o ON ((o.object_stage_id = st.stage_id)))\n     LEFT JOIN sections s ON ((s.section_object_id = o.object_id)))\n     LEFT JOIN section_statuses ss ON ((s.section_status_id = ss.id)))\n     LEFT JOIN profiles sr ON ((s.section_responsible = sr.user_id)))\n  ORDER BY p.project_name, st.stage_name, o.object_name, s.section_name;"
  },
  {
    "schema": "public",
    "name": "v_cache_section_budget_summary",
    "sql_definition": " SELECT s.section_id,\n    s.section_name,\n    s.section_project_id,\n    s.section_object_id,\n    s.section_responsible,\n    1 AS budget_count,\n    COALESCE(b.total_amount, (0)::numeric) AS total_planned,\n    COALESCE(spent.amount, (0)::numeric) AS total_spent,\n    (COALESCE(b.total_amount, (0)::numeric) - COALESCE(spent.amount, (0)::numeric)) AS remaining,\n        CASE\n            WHEN (COALESCE(b.total_amount, (0)::numeric) = (0)::numeric) THEN (0)::numeric\n            ELSE round(((COALESCE(spent.amount, (0)::numeric) / b.total_amount) * (100)::numeric), 2)\n        END AS spent_percentage\n   FROM ((sections s\n     LEFT JOIN budgets b ON (((b.entity_type = 'section'::budget_entity_type) AND (b.entity_id = s.section_id) AND (b.is_active = true))))\n     LEFT JOIN ( SELECT budget_expenses.budget_id,\n            sum(budget_expenses.amount) AS amount\n           FROM budget_expenses\n          WHERE ((budget_expenses.status)::text = 'approved'::text)\n          GROUP BY budget_expenses.budget_id) spent ON ((spent.budget_id = b.budget_id)));"
  },
  {
    "schema": "public",
    "name": "v_org_structure",
    "sql_definition": " SELECT s.subdivision_id,\n    s.subdivision_name,\n    d.department_id,\n    d.department_name,\n    d.subdivision_id AS department_subdivision_id,\n    t.team_id,\n    t.team_name,\n    t.department_id AS team_department_id,\n    p.user_id AS employee_id,\n    p.first_name AS employee_first_name,\n    p.last_name AS employee_last_name,\n    concat(p.last_name, ' ', p.first_name) AS employee_name,\n    p.team_id AS employee_team_id,\n    p.avatar_url AS employee_avatar\n   FROM (((subdivisions s\n     LEFT JOIN departments d ON ((d.subdivision_id = s.subdivision_id)))\n     LEFT JOIN teams t ON ((t.department_id = d.department_id)))\n     LEFT JOIN profiles p ON ((p.team_id = t.team_id)))\n  ORDER BY s.subdivision_name, d.department_name, t.team_name, p.last_name, p.first_name;"
  },
  {
    "schema": "public",
    "name": "v_project_sections",
    "sql_definition": " SELECT s.section_id,\n    s.section_name,\n    s.section_object_id AS object_id,\n    o.object_name,\n    st.stage_id,\n    st.stage_name,\n    st.stage_project_id AS project_id\n   FROM ((sections s\n     JOIN objects o ON ((o.object_id = s.section_object_id)))\n     JOIN stages st ON ((st.stage_id = o.object_stage_id)))\n  ORDER BY s.section_name;"
  },
  {
    "schema": "public",
    "name": "v_project_structure",
    "sql_definition": " SELECT pm.user_id AS manager_id,\n    pm.first_name AS manager_first_name,\n    pm.last_name AS manager_last_name,\n    concat(pm.last_name, ' ', pm.first_name) AS manager_name,\n    p.project_id,\n    p.project_name,\n    p.project_status,\n    p.project_manager,\n    NULL::uuid AS stage_id,\n    p.stage_type AS stage_name,\n    p.project_id AS stage_project_id,\n    o.object_id,\n    o.object_name,\n    o.object_project_id AS object_stage_id,\n    sec.section_id,\n    sec.section_name,\n    sec.section_object_id\n   FROM (((projects p\n     LEFT JOIN profiles pm ON ((pm.user_id = p.project_manager)))\n     LEFT JOIN objects o ON ((o.object_project_id = p.project_id)))\n     LEFT JOIN sections sec ON ((sec.section_object_id = o.object_id)))\n  ORDER BY pm.last_name, p.project_name, o.object_name, sec.section_name;"
  },
  {
    "schema": "public",
    "name": "v_resource_graph",
    "sql_definition": " SELECT p.project_id,\n    p.project_name,\n    p.project_status,\n    p.stage_type,\n    p.project_manager AS manager_id,\n    pm.first_name AS manager_first_name,\n    pm.last_name AS manager_last_name,\n    concat(pm.last_name, ' ', pm.first_name) AS manager_name,\n    o.object_id,\n    o.object_name,\n    sec.section_id,\n    sec.section_name,\n    sec.section_responsible AS section_responsible_id,\n    sr.first_name AS section_responsible_first_name,\n    sr.last_name AS section_responsible_last_name,\n    concat(sr.last_name, ' ', sr.first_name) AS section_responsible_name,\n    sr.avatar_url AS section_responsible_avatar,\n    sec.section_start_date,\n    sec.section_end_date,\n    sec.section_status_id,\n    ss.name AS section_status_name,\n    ss.color AS section_status_color,\n    sr.department_id AS section_department_id,\n    dept.department_name AS section_department_name,\n    dept.subdivision_id AS section_subdivision_id,\n    sub.subdivision_name AS section_subdivision_name,\n    rc.readiness_checkpoints AS section_readiness_checkpoints,\n    COALESCE(( SELECT jsonb_agg(combined.snapshot ORDER BY (combined.snapshot ->> 'date'::text)) AS jsonb_agg\n           FROM ( SELECT jsonb_build_object('date', srs.snapshot_date, 'value', srs.actual_readiness) AS snapshot\n                   FROM section_readiness_snapshots srs\n                  WHERE ((srs.section_id = sec.section_id) AND (srs.snapshot_date < CURRENT_DATE))\n                UNION ALL\n                 SELECT jsonb_build_object('date', CURRENT_DATE, 'value', (COALESCE(round((sum(((di2.decomposition_item_progress)::numeric * di2.decomposition_item_planned_hours)) / NULLIF(sum(di2.decomposition_item_planned_hours), (0)::numeric))), (0)::numeric))::integer) AS jsonb_build_object\n                   FROM (decomposition_stages ds2\n                     JOIN decomposition_items di2 ON ((di2.decomposition_item_stage_id = ds2.decomposition_stage_id)))\n                  WHERE ((ds2.decomposition_stage_section_id = sec.section_id) AND (di2.decomposition_item_planned_hours > (0)::numeric))\n                 HAVING (sum(di2.decomposition_item_planned_hours) > (0)::numeric)) combined), '[]'::jsonb) AS section_actual_readiness,\n    section_items_spending.budget_spending AS section_budget_spending,\n    sec.section_hourly_rate,\n    ds.decomposition_stage_id,\n    ds.decomposition_stage_name,\n    ds.decomposition_stage_start,\n    ds.decomposition_stage_finish,\n    ds.decomposition_stage_order,\n    ds.stage_status_id AS decomposition_stage_status_id,\n    dss.name AS decomposition_stage_status_name,\n    (dss.color)::character varying AS decomposition_stage_status_color,\n    di.decomposition_item_id,\n    di.decomposition_item_description,\n    di.decomposition_item_planned_hours,\n    di.decomposition_item_planned_due_date,\n    di.decomposition_item_progress,\n    di.decomposition_item_order,\n    di.decomposition_item_responsible AS item_responsible_id,\n    ir.first_name AS item_responsible_first_name,\n    ir.last_name AS item_responsible_last_name,\n    concat(ir.last_name, ' ', ir.first_name) AS item_responsible_name,\n    di.decomposition_item_status_id,\n    dis.name AS item_status_name,\n    dis.color AS item_status_color,\n    di.decomposition_item_difficulty_id,\n    dif.difficulty_abbr AS item_difficulty_abbr,\n    dif.difficulty_definition AS item_difficulty_name,\n    di.decomposition_item_work_category_id,\n    wc.work_category_name,\n    sec.section_description,\n    COALESCE(wl_agg.total_actual_hours, (0)::numeric) AS decomposition_item_actual_hours,\n        CASE\n            WHEN (COALESCE(wl_agg.total_actual_hours, (0)::numeric) > (0)::numeric) THEN round((((di.decomposition_item_planned_hours * (di.decomposition_item_progress)::numeric) / 100.0) / NULLIF(wl_agg.total_actual_hours, (0)::numeric)), 3)\n            ELSE NULL::numeric\n        END AS decomposition_item_cpi,\n    item_budget.budget_id AS item_budget_id,\n    COALESCE(item_budget.total_amount, (0)::numeric) AS item_budget_total,\n    COALESCE(item_budget.total_spent, (0)::numeric) AS item_budget_spent,\n    (COALESCE(item_budget.total_amount, (0)::numeric) - COALESCE(item_budget.total_spent, (0)::numeric)) AS item_budget_remaining,\n        CASE\n            WHEN (COALESCE(item_budget.total_amount, (0)::numeric) > (0)::numeric) THEN round(((COALESCE(item_budget.total_spent, (0)::numeric) / item_budget.total_amount) * (100)::numeric), 1)\n            ELSE (0)::numeric\n        END AS item_budget_percentage,\n    progress_delta.delta AS decomposition_item_progress_delta,\n    COALESCE(progress_history.history, '[]'::jsonb) AS decomposition_item_progress_history\n   FROM ((((((((((((((((((((projects p\n     LEFT JOIN profiles pm ON ((pm.user_id = p.project_manager)))\n     LEFT JOIN objects o ON ((o.object_project_id = p.project_id)))\n     LEFT JOIN sections sec ON ((sec.section_object_id = o.object_id)))\n     LEFT JOIN profiles sr ON ((sr.user_id = sec.section_responsible)))\n     LEFT JOIN departments dept ON ((dept.department_id = sr.department_id)))\n     LEFT JOIN subdivisions sub ON ((sub.subdivision_id = dept.subdivision_id)))\n     LEFT JOIN section_statuses ss ON ((ss.id = sec.section_status_id)))\n     LEFT JOIN LATERAL ( SELECT jsonb_agg(jsonb_build_object('date', src.checkpoint_date, 'value', src.planned_readiness) ORDER BY src.checkpoint_date) AS readiness_checkpoints\n           FROM section_readiness_checkpoints src\n          WHERE (src.section_id = sec.section_id)) rc ON (true))\n     LEFT JOIN LATERAL ( SELECT\n                CASE\n                    WHEN ((section_totals.total_budget IS NULL) OR (section_totals.total_budget = (0)::numeric)) THEN NULL::jsonb\n                    ELSE ( SELECT jsonb_agg(jsonb_build_object('date', daily.expense_date, 'spent', daily.cumulative_spent, 'percentage', round(((daily.cumulative_spent / section_totals.total_budget) * (100)::numeric), 1)) ORDER BY daily.expense_date) AS jsonb_agg\n                       FROM ( SELECT be.expense_date,\n                                sum(be.amount) OVER (ORDER BY be.expense_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_spent\n                               FROM budget_expenses be\n                              WHERE ((be.budget_id = ANY (section_totals.item_budget_ids)) AND ((be.status)::text = 'approved'::text))\n                              ORDER BY be.expense_date) daily)\n                END AS budget_spending\n           FROM ( SELECT array_agg(b.budget_id) AS item_budget_ids,\n                    COALESCE(sum(b.total_amount), (0)::numeric) AS total_budget\n                   FROM ((decomposition_stages ds_inner\n                     JOIN decomposition_items di_inner ON ((di_inner.decomposition_item_stage_id = ds_inner.decomposition_stage_id)))\n                     JOIN budgets b ON (((b.entity_type = 'decomposition_item'::budget_entity_type) AND (b.entity_id = di_inner.decomposition_item_id) AND (b.is_active = true))))\n                  WHERE (ds_inner.decomposition_stage_section_id = sec.section_id)) section_totals) section_items_spending ON (true))\n     LEFT JOIN decomposition_stages ds ON ((ds.decomposition_stage_section_id = sec.section_id)))\n     LEFT JOIN stage_statuses dss ON ((dss.id = ds.stage_status_id)))\n     LEFT JOIN decomposition_items di ON ((di.decomposition_item_stage_id = ds.decomposition_stage_id)))\n     LEFT JOIN profiles ir ON ((ir.user_id = di.decomposition_item_responsible)))\n     LEFT JOIN section_statuses dis ON ((dis.id = di.decomposition_item_status_id)))\n     LEFT JOIN decomposition_difficulty_levels dif ON ((dif.difficulty_id = di.decomposition_item_difficulty_id)))\n     LEFT JOIN work_categories wc ON ((wc.work_category_id = di.decomposition_item_work_category_id)))\n     LEFT JOIN LATERAL ( SELECT sum(wl.work_log_hours) AS total_actual_hours\n           FROM work_logs wl\n          WHERE (wl.decomposition_item_id = di.decomposition_item_id)) wl_agg ON (true))\n     LEFT JOIN LATERAL ( SELECT b.budget_id,\n            b.total_amount,\n            COALESCE(sum(be.amount) FILTER (WHERE ((be.status)::text = 'approved'::text)), (0)::numeric) AS total_spent\n           FROM (budgets b\n             LEFT JOIN budget_expenses be ON ((be.budget_id = b.budget_id)))\n          WHERE ((b.entity_type = 'decomposition_item'::budget_entity_type) AND (b.entity_id = di.decomposition_item_id) AND (b.is_active = true))\n          GROUP BY b.budget_id, b.total_amount\n         LIMIT 1) item_budget ON (true))\n     LEFT JOIN LATERAL ( SELECT (iph.new_progress - COALESCE(iph.old_progress, 0)) AS delta\n           FROM item_progress_history iph\n          WHERE (iph.item_id = di.decomposition_item_id)\n          ORDER BY iph.changed_at DESC\n         LIMIT 1) progress_delta ON (true))\n     LEFT JOIN LATERAL ( SELECT jsonb_agg(jsonb_build_object('date', (iph.changed_at)::date, 'delta', (iph.new_progress - COALESCE(iph.old_progress, 0)), 'oldProgress', COALESCE(iph.old_progress, 0), 'newProgress', iph.new_progress) ORDER BY iph.changed_at) AS history\n           FROM item_progress_history iph\n          WHERE ((iph.item_id = di.decomposition_item_id) AND (iph.changed_at >= (CURRENT_DATE - '30 days'::interval)))) progress_history ON (true))\n  WHERE (p.project_status = 'active'::project_status_enum);"
  },
  {
    "schema": "public",
    "name": "view_calendar_vacations",
    "sql_definition": " SELECT calendar_events.calendar_event_id,\n    calendar_events.calendar_event_type,\n    calendar_events.calendar_event_comment,\n    calendar_events.calendar_event_is_global,\n    calendar_events.calendar_event_is_weekday,\n    calendar_events.calendar_event_created_by,\n    calendar_events.calendar_event_date_start,\n    calendar_events.calendar_event_date_end,\n    calendar_events.calendar_event_created_at\n   FROM calendar_events\n  WHERE (calendar_events.calendar_event_type = ANY (ARRAY['Отпуск запрошен'::calendar_event_type_enum, 'Отпуск одобрен'::calendar_event_type_enum, 'Отпуск отклонен'::calendar_event_type_enum]));"
  },
  {
    "schema": "public",
    "name": "view_decomposition_item_actuals",
    "sql_definition": " SELECT di.decomposition_item_id,\n    di.decomposition_item_section_id AS section_id,\n    COALESCE(sum(wl.work_log_hours), (0)::numeric) AS actual_hours,\n    COALESCE(sum(wl.work_log_amount), (0)::numeric) AS actual_amount,\n    count(wl.work_log_id) AS work_logs_count,\n    max(wl.work_log_date) AS last_work_log_date\n   FROM (decomposition_items di\n     LEFT JOIN work_logs wl ON ((wl.decomposition_item_id = di.decomposition_item_id)))\n  GROUP BY di.decomposition_item_id, di.decomposition_item_section_id;"
  },
  {
    "schema": "public",
    "name": "view_decomposition_item_totals",
    "sql_definition": " SELECT di.decomposition_item_id,\n    (COALESCE(sum(wl.work_log_hours), (0)::numeric))::numeric(10,2) AS actual_hours,\n    (COALESCE(sum(wl.work_log_amount), (0)::numeric))::numeric(14,2) AS actual_amount\n   FROM (decomposition_items di\n     LEFT JOIN work_logs wl ON ((wl.decomposition_item_id = di.decomposition_item_id)))\n  GROUP BY di.decomposition_item_id;"
  },
  {
    "schema": "public",
    "name": "view_decomposition_stage_agg",
    "sql_definition": " SELECT s.decomposition_stage_section_id AS section_id,\n    s.decomposition_stage_id AS stage_id,\n    s.decomposition_stage_name AS stage_name,\n    s.decomposition_stage_start AS start_date,\n    s.decomposition_stage_finish AS finish_date,\n    COALESCE(sum(di.decomposition_item_planned_hours), (0)::numeric) AS planned_hours,\n    COALESCE(sum(wl.work_log_hours), (0)::numeric) AS actual_hours,\n    count(DISTINCT di.decomposition_item_id) AS items_count,\n    min(di.decomposition_item_planned_due_date) AS min_due_date,\n    max(di.decomposition_item_planned_due_date) AS max_due_date\n   FROM ((decomposition_stages s\n     LEFT JOIN decomposition_items di ON ((di.decomposition_item_stage_id = s.decomposition_stage_id)))\n     LEFT JOIN work_logs wl ON ((wl.decomposition_item_id = di.decomposition_item_id)))\n  GROUP BY s.decomposition_stage_section_id, s.decomposition_stage_id, s.decomposition_stage_name, s.decomposition_stage_start, s.decomposition_stage_finish;"
  },
  {
    "schema": "public",
    "name": "view_department_heads",
    "sql_definition": " SELECT d.department_id,\n    d.department_name,\n    d.department_head_id AS user_id,\n    p.first_name,\n    p.last_name,\n    p.email,\n    p.avatar_url\n   FROM (departments d\n     LEFT JOIN profiles p ON ((d.department_head_id = p.user_id)))\n  WHERE ((d.department_name <> 'Без отдела'::text) AND (d.department_head_id IS NOT NULL));"
  },
  {
    "schema": "public",
    "name": "view_departments_with_heads",
    "sql_definition": " SELECT d.department_id,\n    d.department_name,\n    d.subdivision_id,\n    s.subdivision_name,\n    d.department_head_id,\n    p.first_name AS head_first_name,\n    p.last_name AS head_last_name,\n    concat(p.first_name, ' ', p.last_name) AS head_full_name,\n    p.email AS head_email,\n    p.avatar_url AS head_avatar_url\n   FROM ((departments d\n     LEFT JOIN subdivisions s ON ((d.subdivision_id = s.subdivision_id)))\n     LEFT JOIN profiles p ON ((d.department_head_id = p.user_id)))\n  WHERE (d.department_name <> 'Без отдела'::text)\n  ORDER BY d.department_name;"
  },
  {
    "schema": "public",
    "name": "view_employee_vacations",
    "sql_definition": " SELECT e.calendar_event_id AS vacation_id,\n    e.calendar_event_created_by AS user_id,\n    p.first_name,\n    p.last_name,\n    ((p.first_name || ' '::text) || p.last_name) AS full_name,\n    p.department_id,\n    p.team_id,\n    (e.calendar_event_date_start)::date AS date_start,\n    COALESCE((e.calendar_event_date_end)::date, (e.calendar_event_date_start)::date) AS date_end,\n    e.calendar_event_comment AS comment,\n    e.calendar_event_created_at AS created_at\n   FROM (calendar_events e\n     JOIN profiles p ON ((p.user_id = e.calendar_event_created_by)))\n  WHERE ((e.calendar_event_is_global = false) AND (e.calendar_event_type = 'Отпуск одобрен'::calendar_event_type_enum));"
  },
  {
    "schema": "public",
    "name": "view_employee_vacations_daily",
    "sql_definition": " SELECT v.vacation_id,\n    v.user_id,\n    v.department_id,\n    v.team_id,\n    (gs.gs)::date AS vacation_date,\n    1.0 AS rate\n   FROM (view_employee_vacations v\n     CROSS JOIN LATERAL generate_series((v.date_start)::timestamp with time zone, (v.date_end)::timestamp with time zone, '1 day'::interval) gs(gs));"
  },
  {
    "schema": "public",
    "name": "view_employee_workloads",
    "sql_definition": " SELECT p.user_id,\n    p.first_name,\n    p.last_name,\n        CASE\n            WHEN ((TRIM(BOTH FROM p.first_name) = ''::text) OR (p.first_name IS NULL) OR (TRIM(BOTH FROM p.last_name) = ''::text) OR (p.last_name IS NULL)) THEN split_part(p.email, '@'::text, 1)\n            ELSE concat(p.last_name, ' ', p.first_name)\n        END AS full_name,\n    p.email,\n    p.avatar_url,\n    p.work_format,\n    p.employment_rate,\n    pos.position_id,\n    COALESCE(pos.position_name, 'Без должности'::text) AS position_name,\n    p.department_id AS original_department_id,\n    COALESCE(d.department_name, 'Без отдела'::text) AS original_department_name,\n    p.team_id AS original_team_id,\n    COALESCE(t.team_name, 'Без команды'::text) AS original_team_name,\n    COALESCE(p.department_id, '00000000-0000-0000-0000-000000000000'::uuid) AS final_department_id,\n    COALESCE(d.department_name, 'Без отдела'::text) AS final_department_name,\n    COALESCE(p.team_id, '00000000-0000-0000-0000-000000000000'::uuid) AS final_team_id,\n    COALESCE(t.team_name, 'Без команды'::text) AS final_team_name,\n    cat.category_id,\n    COALESCE(cat.category_name, 'Без категории'::text) AS category_name,\n    NULL::uuid AS role_id,\n        CASE\n            WHEN (EXISTS ( SELECT 1\n               FROM (user_roles ur2\n                 JOIN roles r2 ON ((r2.id = ur2.role_id)))\n              WHERE ((ur2.user_id = p.user_id) AND (r2.name = 'admin'::text)))) THEN 'admin'::text\n            WHEN (EXISTS ( SELECT 1\n               FROM (user_roles ur2\n                 JOIN roles r2 ON ((r2.id = ur2.role_id)))\n              WHERE ((ur2.user_id = p.user_id) AND (r2.name = 'department_head'::text)))) THEN 'department_head'::text\n            WHEN (EXISTS ( SELECT 1\n               FROM (user_roles ur2\n                 JOIN roles r2 ON ((r2.id = ur2.role_id)))\n              WHERE ((ur2.user_id = p.user_id) AND (r2.name = 'team_lead'::text)))) THEN 'team_lead'::text\n            WHEN (EXISTS ( SELECT 1\n               FROM (user_roles ur2\n                 JOIN roles r2 ON ((r2.id = ur2.role_id)))\n              WHERE ((ur2.user_id = p.user_id) AND (r2.name = 'user'::text)))) THEN 'user'::text\n            ELSE NULL::text\n        END AS role_name,\n    l.loading_id,\n    l.loading_responsible,\n        CASE\n            WHEN (l.loading_stage IS NOT NULL) THEN ds.decomposition_stage_section_id\n            ELSE l.loading_section\n        END AS loading_section,\n    l.loading_start,\n    l.loading_finish,\n    l.loading_rate,\n    l.loading_status,\n    s.section_id,\n    s.section_name,\n    pr.project_id,\n    pr.project_name,\n    pr.project_status,\n        CASE\n            WHEN (l.loading_id IS NOT NULL) THEN true\n            ELSE false\n        END AS has_loadings,\n    count(l.loading_id) OVER (PARTITION BY p.user_id) AS loadings_count,\n    ds.decomposition_stage_id AS stage_id,\n    ds.decomposition_stage_name AS stage_name,\n    l.loading_comment,\n    o.object_id,\n    o.object_name\n   FROM (((((((((profiles p\n     LEFT JOIN departments d ON ((p.department_id = d.department_id)))\n     LEFT JOIN teams t ON ((p.team_id = t.team_id)))\n     LEFT JOIN positions pos ON ((p.position_id = pos.position_id)))\n     LEFT JOIN categories cat ON ((p.category_id = cat.category_id)))\n     LEFT JOIN loadings l ON (((p.user_id = l.loading_responsible) AND (l.loading_status = 'active'::loading_status_type))))\n     LEFT JOIN decomposition_stages ds ON ((ds.decomposition_stage_id = l.loading_stage)))\n     LEFT JOIN sections s ON ((((l.loading_stage IS NOT NULL) AND (s.section_id = ds.decomposition_stage_section_id)) OR ((l.loading_stage IS NULL) AND (s.section_id = l.loading_section)))))\n     LEFT JOIN projects pr ON ((pr.project_id = s.section_project_id)))\n     LEFT JOIN objects o ON ((o.object_id = s.section_object_id)))\n  ORDER BY d.department_name, t.team_name, p.last_name, p.first_name;"
  },
  {
    "schema": "public",
    "name": "view_integrity_violations",
    "sql_definition": " SELECT 'employee_wrong_department'::text AS violation_type,\n    concat(p.first_name, ' ', p.last_name) AS details,\n    p.user_id,\n    ((('Сотрудник отдела '::text || d1.department_name) || ' в команде отдела '::text) || d2.department_name) AS description\n   FROM (((profiles p\n     JOIN departments d1 ON ((p.department_id = d1.department_id)))\n     JOIN teams t ON ((p.team_id = t.team_id)))\n     JOIN departments d2 ON ((t.department_id = d2.department_id)))\n  WHERE (p.department_id <> t.department_id)\nUNION ALL\n SELECT 'department_head_in_own_department'::text AS violation_type,\n    concat(p.first_name, ' ', p.last_name) AS details,\n    p.user_id,\n    (('Руководитель отдела '::text || d.department_name) || ' является сотрудником того же отдела'::text) AS description\n   FROM (departments d\n     JOIN profiles p ON ((d.department_head_id = p.user_id)))\n  WHERE (p.department_id = d.department_id)\nUNION ALL\n SELECT 'team_lead_in_own_team'::text AS violation_type,\n    concat(p.first_name, ' ', p.last_name) AS details,\n    p.user_id,\n    (('Тимлид команды '::text || t.team_name) || ' является сотрудником той же команды'::text) AS description\n   FROM (teams t\n     JOIN profiles p ON ((t.team_lead_id = p.user_id)))\n  WHERE (p.team_id = t.team_id);"
  },
  {
    "schema": "public",
    "name": "view_manager_projects",
    "sql_definition": " SELECT p.project_id,\n    p.project_name,\n    p.project_manager AS manager_id,\n    prof.first_name AS manager_first_name,\n    prof.last_name AS manager_last_name,\n    concat(prof.first_name, ' ', prof.last_name) AS manager_name,\n    COALESCE(( SELECT jsonb_agg(jsonb_build_object('tag_id', pt.tag_id, 'name', pt.name, 'color', pt.color) ORDER BY pt.name) AS jsonb_agg\n           FROM (project_tag_links ptl\n             JOIN project_tags pt ON ((ptl.tag_id = pt.tag_id)))\n          WHERE (ptl.project_id = p.project_id)), '[]'::jsonb) AS project_tags\n   FROM (projects p\n     JOIN profiles prof ON ((p.project_manager = prof.user_id)))\n  WHERE (p.project_manager IS NOT NULL)\n  ORDER BY p.project_name;"
  },
  {
    "schema": "public",
    "name": "view_my_work_analytics",
    "sql_definition": " SELECT p.user_id,\n    COALESCE(comments_data.comments_count, (0)::bigint) AS comments_count,\n    COALESCE(mentions_data.mentions_count, (0)::bigint) AS mentions_count,\n    COALESCE(active_loadings_data.active_loadings_count, (0)::bigint) AS active_loadings_count,\n    COALESCE(archived_loadings_data.archived_loadings_count, (0)::bigint) AS archived_loadings_count,\n    COALESCE(today_hours_data.today_hours, (0)::numeric) AS today_hours,\n    COALESCE(week_hours_data.week_hours, (0)::numeric) AS week_hours,\n    COALESCE(responsibilities_data.responsibilities, '[]'::jsonb) AS responsibilities\n   FROM (((((((profiles p\n     LEFT JOIN ( SELECT section_comments.author_id AS user_id,\n            count(*) AS comments_count\n           FROM section_comments\n          GROUP BY section_comments.author_id) comments_data ON ((p.user_id = comments_data.user_id)))\n     LEFT JOIN ( SELECT unnest(section_comments.mentions) AS user_id,\n            count(*) AS mentions_count\n           FROM section_comments\n          WHERE ((section_comments.mentions IS NOT NULL) AND (array_length(section_comments.mentions, 1) > 0))\n          GROUP BY (unnest(section_comments.mentions))) mentions_data ON ((p.user_id = mentions_data.user_id)))\n     LEFT JOIN ( SELECT loadings.loading_responsible AS user_id,\n            count(*) AS active_loadings_count\n           FROM loadings\n          WHERE (loadings.loading_status = 'active'::loading_status_type)\n          GROUP BY loadings.loading_responsible) active_loadings_data ON ((p.user_id = active_loadings_data.user_id)))\n     LEFT JOIN ( SELECT loadings.loading_responsible AS user_id,\n            count(*) AS archived_loadings_count\n           FROM loadings\n          WHERE (loadings.loading_status = 'archived'::loading_status_type)\n          GROUP BY loadings.loading_responsible) archived_loadings_data ON ((p.user_id = archived_loadings_data.user_id)))\n     LEFT JOIN ( SELECT work_logs.work_log_created_by AS user_id,\n            sum(work_logs.work_log_hours) AS today_hours\n           FROM work_logs\n          WHERE (work_logs.work_log_date = CURRENT_DATE)\n          GROUP BY work_logs.work_log_created_by) today_hours_data ON ((p.user_id = today_hours_data.user_id)))\n     LEFT JOIN ( SELECT work_logs.work_log_created_by AS user_id,\n            sum(work_logs.work_log_hours) AS week_hours\n           FROM work_logs\n          WHERE (work_logs.work_log_date >= date_trunc('week'::text, (CURRENT_DATE)::timestamp with time zone))\n          GROUP BY work_logs.work_log_created_by) week_hours_data ON ((p.user_id = week_hours_data.user_id)))\n     LEFT JOIN ( WITH projects_manager AS (\n                 SELECT projects.project_manager AS user_id,\n                    jsonb_agg(jsonb_build_object('type', 'project_manager', 'entity_id', projects.project_id, 'entity_name', projects.project_name, 'entity_description', projects.project_description) ORDER BY projects.project_name) AS items\n                   FROM projects\n                  WHERE (projects.project_manager IS NOT NULL)\n                  GROUP BY projects.project_manager\n                ), projects_lead AS (\n                 SELECT projects.project_lead_engineer AS user_id,\n                    jsonb_agg(jsonb_build_object('type', 'lead_engineer', 'entity_id', projects.project_id, 'entity_name', projects.project_name, 'entity_description', projects.project_description) ORDER BY projects.project_name) AS items\n                   FROM projects\n                  WHERE (projects.project_lead_engineer IS NOT NULL)\n                  GROUP BY projects.project_lead_engineer\n                ), sections_resp AS (\n                 SELECT sections.section_responsible AS user_id,\n                    jsonb_agg(jsonb_build_object('type', 'section_responsible', 'entity_id', sections.section_id, 'entity_name', sections.section_name, 'entity_description', sections.section_description) ORDER BY sections.section_name) AS items\n                   FROM sections\n                  WHERE (sections.section_responsible IS NOT NULL)\n                  GROUP BY sections.section_responsible\n                )\n         SELECT u.user_id,\n            ((COALESCE(pm.items, '[]'::jsonb) || COALESCE(pl.items, '[]'::jsonb)) || COALESCE(sr.items, '[]'::jsonb)) AS responsibilities\n           FROM (((profiles u\n             LEFT JOIN projects_manager pm ON ((pm.user_id = u.user_id)))\n             LEFT JOIN projects_lead pl ON ((pl.user_id = u.user_id)))\n             LEFT JOIN sections_resp sr ON ((sr.user_id = u.user_id)))) responsibilities_data ON ((p.user_id = responsibilities_data.user_id)));"
  },
  {
    "schema": "public",
    "name": "view_organizational_structure",
    "sql_definition": " SELECT d.department_id,\n    d.department_name,\n    d.department_head_id,\n    concat(dh.first_name, ' ', dh.last_name) AS department_head_name,\n    dh.email AS department_head_email,\n    dh.avatar_url AS department_head_avatar_url,\n    concat(dh.first_name, ' ', dh.last_name) AS department_head_full_name,\n    t.team_id,\n    t.team_name,\n    t.team_lead_id,\n    concat(tl.first_name, ' ', tl.last_name) AS team_lead_name,\n    tl.email AS team_lead_email,\n    tl.avatar_url AS team_lead_avatar_url,\n    concat(tl.first_name, ' ', tl.last_name) AS team_lead_full_name,\n    p.user_id,\n    concat(p.first_name, ' ', p.last_name) AS employee_name,\n    p.first_name AS employee_first_name,\n    p.last_name AS employee_last_name,\n    p.work_format,\n    p.employment_rate,\n    ( SELECT count(DISTINCT p2.user_id) AS count\n           FROM profiles p2\n          WHERE (p2.department_id = d.department_id)) AS department_employee_count,\n    ( SELECT count(DISTINCT p2.user_id) AS count\n           FROM profiles p2\n          WHERE (p2.team_id = t.team_id)) AS team_employee_count\n   FROM ((((departments d\n     LEFT JOIN profiles dh ON ((d.department_head_id = dh.user_id)))\n     LEFT JOIN teams t ON ((d.department_id = t.department_id)))\n     LEFT JOIN profiles tl ON ((t.team_lead_id = tl.user_id)))\n     LEFT JOIN profiles p ON ((t.team_id = p.team_id)))\n  WHERE (d.department_name <> 'Без отдела'::text)\n  ORDER BY d.department_name, t.team_name, p.last_name;"
  },
  {
    "schema": "public",
    "name": "view_organizational_structure_ui",
    "sql_definition": " SELECT d.department_id,\n    d.department_name,\n    d.department_head_id,\n    concat(dh.first_name, ' ', dh.last_name) AS department_head_name,\n    dh.email AS department_head_email,\n    dh.avatar_url AS department_head_avatar_url,\n    t.team_id,\n    t.team_name,\n    t.team_lead_id,\n    concat(tl.first_name, ' ', tl.last_name) AS team_lead_name,\n    tl.email AS team_lead_email,\n    tl.avatar_url AS team_lead_avatar_url,\n    p.user_id,\n    concat(p.first_name, ' ', p.last_name) AS employee_name,\n    p.first_name AS employee_first_name,\n    p.last_name AS employee_last_name,\n    p.email AS employee_email,\n    p.avatar_url AS employee_avatar_url,\n    p.work_format,\n    p.employment_rate\n   FROM ((((departments d\n     LEFT JOIN profiles dh ON ((d.department_head_id = dh.user_id)))\n     LEFT JOIN teams t ON ((d.department_id = t.department_id)))\n     LEFT JOIN profiles tl ON ((t.team_lead_id = tl.user_id)))\n     LEFT JOIN profiles p ON ((t.team_id = p.team_id)))\n  WHERE (d.department_name <> 'Без отдела'::text)\n  ORDER BY d.department_name, t.team_name, p.last_name;"
  },
  {
    "schema": "public",
    "name": "view_planning_analytics_departments_2",
    "sql_definition": " WITH today_date AS (\n         SELECT CURRENT_DATE AS \"current_date\"\n        ), absence_users AS (\n         SELECT DISTINCT p_1.user_id,\n            p_1.department_id\n           FROM (((loadings l_1\n             JOIN sections s_1 ON ((l_1.loading_section = s_1.section_id)))\n             JOIN profiles p_1 ON ((l_1.loading_responsible = p_1.user_id)))\n             CROSS JOIN today_date td_1)\n          WHERE ((s_1.section_project_id = '80bea5b8-1ecc-4ace-8d73-91f26e67b898'::uuid) AND (l_1.loading_status = 'active'::loading_status_type) AND (l_1.loading_start <= td_1.\"current_date\") AND (l_1.loading_finish >= td_1.\"current_date\") AND (l_1.is_shortage = false) AND (p_1.department_id IS NOT NULL))\n        )\n SELECT ( SELECT CURRENT_DATE AS \"current_date\"\n           FROM today_date) AS analytics_date,\n    d.department_id,\n    d.department_name,\n    d.subdivision_id,\n    sub.subdivision_name,\n    count(DISTINCT p.user_id) AS total_users,\n    count(DISTINCT\n        CASE\n            WHEN ((l.loading_responsible IS NOT NULL) OR (au.user_id IS NOT NULL)) THEN p.user_id\n            ELSE NULL::uuid\n        END) AS users_with_loading,\n        CASE\n            WHEN (count(DISTINCT p.user_id) > 0) THEN round((((count(DISTINCT\n            CASE\n                WHEN ((l.loading_responsible IS NOT NULL) OR (au.user_id IS NOT NULL)) THEN p.user_id\n                ELSE NULL::uuid\n            END))::numeric / (count(DISTINCT p.user_id))::numeric) * (100)::numeric), 2)\n            ELSE (0)::numeric\n        END AS percentage_users_with_loading,\n    count(DISTINCT l.loading_section) AS sections_in_work_today,\n    count(DISTINCT s.section_project_id) AS projects_in_work_today,\n    array_agg(DISTINCT l.loading_section) FILTER (WHERE (l.loading_section IS NOT NULL)) AS section_ids_array,\n    array_agg(DISTINCT s.section_project_id) FILTER (WHERE (s.section_project_id IS NOT NULL)) AS project_ids_array,\n    COALESCE(sum(l.loading_rate), (0)::numeric) AS total_loading_rate,\n        CASE\n            WHEN (count(DISTINCT p.user_id) > 0) THEN round((COALESCE(sum(l.loading_rate), (0)::numeric) / (count(DISTINCT p.user_id))::numeric), 2)\n            ELSE (0)::numeric\n        END AS avg_department_loading,\n    ( SELECT jsonb_agg(jsonb_build_object('first_name', p2.first_name, 'last_name', p2.last_name, 'category_name', c.category_name) ORDER BY p2.last_name, p2.first_name) AS jsonb_agg\n           FROM (profiles p2\n             LEFT JOIN categories c ON ((p2.category_id = c.category_id)))\n          WHERE ((p2.department_id = d.department_id) AND (NOT (EXISTS ( SELECT 1\n                   FROM (loadings l2\n                     CROSS JOIN today_date td_1)\n                  WHERE ((l2.loading_responsible = p2.user_id) AND (l2.loading_status = 'active'::loading_status_type) AND (l2.loading_start <= td_1.\"current_date\") AND (l2.loading_finish >= td_1.\"current_date\") AND (l2.is_shortage = false))))) AND (NOT (EXISTS ( SELECT 1\n                   FROM absence_users au_1\n                  WHERE (au_1.user_id = p2.user_id)))))) AS users_without_loading,\n    count(l.loading_id) AS total_loadings_count,\n    count(DISTINCT au.user_id) AS absence_count\n   FROM ((((((departments d\n     LEFT JOIN subdivisions sub ON ((d.subdivision_id = sub.subdivision_id)))\n     CROSS JOIN today_date td)\n     LEFT JOIN profiles p ON ((p.department_id = d.department_id)))\n     LEFT JOIN absence_users au ON ((au.user_id = p.user_id)))\n     LEFT JOIN loadings l ON (((l.loading_responsible = p.user_id) AND (l.loading_status = 'active'::loading_status_type) AND (l.loading_start <= td.\"current_date\") AND (l.loading_finish >= td.\"current_date\") AND (l.is_shortage = false))))\n     LEFT JOIN sections s ON ((l.loading_section = s.section_id)))\n  GROUP BY d.department_id, d.department_name, d.subdivision_id, sub.subdivision_name\n  ORDER BY\n        CASE\n            WHEN (count(DISTINCT p.user_id) > 0) THEN round((COALESCE(sum(l.loading_rate), (0)::numeric) / (count(DISTINCT p.user_id))::numeric), 2)\n            ELSE (0)::numeric\n        END DESC;"
  },
  {
    "schema": "public",
    "name": "view_planning_analytics_departments_projects_2",
    "sql_definition": " WITH today_date AS (\n         SELECT CURRENT_DATE AS \"current_date\"\n        ), absence_users AS (\n         SELECT DISTINCT p.user_id,\n            p.department_id\n           FROM ((calendar_events ce\n             JOIN profiles p ON ((ce.calendar_event_created_by = p.user_id)))\n             CROSS JOIN today_date td)\n          WHERE ((ce.calendar_event_type = ANY (ARRAY['Отпуск одобрен'::calendar_event_type_enum, 'Больничный'::calendar_event_type_enum, 'Отгул'::calendar_event_type_enum])) AND (ce.calendar_event_is_global = false) AND (ce.calendar_event_date_start <= td.\"current_date\") AND (ce.calendar_event_date_end >= td.\"current_date\") AND (p.department_id IS NOT NULL))\n        ), department_projects AS (\n         SELECT d.department_id,\n            d.department_name,\n            d.subdivision_id,\n            sub.subdivision_name,\n            (p.project_id)::text AS project_id,\n            p.project_name,\n            count(l.loading_id) AS users_count,\n            COALESCE(sum(l.loading_rate), (0)::numeric) AS total_loading_rate\n           FROM ((((((departments d\n             LEFT JOIN subdivisions sub ON ((d.subdivision_id = sub.subdivision_id)))\n             CROSS JOIN today_date td)\n             LEFT JOIN profiles prof ON ((prof.department_id = d.department_id)))\n             LEFT JOIN loadings l ON (((l.loading_responsible = prof.user_id) AND (l.loading_status = 'active'::loading_status_type) AND (l.loading_start <= td.\"current_date\") AND (l.loading_finish >= td.\"current_date\") AND (l.is_shortage = false))))\n             LEFT JOIN sections s ON ((l.loading_section = s.section_id)))\n             LEFT JOIN projects p ON ((s.section_project_id = p.project_id)))\n          WHERE ((p.project_id IS NOT NULL) AND (l.loading_id IS NOT NULL))\n          GROUP BY d.department_id, d.department_name, d.subdivision_id, sub.subdivision_name, p.project_id, p.project_name\n         HAVING (COALESCE(sum(l.loading_rate), (0)::numeric) > (0)::numeric)\n        ), absence_projects AS (\n         SELECT d.department_id,\n            d.department_name,\n            d.subdivision_id,\n            sub.subdivision_name,\n            'absence'::text AS project_id,\n            'Отпуск/Больничный/Отгул'::text AS project_name,\n            count(DISTINCT au.user_id) AS users_count,\n            (count(DISTINCT au.user_id))::numeric AS total_loading_rate\n           FROM ((departments d\n             LEFT JOIN subdivisions sub ON ((d.subdivision_id = sub.subdivision_id)))\n             JOIN absence_users au ON ((au.department_id = d.department_id)))\n          GROUP BY d.department_id, d.department_name, d.subdivision_id, sub.subdivision_name\n         HAVING (count(DISTINCT au.user_id) > 0)\n        )\n SELECT ( SELECT CURRENT_DATE AS \"current_date\"\n           FROM today_date) AS analytics_date,\n    combined.department_id,\n    combined.department_name,\n    combined.subdivision_id,\n    combined.subdivision_name,\n    combined.project_id,\n    combined.project_name,\n    combined.users_count,\n    combined.total_loading_rate,\n    row_number() OVER (PARTITION BY combined.department_id ORDER BY combined.total_loading_rate DESC) AS rank\n   FROM ( SELECT department_projects.department_id,\n            department_projects.department_name,\n            department_projects.subdivision_id,\n            department_projects.subdivision_name,\n            department_projects.project_id,\n            department_projects.project_name,\n            department_projects.users_count,\n            department_projects.total_loading_rate\n           FROM department_projects\n        UNION ALL\n         SELECT absence_projects.department_id,\n            absence_projects.department_name,\n            absence_projects.subdivision_id,\n            absence_projects.subdivision_name,\n            absence_projects.project_id,\n            absence_projects.project_name,\n            absence_projects.users_count,\n            absence_projects.total_loading_rate\n           FROM absence_projects) combined\n  ORDER BY combined.department_id, (row_number() OVER (PARTITION BY combined.department_id ORDER BY combined.total_loading_rate DESC));"
  },
  {
    "schema": "public",
    "name": "view_planning_analytics_summary",
    "sql_definition": " WITH today_date AS (\n         SELECT CURRENT_DATE AS \"current_date\"\n        ), users_with_loading AS (\n         SELECT count(DISTINCT\n                CASE\n                    WHEN (l.loading_id IS NOT NULL) THEN p.user_id\n                    ELSE NULL::uuid\n                END) AS users_with_loading_count,\n            count(DISTINCT p.user_id) AS total_users_count,\n                CASE\n                    WHEN (count(DISTINCT p.user_id) > 0) THEN round((((count(DISTINCT\n                    CASE\n                        WHEN (l.loading_id IS NOT NULL) THEN p.user_id\n                        ELSE NULL::uuid\n                    END))::numeric / (count(DISTINCT p.user_id))::numeric) * (100)::numeric), 2)\n                    ELSE (0)::numeric\n                END AS percentage_users_with_loading\n           FROM ((profiles p\n             CROSS JOIN today_date td)\n             LEFT JOIN loadings l ON (((l.loading_responsible = p.user_id) AND (l.loading_status = 'active'::loading_status_type) AND (l.loading_start <= td.\"current_date\") AND (l.loading_finish >= td.\"current_date\") AND (l.is_shortage = false))))\n        ), sections_in_work AS (\n         SELECT count(DISTINCT l.loading_section) AS sections_count\n           FROM (loadings l\n             CROSS JOIN today_date td)\n          WHERE ((l.loading_status = 'active'::loading_status_type) AND (l.loading_start <= td.\"current_date\") AND (l.loading_finish >= td.\"current_date\") AND (l.is_shortage = false) AND (l.loading_section IS NOT NULL))\n        ), projects_in_work AS (\n         SELECT count(DISTINCT s.section_project_id) AS projects_count\n           FROM ((loadings l\n             CROSS JOIN today_date td)\n             JOIN sections s ON ((l.loading_section = s.section_id)))\n          WHERE ((l.loading_status = 'active'::loading_status_type) AND (l.loading_start <= td.\"current_date\") AND (l.loading_finish >= td.\"current_date\") AND (l.is_shortage = false) AND (s.section_project_id IS NOT NULL))\n        ), department_loading_per_dept AS (\n         SELECT d.department_id,\n            count(DISTINCT p.user_id) AS total_users,\n            COALESCE(sum(l.loading_rate), (0)::numeric) AS total_loading_rate,\n                CASE\n                    WHEN (count(DISTINCT p.user_id) > 0) THEN (COALESCE(sum(l.loading_rate), (0)::numeric) / (count(DISTINCT p.user_id))::numeric)\n                    ELSE (0)::numeric\n                END AS avg_loading_per_user\n           FROM (((departments d\n             CROSS JOIN today_date td)\n             LEFT JOIN profiles p ON ((p.department_id = d.department_id)))\n             LEFT JOIN loadings l ON (((l.loading_responsible = p.user_id) AND (l.loading_status = 'active'::loading_status_type) AND (l.loading_start <= td.\"current_date\") AND (l.loading_finish >= td.\"current_date\") AND (l.is_shortage = false))))\n          GROUP BY d.department_id\n        ), department_avg_loading AS (\n         SELECT round(avg(department_loading_per_dept.avg_loading_per_user), 2) AS avg_loading\n           FROM department_loading_per_dept\n        ), top_projects AS (\n         SELECT json_agg(json_build_object('project_id', pr.project_id, 'project_name', pr.project_name, 'total_loadings_count', pr.total_loadings_count, 'total_loading_rate', pr.total_loading_rate, 'rank', pr.rank) ORDER BY pr.rank) AS projects_data\n           FROM ( SELECT p.project_id,\n                    p.project_name,\n                    count(l.loading_id) AS total_loadings_count,\n                    COALESCE(sum(l.loading_rate), (0)::numeric) AS total_loading_rate,\n                    row_number() OVER (ORDER BY COALESCE(sum(l.loading_rate), (0)::numeric) DESC) AS rank\n                   FROM ((((projects p\n                     CROSS JOIN today_date td)\n                     LEFT JOIN sections s ON ((s.section_project_id = p.project_id)))\n                     LEFT JOIN loadings l ON (((l.loading_section = s.section_id) AND (l.loading_status = 'active'::loading_status_type) AND (l.loading_start <= td.\"current_date\") AND (l.loading_finish >= td.\"current_date\") AND (l.is_shortage = false))))\n                     JOIN profiles prof ON (((l.loading_responsible = prof.user_id) AND (prof.department_id IS NOT NULL))))\n                  GROUP BY p.project_id, p.project_name\n                 HAVING (COALESCE(sum(l.loading_rate), (0)::numeric) > (0)::numeric)) pr\n          WHERE (pr.rank <= 10)\n        )\n SELECT ( SELECT CURRENT_DATE AS \"current_date\"\n           FROM today_date) AS analytics_date,\n    uwl.users_with_loading_count,\n    uwl.total_users_count,\n    uwl.percentage_users_with_loading,\n    siw.sections_count AS sections_in_work_today,\n    piw.projects_count AS projects_in_work_today,\n    COALESCE(dal.avg_loading, (0)::numeric) AS avg_department_loading,\n    COALESCE(tp.projects_data, '[]'::json) AS top_projects_by_loading\n   FROM ((((users_with_loading uwl\n     CROSS JOIN sections_in_work siw)\n     CROSS JOIN projects_in_work piw)\n     CROSS JOIN department_avg_loading dal)\n     CROSS JOIN top_projects tp);"
  },
  {
    "schema": "public",
    "name": "view_planning_team_freshness",
    "sql_definition": " SELECT t.team_id,\n    t.team_name,\n    d.department_id,\n    d.department_name,\n    ( SELECT ta.confirmed_at\n           FROM teams_activity ta\n          WHERE (ta.team_id = t.team_id)\n          ORDER BY ta.confirmed_at DESC\n         LIMIT 1) AS last_confirmed_at,\n    ( SELECT GREATEST(COALESCE(max(l.loading_updated), '1970-01-01 00:00:00+00'::timestamp with time zone), COALESCE(max(l.loading_created), '1970-01-01 00:00:00+00'::timestamp with time zone)) AS \"greatest\"\n           FROM (loadings l\n             JOIN profiles p ON ((l.loading_responsible = p.user_id)))\n          WHERE (p.team_id = t.team_id)) AS last_loading_update,\n    ( SELECT (count(*))::integer AS count\n           FROM (loadings l\n             JOIN profiles p ON ((l.loading_responsible = p.user_id)))\n          WHERE ((p.team_id = t.team_id) AND (l.loading_status = 'active'::loading_status_type))) AS active_loadings_count,\n    GREATEST(COALESCE(( SELECT ta.confirmed_at\n           FROM teams_activity ta\n          WHERE (ta.team_id = t.team_id)\n          ORDER BY ta.confirmed_at DESC\n         LIMIT 1), '1970-01-01 00:00:00+00'::timestamp with time zone), COALESCE(( SELECT GREATEST(max(l.loading_updated), max(l.loading_created)) AS \"greatest\"\n           FROM (loadings l\n             JOIN profiles p ON ((l.loading_responsible = p.user_id)))\n          WHERE (p.team_id = t.team_id)), '1970-01-01 00:00:00+00'::timestamp with time zone)) AS last_update,\n    (EXTRACT(day FROM (CURRENT_TIMESTAMP - GREATEST(COALESCE(( SELECT ta.confirmed_at\n           FROM teams_activity ta\n          WHERE (ta.team_id = t.team_id)\n          ORDER BY ta.confirmed_at DESC\n         LIMIT 1), '1970-01-01 00:00:00+00'::timestamp with time zone), COALESCE(( SELECT GREATEST(max(l.loading_updated), max(l.loading_created)) AS \"greatest\"\n           FROM (loadings l\n             JOIN profiles p ON ((l.loading_responsible = p.user_id)))\n          WHERE (p.team_id = t.team_id)), '1970-01-01 00:00:00+00'::timestamp with time zone)))))::integer AS days_since_update\n   FROM (teams t\n     JOIN departments d ON ((t.department_id = d.department_id)))\n  WHERE (d.department_name <> 'Без отдела'::text)\n  ORDER BY d.department_name, t.team_name;"
  },
  {
    "schema": "public",
    "name": "view_project_dashboard",
    "sql_definition": " SELECT p.project_id,\n    COALESCE(di_agg.hours_planned_total, (0)::numeric) AS hours_planned_total,\n    COALESCE(wl_agg.hours_actual_total, (0)::numeric) AS hours_actual_total,\n    COALESCE(di_agg.decomposition_count, (0)::bigint) AS decomposition_count\n   FROM ((projects p\n     LEFT JOIN ( SELECT s.section_project_id AS project_id,\n            sum(di.decomposition_item_planned_hours) AS hours_planned_total,\n            count(di.decomposition_item_id) AS decomposition_count\n           FROM (sections s\n             JOIN decomposition_items di ON ((di.decomposition_item_section_id = s.section_id)))\n          GROUP BY s.section_project_id) di_agg ON ((di_agg.project_id = p.project_id)))\n     LEFT JOIN ( SELECT s.section_project_id AS project_id,\n            sum(wl.work_log_hours) AS hours_actual_total\n           FROM ((sections s\n             JOIN decomposition_items di ON ((di.decomposition_item_section_id = s.section_id)))\n             JOIN work_logs wl ON ((wl.decomposition_item_id = di.decomposition_item_id)))\n          GROUP BY s.section_project_id) wl_agg ON ((wl_agg.project_id = p.project_id)));"
  },
  {
    "schema": "public",
    "name": "view_project_summary",
    "sql_definition": " WITH project_bounds AS (\n         SELECT s.section_project_id AS project_id,\n            (min(s.section_start_date))::date AS project_start_date,\n            (max(s.section_end_date))::date AS project_end_date,\n            count(*) AS sections_count\n           FROM sections s\n          GROUP BY s.section_project_id\n        ), loadings_resolved AS (\n         SELECT COALESCE(ds.decomposition_stage_section_id, l.loading_section) AS section_id,\n            l.loading_id,\n            l.loading_responsible,\n            l.loading_start,\n            l.loading_finish,\n            l.loading_rate,\n            l.loading_status,\n            l.is_shortage\n           FROM (loadings l\n             LEFT JOIN decomposition_stages ds ON ((ds.decomposition_stage_id = l.loading_stage)))\n        ), project_loadings AS (\n         SELECT s.section_project_id AS project_id,\n            lr.loading_id,\n            lr.loading_responsible,\n            lr.loading_start,\n            lr.loading_finish,\n            lr.loading_rate,\n            lr.loading_status,\n            lr.is_shortage\n           FROM (loadings_resolved lr\n             JOIN sections s ON ((s.section_id = lr.section_id)))\n        ), today AS (\n         SELECT CURRENT_DATE AS d\n        ), project_loadings_today_agg AS (\n         SELECT pl.project_id,\n            count(DISTINCT pl.loading_responsible) AS employees_with_loadings_today,\n            count(pl.loading_id) AS loadings_count_today,\n            COALESCE(sum(pl.loading_rate), (0)::numeric) AS total_loading_rate_today\n           FROM (project_loadings pl\n             CROSS JOIN today t)\n          WHERE ((pl.loading_status = 'active'::loading_status_type) AND (pl.is_shortage = false) AND (pl.loading_start <= t.d) AND (pl.loading_finish >= t.d))\n          GROUP BY pl.project_id\n        ), project_loadings_active_agg AS (\n         SELECT pl.project_id,\n            count(DISTINCT pl.loading_responsible) AS employees_with_loadings_active,\n            count(pl.loading_id) AS loadings_count_active,\n            COALESCE(sum(pl.loading_rate), (0)::numeric) AS total_loading_rate_active\n           FROM project_loadings pl\n          WHERE ((pl.loading_status = 'active'::loading_status_type) AND (pl.is_shortage = false))\n          GROUP BY pl.project_id\n        ), engaged_employees AS (\n         SELECT ps.section_project_id AS project_id,\n            ps.section_responsible AS user_id\n           FROM sections ps\n          WHERE (ps.section_responsible IS NOT NULL)\n        UNION\n         SELECT s.section_project_id,\n            t.task_responsible\n           FROM (tasks t\n             JOIN sections s ON ((s.section_id = t.task_parent_section)))\n          WHERE (t.task_responsible IS NOT NULL)\n        UNION\n         SELECT s.section_project_id,\n            di.decomposition_item_responsible\n           FROM (decomposition_items di\n             JOIN sections s ON ((s.section_id = di.decomposition_item_section_id)))\n          WHERE (di.decomposition_item_responsible IS NOT NULL)\n        UNION\n         SELECT pla.project_id,\n            pla.loading_responsible\n           FROM project_loadings pla\n          WHERE ((pla.loading_responsible IS NOT NULL) AND (pla.loading_status = 'active'::loading_status_type) AND (pla.is_shortage = false))\n        ), engaged_employees_agg AS (\n         SELECT engaged_employees.project_id,\n            count(DISTINCT engaged_employees.user_id) AS engaged_employees_total\n           FROM engaged_employees\n          GROUP BY engaged_employees.project_id\n        ), engaged_employees_with_profiles AS (\n         SELECT ee.project_id,\n            ee.user_id,\n            p_1.first_name,\n            p_1.last_name,\n            p_1.email,\n            p_1.department_id,\n            p_1.team_id\n           FROM (engaged_employees ee\n             LEFT JOIN profiles p_1 ON ((p_1.user_id = ee.user_id)))\n        ), project_departments AS (\n         SELECT eep.project_id,\n            COALESCE(jsonb_agg(DISTINCT jsonb_build_object('department_id', d.department_id, 'department_name', d.department_name)) FILTER (WHERE (d.department_id IS NOT NULL)), '[]'::jsonb) AS departments_involved,\n            COALESCE(array_agg(DISTINCT d.department_id) FILTER (WHERE (d.department_id IS NOT NULL)), ARRAY[]::uuid[]) AS department_ids\n           FROM (engaged_employees_with_profiles eep\n             LEFT JOIN departments d ON ((d.department_id = eep.department_id)))\n          GROUP BY eep.project_id\n        ), project_teams AS (\n         SELECT eep.project_id,\n            COALESCE(jsonb_agg(DISTINCT jsonb_build_object('team_id', t.team_id, 'team_name', t.team_name)) FILTER (WHERE (t.team_id IS NOT NULL)), '[]'::jsonb) AS teams_involved,\n            COALESCE(array_agg(DISTINCT t.team_id) FILTER (WHERE (t.team_id IS NOT NULL)), ARRAY[]::uuid[]) AS team_ids\n           FROM (engaged_employees_with_profiles eep\n             LEFT JOIN teams t ON ((t.team_id = eep.team_id)))\n          GROUP BY eep.project_id\n        ), project_employees AS (\n         SELECT eep.project_id,\n            COALESCE(jsonb_agg(DISTINCT jsonb_build_object('user_id', eep.user_id, 'first_name', eep.first_name, 'last_name', eep.last_name, 'email', eep.email, 'department_id', eep.department_id, 'team_id', eep.team_id)) FILTER (WHERE (eep.user_id IS NOT NULL)), '[]'::jsonb) AS employees_involved,\n            COALESCE(array_agg(DISTINCT eep.user_id) FILTER (WHERE (eep.user_id IS NOT NULL)), ARRAY[]::uuid[]) AS employee_ids\n           FROM engaged_employees_with_profiles eep\n          GROUP BY eep.project_id\n        ), project_stages AS (\n         SELECT s.stage_project_id AS project_id,\n            COALESCE(jsonb_agg(jsonb_build_object('stage_id', s.stage_id, 'stage_name', s.stage_name, 'stage_description', s.stage_description) ORDER BY s.stage_created), '[]'::jsonb) AS stages_list\n           FROM stages s\n          GROUP BY s.stage_project_id\n        ), project_objects AS (\n         SELECT o.object_project_id AS project_id,\n            COALESCE(jsonb_agg(jsonb_build_object('object_id', o.object_id, 'object_name', o.object_name, 'object_description', o.object_description) ORDER BY o.object_created), '[]'::jsonb) AS objects_list\n           FROM objects o\n          GROUP BY o.object_project_id\n        )\n SELECT p.project_id,\n    p.project_name,\n    p.project_status,\n    p.project_created,\n    p.client_id,\n    c.client_name,\n    p.project_manager AS manager_id,\n    ((pm.first_name || ' '::text) || pm.last_name) AS manager_name,\n    pb.project_start_date,\n    pb.project_end_date,\n    pb.sections_count,\n    COALESCE(plt_agg.employees_with_loadings_today, (0)::bigint) AS employees_with_loadings_today,\n    COALESCE(plt_agg.loadings_count_today, (0)::bigint) AS loadings_count_today,\n    COALESCE(plt_agg.total_loading_rate_today, (0)::numeric) AS total_loading_rate_today,\n    COALESCE(pla_agg.employees_with_loadings_active, (0)::bigint) AS employees_with_loadings_active,\n    COALESCE(pla_agg.loadings_count_active, (0)::bigint) AS loadings_count_active,\n    COALESCE(pla_agg.total_loading_rate_active, (0)::numeric) AS total_loading_rate_active,\n    COALESCE(ee_agg.engaged_employees_total, (0)::bigint) AS engaged_employees_total,\n    COALESCE(pd.departments_involved, '[]'::jsonb) AS departments_involved,\n    COALESCE(ptm.teams_involved, '[]'::jsonb) AS teams_involved,\n    COALESCE(pe.employees_involved, '[]'::jsonb) AS employees_involved,\n    COALESCE(psg.stages_list, '[]'::jsonb) AS stages_list,\n    COALESCE(pobj.objects_list, '[]'::jsonb) AS objects_list,\n    COALESCE(pd.department_ids, ARRAY[]::uuid[]) AS department_ids,\n    COALESCE(ptm.team_ids, ARRAY[]::uuid[]) AS team_ids,\n    COALESCE(pe.employee_ids, ARRAY[]::uuid[]) AS employee_ids,\n    COALESCE(( SELECT jsonb_agg(jsonb_build_object('tag_id', pt.tag_id, 'name', pt.name, 'color', pt.color) ORDER BY pt.name) AS jsonb_agg\n           FROM (project_tag_links ptl\n             JOIN project_tags pt ON ((ptl.tag_id = pt.tag_id)))\n          WHERE (ptl.project_id = p.project_id)), '[]'::jsonb) AS project_tags\n   FROM (((((((((((projects p\n     LEFT JOIN clients c ON ((c.client_id = p.client_id)))\n     LEFT JOIN profiles pm ON ((pm.user_id = p.project_manager)))\n     LEFT JOIN project_bounds pb ON ((pb.project_id = p.project_id)))\n     LEFT JOIN project_loadings_today_agg plt_agg ON ((plt_agg.project_id = p.project_id)))\n     LEFT JOIN project_loadings_active_agg pla_agg ON ((pla_agg.project_id = p.project_id)))\n     LEFT JOIN engaged_employees_agg ee_agg ON ((ee_agg.project_id = p.project_id)))\n     LEFT JOIN project_departments pd ON ((pd.project_id = p.project_id)))\n     LEFT JOIN project_teams ptm ON ((ptm.project_id = p.project_id)))\n     LEFT JOIN project_employees pe ON ((pe.project_id = p.project_id)))\n     LEFT JOIN project_stages psg ON ((psg.project_id = p.project_id)))\n     LEFT JOIN project_objects pobj ON ((pobj.project_id = p.project_id)))\n  ORDER BY p.project_name;"
  },
  {
    "schema": "public",
    "name": "view_project_tree",
    "sql_definition": " WITH projects_with_managers AS (\n         SELECT p.project_id,\n            p.project_name,\n            p.project_description,\n            p.project_status,\n            p.project_created,\n            p.project_updated,\n            p.project_manager AS manager_id,\n            p.project_lead_engineer AS lead_engineer_id,\n            p.client_id,\n            c.client_name,\n                CASE\n                    WHEN (p.project_manager IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((pm.first_name || ' '::text) || pm.last_name)), ''::text), split_part(pm.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS manager_name,\n            pm.avatar_url AS manager_avatar,\n            COALESCE(( SELECT jsonb_agg(jsonb_build_object('tag_id', pt.tag_id, 'name', pt.name, 'color', pt.color) ORDER BY pt.name) AS jsonb_agg\n                   FROM (project_tag_links ptl\n                     JOIN project_tags pt ON ((ptl.tag_id = pt.tag_id)))\n                  WHERE (ptl.project_id = p.project_id)), '[]'::jsonb) AS project_tags\n           FROM ((projects p\n             LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n             LEFT JOIN clients c ON ((p.client_id = c.client_id)))\n        ), all_stages AS (\n         SELECT s.stage_id,\n            s.stage_name,\n            s.stage_description,\n            s.stage_project_id,\n            s.stage_created,\n            s.stage_updated,\n            s.external_id AS stage_external_id,\n            s.external_source AS stage_external_source\n           FROM stages s\n        ), all_objects AS (\n         SELECT o.object_id,\n            o.object_name,\n            o.object_description,\n            o.object_stage_id,\n            o.object_project_id,\n            o.object_start_date,\n            o.object_end_date,\n            o.object_created,\n            o.object_updated\n           FROM objects o\n        ), all_sections AS (\n         SELECT s.section_id,\n            s.section_name,\n            s.section_description,\n            s.section_object_id,\n            s.section_type,\n            s.section_start_date,\n            s.section_end_date,\n            s.section_created,\n            s.section_updated,\n            s.section_responsible,\n            s.section_status_id,\n                CASE\n                    WHEN (s.section_responsible IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((sr.first_name || ' '::text) || sr.last_name)), ''::text), split_part(sr.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS section_responsible_name,\n            sr.email AS section_responsible_email,\n            sr.avatar_url AS section_responsible_avatar,\n            sr.department_id AS responsible_department_id,\n            d.department_name AS responsible_department_name,\n            sr.team_id AS responsible_team_id,\n            t.team_name AS responsible_team_name\n           FROM (((sections s\n             LEFT JOIN profiles sr ON ((s.section_responsible = sr.user_id)))\n             LEFT JOIN departments d ON ((sr.department_id = d.department_id)))\n             LEFT JOIN teams t ON ((sr.team_id = t.team_id)))\n        )\n SELECT pwm.project_id,\n    ast.stage_id,\n    ao.object_id,\n    asec.section_id,\n    pwm.project_name,\n    ast.stage_name,\n    ao.object_name,\n    asec.section_name,\n    pwm.project_description,\n    ast.stage_description,\n    ao.object_description,\n    asec.section_description,\n    pwm.manager_id,\n    pwm.manager_name,\n    pwm.manager_avatar,\n    pwm.client_id,\n    pwm.client_name,\n    asec.section_responsible AS section_responsible_id,\n    asec.section_responsible_name,\n    asec.section_responsible_email,\n    asec.section_responsible_avatar,\n    asec.responsible_department_id,\n    asec.responsible_department_name,\n    asec.responsible_team_id,\n    asec.responsible_team_name,\n    pwm.project_status,\n    asec.section_type,\n    pwm.project_created,\n    pwm.project_updated,\n    ast.stage_created,\n    ast.stage_updated,\n    ao.object_start_date,\n    ao.object_end_date,\n    ao.object_created,\n    ao.object_updated,\n    asec.section_start_date,\n    asec.section_end_date,\n    asec.section_created,\n    asec.section_updated,\n    asec.section_status_id,\n    ss.name AS section_status_name,\n    ss.color AS section_status_color,\n    ast.stage_external_id,\n    ast.stage_external_source,\n        CASE\n            WHEN (asec.section_id IS NOT NULL) THEN 'section'::text\n            WHEN (ao.object_id IS NOT NULL) THEN 'object'::text\n            WHEN (ast.stage_id IS NOT NULL) THEN 'stage'::text\n            ELSE 'project'::text\n        END AS node_type,\n        CASE\n            WHEN (asec.section_id IS NOT NULL) THEN 4\n            WHEN (ao.object_id IS NOT NULL) THEN 3\n            WHEN (ast.stage_id IS NOT NULL) THEN 2\n            ELSE 1\n        END AS hierarchy_level,\n    (ufp.user_id IS NOT NULL) AS is_favorite,\n    pwm.project_tags,\n    pwm.lead_engineer_id,\n    (ao.object_stage_id IS NULL) AS object_is_stageless\n   FROM (((((projects_with_managers pwm\n     LEFT JOIN all_stages ast ON ((pwm.project_id = ast.stage_project_id)))\n     LEFT JOIN all_objects ao ON (((ao.object_stage_id = ast.stage_id) OR ((ao.object_stage_id IS NULL) AND (ao.object_project_id = pwm.project_id)))))\n     LEFT JOIN all_sections asec ON ((ao.object_id = asec.section_object_id)))\n     LEFT JOIN section_statuses ss ON ((asec.section_status_id = ss.id)))\n     LEFT JOIN user_favorite_projects ufp ON (((ufp.project_id = pwm.project_id) AND (ufp.user_id = auth.uid()))))\n  ORDER BY COALESCE(pwm.manager_name, 'Менеджер не назначен'::text), pwm.project_name, ast.stage_name, ao.object_name, asec.section_name;"
  },
  {
    "schema": "public",
    "name": "view_project_tree_backup",
    "sql_definition": " WITH projects_with_managers AS (\n         SELECT p.project_id,\n            p.project_name,\n            p.project_description,\n            p.project_status,\n            p.project_created,\n            p.project_updated,\n            p.project_manager AS manager_id,\n                CASE\n                    WHEN (p.project_manager IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((pm.first_name || ' '::text) || pm.last_name)), ''::text), split_part(pm.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS manager_name,\n            pm.avatar_url AS manager_avatar\n           FROM (projects p\n             LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n        ), all_stages AS (\n         SELECT s.stage_id,\n            s.stage_name,\n            s.stage_description,\n            s.stage_project_id,\n            s.stage_created,\n            s.stage_updated,\n            s.external_id AS stage_external_id,\n            s.external_source AS stage_external_source\n           FROM stages s\n        ), all_objects AS (\n         SELECT o.object_id,\n            o.object_name,\n            o.object_description,\n            o.object_stage_id,\n            o.object_start_date,\n            o.object_end_date,\n            o.object_created,\n            o.object_updated\n           FROM objects o\n        ), all_sections AS (\n         SELECT s.section_id,\n            s.section_name,\n            s.section_description,\n            s.section_object_id,\n            s.section_type,\n            s.section_start_date,\n            s.section_end_date,\n            s.section_created,\n            s.section_updated,\n            s.section_responsible,\n                CASE\n                    WHEN (s.section_responsible IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((sr.first_name || ' '::text) || sr.last_name)), ''::text), split_part(sr.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS section_responsible_name,\n            sr.email AS section_responsible_email,\n            sr.avatar_url AS section_responsible_avatar,\n            sr.department_id AS responsible_department_id,\n            d.department_name AS responsible_department_name,\n            sr.team_id AS responsible_team_id,\n            t.team_name AS responsible_team_name\n           FROM (((sections s\n             LEFT JOIN profiles sr ON ((s.section_responsible = sr.user_id)))\n             LEFT JOIN departments d ON ((sr.department_id = d.department_id)))\n             LEFT JOIN teams t ON ((sr.team_id = t.team_id)))\n        )\n SELECT pwm.project_id,\n    ast.stage_id,\n    ao.object_id,\n    asec.section_id,\n    pwm.project_name,\n    ast.stage_name,\n    ao.object_name,\n    asec.section_name,\n    pwm.project_description,\n    ast.stage_description,\n    ao.object_description,\n    asec.section_description,\n    pwm.manager_id,\n    pwm.manager_name,\n    pwm.manager_avatar,\n    asec.section_responsible AS section_responsible_id,\n    asec.section_responsible_name,\n    asec.section_responsible_email,\n    asec.section_responsible_avatar,\n    asec.responsible_department_id,\n    asec.responsible_department_name,\n    asec.responsible_team_id,\n    asec.responsible_team_name,\n    pwm.project_status,\n    asec.section_type,\n    pwm.project_created,\n    pwm.project_updated,\n    ast.stage_created,\n    ast.stage_updated,\n    ao.object_start_date,\n    ao.object_end_date,\n    ao.object_created,\n    ao.object_updated,\n    asec.section_start_date,\n    asec.section_end_date,\n    asec.section_created,\n    asec.section_updated,\n    ast.stage_external_id,\n    ast.stage_external_source,\n        CASE\n            WHEN (asec.section_id IS NOT NULL) THEN 'section'::text\n            WHEN (ao.object_id IS NOT NULL) THEN 'object'::text\n            WHEN (ast.stage_id IS NOT NULL) THEN 'stage'::text\n            ELSE 'project'::text\n        END AS node_type,\n        CASE\n            WHEN (asec.section_id IS NOT NULL) THEN 4\n            WHEN (ao.object_id IS NOT NULL) THEN 3\n            WHEN (ast.stage_id IS NOT NULL) THEN 2\n            ELSE 1\n        END AS hierarchy_level\n   FROM (((projects_with_managers pwm\n     LEFT JOIN all_stages ast ON ((pwm.project_id = ast.stage_project_id)))\n     LEFT JOIN all_objects ao ON ((ast.stage_id = ao.object_stage_id)))\n     LEFT JOIN all_sections asec ON ((ao.object_id = asec.section_object_id)))\n  ORDER BY COALESCE(pwm.manager_name, 'Менеджер не назначен'::text), pwm.project_name, ast.stage_name, ao.object_name, asec.section_name;"
  },
  {
    "schema": "public",
    "name": "view_project_tree_fixed",
    "sql_definition": " WITH projects_with_managers AS (\n         SELECT p.project_id,\n            p.project_name,\n            p.project_description,\n            p.project_status,\n            p.project_created,\n            p.project_updated,\n            p.project_manager AS manager_id,\n            p.project_lead_engineer AS lead_engineer_id,\n            p.client_id,\n            c.client_name,\n                CASE\n                    WHEN (p.project_manager IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((pm.first_name || ' '::text) || pm.last_name)), ''::text), split_part(pm.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS manager_name,\n            pm.avatar_url AS manager_avatar,\n            COALESCE(( SELECT jsonb_agg(jsonb_build_object('tag_id', pt.tag_id, 'name', pt.name, 'color', pt.color) ORDER BY pt.name) AS jsonb_agg\n                   FROM (project_tag_links ptl\n                     JOIN project_tags pt ON ((ptl.tag_id = pt.tag_id)))\n                  WHERE (ptl.project_id = p.project_id)), '[]'::jsonb) AS project_tags\n           FROM ((projects p\n             LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n             LEFT JOIN clients c ON ((p.client_id = c.client_id)))\n        ), all_stages AS (\n         SELECT s.stage_id,\n            s.stage_name,\n            s.stage_description,\n            s.stage_project_id,\n            s.stage_created,\n            s.stage_updated,\n            s.external_id AS stage_external_id,\n            s.external_source AS stage_external_source\n           FROM stages s\n        ), all_objects AS (\n         SELECT o.object_id,\n            o.object_name,\n            o.object_description,\n            o.object_stage_id,\n            o.object_project_id,\n            o.object_start_date,\n            o.object_end_date,\n            o.object_created,\n            o.object_updated\n           FROM objects o\n        ), all_sections AS (\n         SELECT s.section_id,\n            s.section_name,\n            s.section_description,\n            s.section_object_id,\n            s.section_type,\n            s.section_start_date,\n            s.section_end_date,\n            s.section_created,\n            s.section_updated,\n            s.section_responsible,\n            s.section_status_id,\n                CASE\n                    WHEN (s.section_responsible IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((sr.first_name || ' '::text) || sr.last_name)), ''::text), split_part(sr.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS section_responsible_name,\n            sr.email AS section_responsible_email,\n            sr.avatar_url AS section_responsible_avatar,\n            sr.department_id AS responsible_department_id,\n            d.department_name AS responsible_department_name,\n            sr.team_id AS responsible_team_id,\n            t.team_name AS responsible_team_name\n           FROM (((sections s\n             LEFT JOIN profiles sr ON ((s.section_responsible = sr.user_id)))\n             LEFT JOIN departments d ON ((sr.department_id = d.department_id)))\n             LEFT JOIN teams t ON ((sr.team_id = t.team_id)))\n        )\n SELECT pwm.project_id,\n    ast.stage_id,\n    ao.object_id,\n    asec.section_id,\n    pwm.project_name,\n    ast.stage_name,\n    ao.object_name,\n    asec.section_name,\n    pwm.project_description,\n    ast.stage_description,\n    ao.object_description,\n    asec.section_description,\n    pwm.manager_id,\n    pwm.manager_name,\n    pwm.manager_avatar,\n    pwm.client_id,\n    pwm.client_name,\n    asec.section_responsible AS section_responsible_id,\n    asec.section_responsible_name,\n    asec.section_responsible_email,\n    asec.section_responsible_avatar,\n    asec.responsible_department_id,\n    asec.responsible_department_name,\n    asec.responsible_team_id,\n    asec.responsible_team_name,\n    pwm.project_status,\n    asec.section_type,\n    pwm.project_created,\n    pwm.project_updated,\n    ast.stage_created,\n    ast.stage_updated,\n    ao.object_start_date,\n    ao.object_end_date,\n    ao.object_created,\n    ao.object_updated,\n    asec.section_start_date,\n    asec.section_end_date,\n    asec.section_created,\n    asec.section_updated,\n    asec.section_status_id,\n    ss.name AS section_status_name,\n    ss.color AS section_status_color,\n    ast.stage_external_id,\n    ast.stage_external_source,\n        CASE\n            WHEN (asec.section_id IS NOT NULL) THEN 'section'::text\n            WHEN (ao.object_id IS NOT NULL) THEN 'object'::text\n            WHEN (ast.stage_id IS NOT NULL) THEN 'stage'::text\n            ELSE 'project'::text\n        END AS node_type,\n        CASE\n            WHEN (asec.section_id IS NOT NULL) THEN 4\n            WHEN (ao.object_id IS NOT NULL) THEN 3\n            WHEN (ast.stage_id IS NOT NULL) THEN 2\n            ELSE 1\n        END AS hierarchy_level,\n    (ufp.user_id IS NOT NULL) AS is_favorite,\n    pwm.project_tags,\n    pwm.lead_engineer_id,\n    (ao.object_stage_id IS NULL) AS object_is_stageless\n   FROM (((((projects_with_managers pwm\n     LEFT JOIN all_stages ast ON ((pwm.project_id = ast.stage_project_id)))\n     LEFT JOIN all_objects ao ON (((ao.object_stage_id = ast.stage_id) OR ((ao.object_stage_id IS NULL) AND (ao.object_project_id = pwm.project_id)))))\n     LEFT JOIN all_sections asec ON ((ao.object_id = asec.section_object_id)))\n     LEFT JOIN section_statuses ss ON ((asec.section_status_id = ss.id)))\n     LEFT JOIN user_favorite_projects ufp ON (((ufp.project_id = pwm.project_id) AND (ufp.user_id = auth.uid()))))\n  ORDER BY COALESCE(pwm.manager_name, 'Менеджер не назначен'::text), pwm.project_name, ast.stage_name, ao.object_name, asec.section_name;"
  },
  {
    "schema": "public",
    "name": "view_project_tree_full",
    "sql_definition": " WITH all_projects AS (\n         SELECT p_1.project_id,\n            p_1.project_name,\n            p_1.project_description,\n            p_1.project_status,\n            p_1.project_manager,\n            p_1.stage_type,\n            p_1.project_created,\n            p_1.project_updated\n           FROM projects p_1\n        ), linked_stages AS (\n         SELECT s.stage_id,\n            s.stage_name,\n            s.stage_description,\n            s.stage_project_id AS project_id,\n            s.stage_created,\n            s.stage_updated,\n            s.external_id AS stage_external_id,\n            s.external_source AS stage_external_source\n           FROM stages s\n        ), virtual_stages AS (\n         SELECT gen_random_uuid() AS stage_id,\n            p_1.stage_type AS stage_name,\n            NULL::text AS stage_description,\n            p_1.project_id,\n            NULL::timestamp with time zone AS stage_created,\n            NULL::timestamp with time zone AS stage_updated,\n            NULL::text AS stage_external_id,\n            NULL::text AS stage_external_source\n           FROM projects p_1\n          WHERE ((p_1.stage_type IS NOT NULL) AND (NOT (EXISTS ( SELECT 1\n                   FROM stages s\n                  WHERE (s.stage_project_id = p_1.project_id)))))\n        ), all_stages AS (\n         SELECT linked_stages.stage_id,\n            linked_stages.stage_name,\n            linked_stages.stage_description,\n            linked_stages.project_id,\n            linked_stages.stage_created,\n            linked_stages.stage_updated,\n            linked_stages.stage_external_id,\n            linked_stages.stage_external_source\n           FROM linked_stages\n        UNION ALL\n         SELECT virtual_stages.stage_id,\n            virtual_stages.stage_name,\n            virtual_stages.stage_description,\n            virtual_stages.project_id,\n            virtual_stages.stage_created,\n            virtual_stages.stage_updated,\n            virtual_stages.stage_external_id,\n            virtual_stages.stage_external_source\n           FROM virtual_stages\n        ), all_objects AS (\n         SELECT o_1.object_id,\n            o_1.object_name,\n            o_1.object_description,\n            o_1.object_stage_id AS stage_id,\n            o_1.object_start_date,\n            o_1.object_end_date,\n            o_1.object_created,\n            o_1.object_updated\n           FROM objects o_1\n        ), all_sections AS (\n         SELECT s.section_id,\n            s.section_name,\n            s.section_description,\n            s.section_object_id AS object_id,\n            s.section_type,\n            s.section_start_date,\n            s.section_end_date,\n            s.section_status_id,\n            s.section_responsible,\n            s.section_created,\n            s.section_updated\n           FROM sections s\n        ), all_decomposition_stages AS (\n         SELECT ds_1.decomposition_stage_id,\n            ds_1.decomposition_stage_name,\n            ds_1.decomposition_stage_description,\n            ds_1.decomposition_stage_section_id AS section_id,\n            ds_1.decomposition_stage_start,\n            ds_1.decomposition_stage_finish,\n            ds_1.decomposition_stage_order,\n            ds_1.decomposition_stage_status_id,\n            ds_1.created_at AS decomposition_stage_created,\n            ds_1.updated_at AS decomposition_stage_updated\n           FROM decomposition_stages ds_1\n        )\n SELECT p.project_id,\n    st.stage_id,\n    o.object_id,\n    sec.section_id,\n    ds.decomposition_stage_id,\n    p.project_name,\n    st.stage_name,\n    o.object_name,\n    sec.section_name,\n    ds.decomposition_stage_name,\n    p.project_description,\n    st.stage_description,\n    o.object_description,\n    sec.section_description,\n    ds.decomposition_stage_description,\n    p.project_status,\n    p.project_manager,\n    p.project_created,\n    p.project_updated,\n    st.stage_created,\n    st.stage_updated,\n    st.stage_external_id,\n    st.stage_external_source,\n    o.object_start_date,\n    o.object_end_date,\n    o.object_created,\n    o.object_updated,\n    sec.section_type,\n    sec.section_start_date,\n    sec.section_end_date,\n    sec.section_status_id,\n    sec.section_responsible,\n    sec.section_created,\n    sec.section_updated,\n    ds.decomposition_stage_start,\n    ds.decomposition_stage_finish,\n    ds.decomposition_stage_order,\n    ds.decomposition_stage_status_id,\n    ds.decomposition_stage_created,\n    ds.decomposition_stage_updated,\n        CASE\n            WHEN (ds.decomposition_stage_id IS NOT NULL) THEN 'decomposition_stage'::text\n            WHEN (sec.section_id IS NOT NULL) THEN 'section'::text\n            WHEN (o.object_id IS NOT NULL) THEN 'object'::text\n            WHEN (st.stage_id IS NOT NULL) THEN 'stage'::text\n            ELSE 'project'::text\n        END AS node_type,\n        CASE\n            WHEN (ds.decomposition_stage_id IS NOT NULL) THEN 5\n            WHEN (sec.section_id IS NOT NULL) THEN 4\n            WHEN (o.object_id IS NOT NULL) THEN 3\n            WHEN (st.stage_id IS NOT NULL) THEN 2\n            ELSE 1\n        END AS hierarchy_level\n   FROM ((((all_projects p\n     LEFT JOIN all_stages st ON ((st.project_id = p.project_id)))\n     LEFT JOIN all_objects o ON ((o.stage_id = st.stage_id)))\n     LEFT JOIN all_sections sec ON ((sec.object_id = o.object_id)))\n     LEFT JOIN all_decomposition_stages ds ON ((ds.section_id = sec.section_id)))\n  ORDER BY p.project_name, st.stage_name, o.object_name, sec.section_name, ds.decomposition_stage_order, ds.decomposition_stage_name;"
  },
  {
    "schema": "public",
    "name": "view_project_tree_optimized",
    "sql_definition": " WITH project_hierarchy AS (\n         SELECT (p.project_id)::text AS node_id,\n            p.project_name AS node_name,\n            'project'::text AS node_type,\n            1 AS hierarchy_level,\n            p.project_id,\n            NULL::uuid AS object_id,\n            NULL::uuid AS section_id,\n            NULL::uuid AS decomposition_stage_id,\n            p.stage_type,\n            p.project_description AS description,\n            p.project_manager AS responsible_id,\n            NULL::timestamp without time zone AS start_date,\n            NULL::timestamp without time zone AS end_date,\n            p.project_name AS sort_path,\n            0 AS sort_order,\n            p.project_status,\n            p.project_manager AS manager_id,\n                CASE\n                    WHEN (p.project_manager IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((pm.first_name || ' '::text) || pm.last_name)), ''::text), split_part(pm.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS manager_name,\n            pm.avatar_url AS manager_avatar,\n            (ufp.user_id IS NOT NULL) AS is_favorite,\n            pu.involved_users\n           FROM (((projects p\n             LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n             LEFT JOIN user_favorite_projects ufp ON (((ufp.project_id = p.project_id) AND (ufp.user_id = auth.uid()))))\n             LEFT JOIN mat_project_involved_users pu ON ((pu.project_id = p.project_id)))\n        UNION ALL\n         SELECT (o.object_id)::text AS node_id,\n            o.object_name AS node_name,\n            'object'::text AS node_type,\n            2 AS hierarchy_level,\n            o.object_project_id AS project_id,\n            o.object_id,\n            NULL::uuid AS section_id,\n            NULL::uuid AS decomposition_stage_id,\n            p.stage_type,\n            o.object_description AS description,\n            o.object_responsible AS responsible_id,\n            o.object_start_date AS start_date,\n            o.object_end_date AS end_date,\n            o.object_name AS sort_path,\n            0 AS sort_order,\n            p.project_status,\n            p.project_manager AS manager_id,\n                CASE\n                    WHEN (p.project_manager IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((pm.first_name || ' '::text) || pm.last_name)), ''::text), split_part(pm.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS manager_name,\n            pm.avatar_url AS manager_avatar,\n            (ufp.user_id IS NOT NULL) AS is_favorite,\n            pu.involved_users\n           FROM ((((objects o\n             JOIN projects p ON ((o.object_project_id = p.project_id)))\n             LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n             LEFT JOIN user_favorite_projects ufp ON (((ufp.project_id = p.project_id) AND (ufp.user_id = auth.uid()))))\n             LEFT JOIN mat_project_involved_users pu ON ((pu.project_id = p.project_id)))\n        UNION ALL\n         SELECT (sec.section_id)::text AS node_id,\n            sec.section_name AS node_name,\n            'section'::text AS node_type,\n            3 AS hierarchy_level,\n            o.object_project_id AS project_id,\n            sec.section_object_id AS object_id,\n            sec.section_id,\n            NULL::uuid AS decomposition_stage_id,\n            p.stage_type,\n            sec.section_description AS description,\n            sec.section_responsible AS responsible_id,\n            sec.section_start_date AS start_date,\n            sec.section_end_date AS end_date,\n            sec.section_name AS sort_path,\n            0 AS sort_order,\n            p.project_status,\n            p.project_manager AS manager_id,\n                CASE\n                    WHEN (p.project_manager IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((pm.first_name || ' '::text) || pm.last_name)), ''::text), split_part(pm.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS manager_name,\n            pm.avatar_url AS manager_avatar,\n            (ufp.user_id IS NOT NULL) AS is_favorite,\n            pu.involved_users\n           FROM (((((sections sec\n             JOIN objects o ON ((sec.section_object_id = o.object_id)))\n             JOIN projects p ON ((o.object_project_id = p.project_id)))\n             LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n             LEFT JOIN user_favorite_projects ufp ON (((ufp.project_id = p.project_id) AND (ufp.user_id = auth.uid()))))\n             LEFT JOIN mat_project_involved_users pu ON ((pu.project_id = p.project_id)))\n        UNION ALL\n         SELECT (ds.decomposition_stage_id)::text AS node_id,\n            ds.decomposition_stage_name AS node_name,\n            'decomposition_stage'::text AS node_type,\n            4 AS hierarchy_level,\n            o.object_project_id AS project_id,\n            sec.section_object_id AS object_id,\n            ds.decomposition_stage_section_id AS section_id,\n            ds.decomposition_stage_id,\n            p.stage_type,\n            ds.decomposition_stage_description AS description,\n            NULL::uuid AS responsible_id,\n            ds.decomposition_stage_start AS start_date,\n            ds.decomposition_stage_finish AS end_date,\n            ds.decomposition_stage_name AS sort_path,\n            ds.decomposition_stage_order AS sort_order,\n            p.project_status,\n            p.project_manager AS manager_id,\n                CASE\n                    WHEN (p.project_manager IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((pm.first_name || ' '::text) || pm.last_name)), ''::text), split_part(pm.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS manager_name,\n            pm.avatar_url AS manager_avatar,\n            (ufp.user_id IS NOT NULL) AS is_favorite,\n            pu.involved_users\n           FROM ((((((decomposition_stages ds\n             JOIN sections sec ON ((ds.decomposition_stage_section_id = sec.section_id)))\n             JOIN objects o ON ((sec.section_object_id = o.object_id)))\n             JOIN projects p ON ((o.object_project_id = p.project_id)))\n             LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n             LEFT JOIN user_favorite_projects ufp ON (((ufp.project_id = p.project_id) AND (ufp.user_id = auth.uid()))))\n             LEFT JOIN mat_project_involved_users pu ON ((pu.project_id = p.project_id)))\n        )\n SELECT project_hierarchy.node_id,\n    project_hierarchy.node_name,\n    project_hierarchy.node_type,\n    project_hierarchy.hierarchy_level,\n    project_hierarchy.project_id,\n    project_hierarchy.object_id,\n    project_hierarchy.section_id,\n    project_hierarchy.decomposition_stage_id,\n    project_hierarchy.stage_type,\n    project_hierarchy.description,\n    project_hierarchy.responsible_id,\n    project_hierarchy.start_date,\n    project_hierarchy.end_date,\n    project_hierarchy.sort_path,\n    project_hierarchy.sort_order,\n    project_hierarchy.project_status,\n    project_hierarchy.manager_id,\n    project_hierarchy.manager_name,\n    project_hierarchy.manager_avatar,\n    project_hierarchy.is_favorite,\n    project_hierarchy.involved_users\n   FROM project_hierarchy\n  ORDER BY project_hierarchy.hierarchy_level, project_hierarchy.sort_path, project_hierarchy.sort_order;"
  },
  {
    "schema": "public",
    "name": "view_project_tree_v2",
    "sql_definition": " WITH projects_with_managers AS (\n         SELECT p.project_id,\n            p.project_name,\n            p.project_description,\n            p.project_status,\n            p.project_created,\n            p.project_updated,\n            p.project_manager AS manager_id,\n            p.project_lead_engineer AS lead_engineer_id,\n            p.client_id,\n            c.client_name,\n                CASE\n                    WHEN (p.project_manager IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((pm.first_name || ' '::text) || pm.last_name)), ''::text), split_part(pm.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS manager_name,\n            pm.avatar_url AS manager_avatar,\n            COALESCE(( SELECT jsonb_agg(jsonb_build_object('tag_id', pt.tag_id, 'name', pt.name, 'color', pt.color) ORDER BY pt.name) AS jsonb_agg\n                   FROM (project_tag_links ptl\n                     JOIN project_tags pt ON ((ptl.tag_id = pt.tag_id)))\n                  WHERE (ptl.project_id = p.project_id)), '[]'::jsonb) AS project_tags\n           FROM ((projects p\n             LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n             LEFT JOIN clients c ON ((p.client_id = c.client_id)))\n        ), all_stages AS (\n         SELECT s.stage_id,\n            s.stage_name,\n            s.stage_description,\n            s.stage_project_id,\n            s.stage_created,\n            s.stage_updated,\n            s.external_id AS stage_external_id,\n            s.external_source AS stage_external_source\n           FROM stages s\n        ), all_objects AS (\n         SELECT o.object_id,\n            o.object_name,\n            o.object_description,\n            o.object_stage_id,\n            o.object_project_id,\n            o.object_start_date,\n            o.object_end_date,\n            o.object_created,\n            o.object_updated\n           FROM objects o\n        ), all_sections AS (\n         SELECT s.section_id,\n            s.section_name,\n            s.section_description,\n            s.section_object_id,\n            s.section_type,\n            s.section_start_date,\n            s.section_end_date,\n            s.section_created,\n            s.section_updated,\n            s.section_responsible,\n            s.section_status_id,\n                CASE\n                    WHEN (s.section_responsible IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((sr.first_name || ' '::text) || sr.last_name)), ''::text), split_part(sr.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS section_responsible_name,\n            sr.email AS section_responsible_email,\n            sr.avatar_url AS section_responsible_avatar,\n            sr.department_id AS responsible_department_id,\n            d.department_name AS responsible_department_name,\n            sr.team_id AS responsible_team_id,\n            t.team_name AS responsible_team_name\n           FROM (((sections s\n             LEFT JOIN profiles sr ON ((s.section_responsible = sr.user_id)))\n             LEFT JOIN departments d ON ((sr.department_id = d.department_id)))\n             LEFT JOIN teams t ON ((sr.team_id = t.team_id)))\n        )\n SELECT pwm.project_id,\n    ast.stage_id,\n    ao.object_id,\n    asec.section_id,\n    pwm.project_name,\n    ast.stage_name,\n    ao.object_name,\n    asec.section_name,\n    pwm.project_description,\n    ast.stage_description,\n    ao.object_description,\n    asec.section_description,\n    pwm.manager_id,\n    pwm.manager_name,\n    pwm.manager_avatar,\n    pwm.client_id,\n    pwm.client_name,\n    asec.section_responsible AS section_responsible_id,\n    asec.section_responsible_name,\n    asec.section_responsible_email,\n    asec.section_responsible_avatar,\n    asec.responsible_department_id,\n    asec.responsible_department_name,\n    asec.responsible_team_id,\n    asec.responsible_team_name,\n    pwm.project_status,\n    asec.section_type,\n    pwm.project_created,\n    pwm.project_updated,\n    ast.stage_created,\n    ast.stage_updated,\n    ao.object_start_date,\n    ao.object_end_date,\n    ao.object_created,\n    ao.object_updated,\n    asec.section_start_date,\n    asec.section_end_date,\n    asec.section_created,\n    asec.section_updated,\n    asec.section_status_id,\n    ss.name AS section_status_name,\n    ss.color AS section_status_color,\n    ast.stage_external_id,\n    ast.stage_external_source,\n        CASE\n            WHEN (asec.section_id IS NOT NULL) THEN 'section'::text\n            WHEN (ao.object_id IS NOT NULL) THEN 'object'::text\n            WHEN (ast.stage_id IS NOT NULL) THEN 'stage'::text\n            ELSE 'project'::text\n        END AS node_type,\n        CASE\n            WHEN (asec.section_id IS NOT NULL) THEN 4\n            WHEN (ao.object_id IS NOT NULL) THEN 3\n            WHEN (ast.stage_id IS NOT NULL) THEN 2\n            ELSE 1\n        END AS hierarchy_level,\n    (ufp.user_id IS NOT NULL) AS is_favorite,\n    pwm.project_tags,\n    pwm.lead_engineer_id,\n    (ao.object_stage_id IS NULL) AS object_is_stageless\n   FROM (((((projects_with_managers pwm\n     LEFT JOIN all_stages ast ON ((pwm.project_id = ast.stage_project_id)))\n     LEFT JOIN all_objects ao ON (((ao.object_stage_id = ast.stage_id) OR ((ao.object_stage_id IS NULL) AND (ao.object_project_id = pwm.project_id)))))\n     LEFT JOIN all_sections asec ON ((ao.object_id = asec.section_object_id)))\n     LEFT JOIN section_statuses ss ON ((asec.section_status_id = ss.id)))\n     LEFT JOIN user_favorite_projects ufp ON (((ufp.project_id = pwm.project_id) AND (ufp.user_id = auth.uid()))))\n  ORDER BY COALESCE(pwm.manager_name, 'Менеджер не назначен'::text), pwm.project_name, ast.stage_name, ao.object_name, asec.section_name;"
  },
  {
    "schema": "public",
    "name": "view_project_tree_v3",
    "sql_definition": " WITH projects_with_managers AS (\n         SELECT p.project_id,\n            p.project_name,\n            p.project_description,\n            p.project_status,\n            p.project_created,\n            p.project_updated,\n            p.project_manager AS manager_id,\n            p.project_lead_engineer AS lead_engineer_id,\n            p.client_id,\n            c.client_name,\n                CASE\n                    WHEN (p.project_manager IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((pm.first_name || ' '::text) || pm.last_name)), ''::text), split_part(pm.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS manager_name,\n            pm.avatar_url AS manager_avatar,\n            COALESCE(( SELECT jsonb_agg(jsonb_build_object('tag_id', pt.tag_id, 'name', pt.name, 'color', pt.color) ORDER BY pt.name) AS jsonb_agg\n                   FROM (project_tag_links ptl\n                     JOIN project_tags pt ON ((ptl.tag_id = pt.tag_id)))\n                  WHERE (ptl.project_id = p.project_id)), '[]'::jsonb) AS project_tags\n           FROM ((projects p\n             LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n             LEFT JOIN clients c ON ((p.client_id = c.client_id)))\n        ), all_stages AS (\n         SELECT s.stage_id,\n            s.stage_name,\n            s.stage_description,\n            s.stage_project_id,\n            s.stage_created,\n            s.stage_updated,\n            s.external_id AS stage_external_id,\n            s.external_source AS stage_external_source\n           FROM stages s\n        ), all_objects AS (\n         SELECT o.object_id,\n            o.object_name,\n            o.object_description,\n            o.object_stage_id,\n            o.object_start_date,\n            o.object_end_date,\n            o.object_created,\n            o.object_updated\n           FROM objects o\n        ), all_sections AS (\n         SELECT s.section_id,\n            s.section_name,\n            s.section_description,\n            s.section_object_id,\n            s.section_type,\n            s.section_start_date,\n            s.section_end_date,\n            s.section_created,\n            s.section_updated,\n            s.section_responsible,\n            s.section_status_id,\n                CASE\n                    WHEN (s.section_responsible IS NOT NULL) THEN COALESCE(NULLIF(TRIM(BOTH FROM ((sr.first_name || ' '::text) || sr.last_name)), ''::text), split_part(sr.email, '@'::text, 1))\n                    ELSE NULL::text\n                END AS section_responsible_name,\n            sr.email AS section_responsible_email,\n            sr.avatar_url AS section_responsible_avatar,\n            sr.department_id AS responsible_department_id,\n            d.department_name AS responsible_department_name,\n            sr.team_id AS responsible_team_id,\n            t.team_name AS responsible_team_name\n           FROM (((sections s\n             LEFT JOIN profiles sr ON ((s.section_responsible = sr.user_id)))\n             LEFT JOIN departments d ON ((sr.department_id = d.department_id)))\n             LEFT JOIN teams t ON ((sr.team_id = t.team_id)))\n        )\n SELECT pwm.project_id,\n    ast.stage_id,\n    ao.object_id,\n    asec.section_id,\n    pwm.project_name,\n    ast.stage_name,\n    ao.object_name,\n    asec.section_name,\n    pwm.project_description,\n    ast.stage_description,\n    ao.object_description,\n    asec.section_description,\n    pwm.manager_id,\n    pwm.manager_name,\n    pwm.manager_avatar,\n    pwm.client_id,\n    pwm.client_name,\n    asec.section_responsible AS section_responsible_id,\n    asec.section_responsible_name,\n    asec.section_responsible_email,\n    asec.section_responsible_avatar,\n    asec.responsible_department_id,\n    asec.responsible_department_name,\n    asec.responsible_team_id,\n    asec.responsible_team_name,\n    pwm.project_status,\n    asec.section_type,\n    pwm.project_created,\n    pwm.project_updated,\n    ast.stage_created,\n    ast.stage_updated,\n    ao.object_start_date,\n    ao.object_end_date,\n    ao.object_created,\n    ao.object_updated,\n    asec.section_start_date,\n    asec.section_end_date,\n    asec.section_created,\n    asec.section_updated,\n    asec.section_status_id,\n    ss.name AS section_status_name,\n    ss.color AS section_status_color,\n    ast.stage_external_id,\n    ast.stage_external_source,\n        CASE\n            WHEN (asec.section_id IS NOT NULL) THEN 'section'::text\n            WHEN (ao.object_id IS NOT NULL) THEN 'object'::text\n            WHEN (ast.stage_id IS NOT NULL) THEN 'stage'::text\n            ELSE 'project'::text\n        END AS node_type,\n        CASE\n            WHEN (asec.section_id IS NOT NULL) THEN 4\n            WHEN (ao.object_id IS NOT NULL) THEN 3\n            WHEN (ast.stage_id IS NOT NULL) THEN 2\n            ELSE 1\n        END AS hierarchy_level,\n    (ufp.user_id IS NOT NULL) AS is_favorite,\n    pwm.project_tags,\n    pwm.lead_engineer_id\n   FROM (((((projects_with_managers pwm\n     LEFT JOIN all_stages ast ON ((pwm.project_id = ast.stage_project_id)))\n     LEFT JOIN all_objects ao ON ((ast.stage_id = ao.object_stage_id)))\n     LEFT JOIN all_sections asec ON ((ao.object_id = asec.section_object_id)))\n     LEFT JOIN section_statuses ss ON ((asec.section_status_id = ss.id)))\n     LEFT JOIN user_favorite_projects ufp ON (((ufp.project_id = pwm.project_id) AND (ufp.user_id = auth.uid()))))\n  ORDER BY COALESCE(pwm.manager_name, 'Менеджер не назначен'::text), pwm.project_name, ast.stage_name, ao.object_name, asec.section_name;"
  },
  {
    "schema": "public",
    "name": "view_project_tree_with_loadings",
    "sql_definition": " SELECT sh.project_id,\n    sh.project_name,\n    sh.project_description,\n    sh.project_status,\n    sh.project_created,\n    sh.project_updated,\n    sh.stage_id,\n    sh.stage_name,\n    sh.stage_description,\n    sh.object_id,\n    sh.object_name,\n    sh.object_description,\n    sh.object_start_date,\n    sh.object_end_date,\n    sh.object_created,\n    sh.object_updated,\n    sh.object_is_stageless,\n    sh.section_id,\n    sh.section_name,\n    sh.section_description,\n    sh.section_type,\n    sh.section_start_date,\n    sh.section_end_date,\n    sh.section_created,\n    sh.section_updated,\n    sh.section_responsible_id,\n    sh.section_responsible_name,\n    sh.section_responsible_email,\n    sh.responsible_department_id,\n    sh.responsible_department_name,\n    sh.responsible_team_id,\n    sh.responsible_team_name,\n    sh.total_loading_rate AS section_total_loading_rate,\n    sh.tasks_count AS section_tasks_count,\n    sh.latest_plan_loading_status,\n    sh.section_responsible_avatar,\n    ds.decomposition_stage_id,\n    ds.decomposition_stage_name,\n    ds.decomposition_stage_description,\n    ds.decomposition_stage_start,\n    ds.decomposition_stage_finish,\n    ds.decomposition_stage_order,\n    ds.decomposition_stage_status_id,\n    ds.created_at AS decomposition_stage_created_at,\n    ds.updated_at AS decomposition_stage_updated_at,\n    st_status.name AS decomposition_stage_status_name,\n    st_status.color AS decomposition_stage_status_color,\n    l.loading_id,\n    l.loading_start,\n    l.loading_finish,\n    l.loading_rate,\n    l.loading_status,\n    l.is_shortage,\n    l.loading_task,\n    l.loading_comment,\n    l.loading_created,\n    l.loading_updated,\n    l.loading_responsible AS loading_responsible_id,\n    lp.first_name AS loading_responsible_first_name,\n    lp.last_name AS loading_responsible_last_name,\n        CASE\n            WHEN ((lp.first_name IS NOT NULL) OR (lp.last_name IS NOT NULL)) THEN btrim(((COALESCE(lp.first_name, ''::text) || ' '::text) || COALESCE(lp.last_name, ''::text)))\n            ELSE NULL::text\n        END AS loading_responsible_full_name,\n    lp.email AS loading_responsible_email,\n    lp.avatar_url AS loading_responsible_avatar,\n    lp.department_id AS loading_responsible_department_id,\n    ld.department_name AS loading_responsible_department_name,\n    lp.team_id AS loading_responsible_team_id,\n    lt.team_name AS loading_responsible_team_name,\n    l.shortage_department_id,\n    sd.department_name AS shortage_department_name,\n    l.shortage_team_id,\n    st.team_name AS shortage_team_name\n   FROM ((((((((view_section_hierarchy sh\n     LEFT JOIN decomposition_stages ds ON ((ds.decomposition_stage_section_id = sh.section_id)))\n     LEFT JOIN section_statuses st_status ON ((st_status.id = ds.decomposition_stage_status_id)))\n     LEFT JOIN loadings l ON (((l.loading_stage = ds.decomposition_stage_id) OR ((ds.decomposition_stage_id IS NULL) AND (l.loading_stage IS NULL) AND (l.loading_section = sh.section_id)))))\n     LEFT JOIN profiles lp ON ((lp.user_id = l.loading_responsible)))\n     LEFT JOIN departments ld ON ((ld.department_id = lp.department_id)))\n     LEFT JOIN teams lt ON ((lt.team_id = lp.team_id)))\n     LEFT JOIN departments sd ON ((sd.department_id = l.shortage_department_id)))\n     LEFT JOIN teams st ON ((st.team_id = l.shortage_team_id)))\n  ORDER BY sh.project_name, sh.stage_name, sh.object_name, sh.section_name, ds.decomposition_stage_order, l.loading_start;"
  },
  {
    "schema": "public",
    "name": "view_project_tree_with_loadings_fixed",
    "sql_definition": " SELECT sh.project_id,\n    sh.project_name,\n    sh.project_description,\n    sh.project_status,\n    sh.project_created,\n    sh.project_updated,\n    sh.stage_id,\n    sh.stage_name,\n    sh.stage_description,\n    sh.object_id,\n    sh.object_name,\n    sh.object_description,\n    sh.object_start_date,\n    sh.object_end_date,\n    sh.object_created,\n    sh.object_updated,\n    sh.section_id,\n    sh.section_name,\n    sh.section_description,\n    sh.section_type,\n    sh.section_start_date,\n    sh.section_end_date,\n    sh.section_created,\n    sh.section_updated,\n    sh.section_responsible_id,\n    sh.section_responsible_name,\n    sh.section_responsible_email,\n    sh.responsible_department_id,\n    sh.responsible_department_name,\n    sh.responsible_team_id,\n    sh.responsible_team_name,\n    sh.total_loading_rate AS section_total_loading_rate,\n    sh.tasks_count AS section_tasks_count,\n    sh.latest_plan_loading_status,\n    sh.section_responsible_avatar,\n    ds.decomposition_stage_id,\n    ds.decomposition_stage_name,\n    ds.decomposition_stage_description,\n    ds.decomposition_stage_start,\n    ds.decomposition_stage_finish,\n    ds.decomposition_stage_order,\n    ds.decomposition_stage_status_id,\n    ds.created_at AS decomposition_stage_created_at,\n    ds.updated_at AS decomposition_stage_updated_at,\n    st_status.name AS decomposition_stage_status_name,\n    st_status.color AS decomposition_stage_status_color,\n    l.loading_id,\n    l.loading_start,\n    l.loading_finish,\n    l.loading_rate,\n    l.loading_status,\n    l.is_shortage,\n    l.loading_task,\n    l.loading_comment,\n    l.loading_created,\n    l.loading_updated,\n    l.loading_responsible AS loading_responsible_id,\n    lp.first_name AS loading_responsible_first_name,\n    lp.last_name AS loading_responsible_last_name,\n        CASE\n            WHEN ((lp.first_name IS NOT NULL) OR (lp.last_name IS NOT NULL)) THEN btrim(((COALESCE(lp.first_name, ''::text) || ' '::text) || COALESCE(lp.last_name, ''::text)))\n            ELSE NULL::text\n        END AS loading_responsible_full_name,\n    lp.email AS loading_responsible_email,\n    lp.avatar_url AS loading_responsible_avatar,\n    lp.department_id AS loading_responsible_department_id,\n    ld.department_name AS loading_responsible_department_name,\n    lp.team_id AS loading_responsible_team_id,\n    lt.team_name AS loading_responsible_team_name,\n    l.shortage_department_id,\n    sd.department_name AS shortage_department_name,\n    l.shortage_team_id,\n    st.team_name AS shortage_team_name\n   FROM ((((((((view_section_hierarchy_fixed sh\n     LEFT JOIN decomposition_stages ds ON ((ds.decomposition_stage_section_id = sh.section_id)))\n     LEFT JOIN section_statuses st_status ON ((st_status.id = ds.decomposition_stage_status_id)))\n     LEFT JOIN loadings l ON (((l.loading_stage = ds.decomposition_stage_id) OR ((ds.decomposition_stage_id IS NULL) AND (l.loading_stage IS NULL) AND (l.loading_section = sh.section_id)))))\n     LEFT JOIN profiles lp ON ((lp.user_id = l.loading_responsible)))\n     LEFT JOIN departments ld ON ((ld.department_id = lp.department_id)))\n     LEFT JOIN teams lt ON ((lt.team_id = lp.team_id)))\n     LEFT JOIN departments sd ON ((sd.department_id = l.shortage_department_id)))\n     LEFT JOIN teams st ON ((st.team_id = l.shortage_team_id)))\n  ORDER BY sh.project_name, sh.stage_name, sh.object_name, sh.section_name, ds.decomposition_stage_order, l.loading_start;"
  },
  {
    "schema": "public",
    "name": "view_project_tree_with_loadings_v2",
    "sql_definition": " SELECT sh.project_id,\n    sh.project_name,\n    sh.project_description,\n    sh.project_status,\n    sh.project_created,\n    sh.project_updated,\n    sh.stage_id,\n    sh.stage_name,\n    sh.stage_description,\n    sh.object_id,\n    sh.object_name,\n    sh.object_description,\n    sh.object_start_date,\n    sh.object_end_date,\n    sh.object_created,\n    sh.object_updated,\n    sh.section_id,\n    sh.section_name,\n    sh.section_description,\n    sh.section_type,\n    sh.section_start_date,\n    sh.section_end_date,\n    sh.section_created,\n    sh.section_updated,\n    sh.section_responsible_id,\n    sh.section_responsible_name,\n    sh.section_responsible_email,\n    sh.responsible_department_id,\n    sh.responsible_department_name,\n    sh.responsible_team_id,\n    sh.responsible_team_name,\n    sh.total_loading_rate AS section_total_loading_rate,\n    sh.tasks_count AS section_tasks_count,\n    sh.latest_plan_loading_status,\n    sh.section_responsible_avatar,\n    ds.decomposition_stage_id,\n    ds.decomposition_stage_name,\n    ds.decomposition_stage_description,\n    ds.decomposition_stage_start,\n    ds.decomposition_stage_finish,\n    ds.decomposition_stage_order,\n    ds.decomposition_stage_status_id,\n    ds.created_at AS decomposition_stage_created_at,\n    ds.updated_at AS decomposition_stage_updated_at,\n    st_status.name AS decomposition_stage_status_name,\n    st_status.color AS decomposition_stage_status_color,\n    l.loading_id,\n    l.loading_start,\n    l.loading_finish,\n    l.loading_rate,\n    l.loading_status,\n    l.is_shortage,\n    l.loading_task,\n    l.loading_comment,\n    l.loading_created,\n    l.loading_updated,\n    l.loading_responsible AS loading_responsible_id,\n    lp.first_name AS loading_responsible_first_name,\n    lp.last_name AS loading_responsible_last_name,\n        CASE\n            WHEN ((lp.first_name IS NOT NULL) OR (lp.last_name IS NOT NULL)) THEN btrim(((COALESCE(lp.first_name, ''::text) || ' '::text) || COALESCE(lp.last_name, ''::text)))\n            ELSE NULL::text\n        END AS loading_responsible_full_name,\n    lp.email AS loading_responsible_email,\n    lp.avatar_url AS loading_responsible_avatar,\n    lp.department_id AS loading_responsible_department_id,\n    ld.department_name AS loading_responsible_department_name,\n    lp.team_id AS loading_responsible_team_id,\n    lt.team_name AS loading_responsible_team_name,\n    l.shortage_department_id,\n    sd.department_name AS shortage_department_name,\n    l.shortage_team_id,\n    st.team_name AS shortage_team_name\n   FROM ((((((((view_section_hierarchy_v2 sh\n     LEFT JOIN decomposition_stages ds ON ((ds.decomposition_stage_section_id = sh.section_id)))\n     LEFT JOIN section_statuses st_status ON ((st_status.id = ds.decomposition_stage_status_id)))\n     LEFT JOIN loadings l ON (((l.loading_stage = ds.decomposition_stage_id) OR ((ds.decomposition_stage_id IS NULL) AND (l.loading_stage IS NULL) AND (l.loading_section = sh.section_id)))))\n     LEFT JOIN profiles lp ON ((lp.user_id = l.loading_responsible)))\n     LEFT JOIN departments ld ON ((ld.department_id = lp.department_id)))\n     LEFT JOIN teams lt ON ((lt.team_id = lp.team_id)))\n     LEFT JOIN departments sd ON ((sd.department_id = l.shortage_department_id)))\n     LEFT JOIN teams st ON ((st.team_id = l.shortage_team_id)))\n  ORDER BY sh.project_name, sh.stage_name, sh.object_name, sh.section_name, ds.decomposition_stage_order, l.loading_start;"
  },
  {
    "schema": "public",
    "name": "view_projects_with_department_info",
    "sql_definition": " SELECT p.project_id,\n    p.project_name,\n    p.project_description,\n    p.project_status,\n    p.project_created,\n    p.project_updated,\n    array_agg(DISTINCT sh.responsible_department_id) FILTER (WHERE (sh.responsible_department_id IS NOT NULL)) AS department_ids,\n    count(DISTINCT sh.section_id) AS sections_count\n   FROM (projects p\n     LEFT JOIN view_section_hierarchy sh ON ((sh.project_id = p.project_id)))\n  WHERE (p.project_status = 'active'::project_status_enum)\n  GROUP BY p.project_id, p.project_name, p.project_description, p.project_status, p.project_created, p.project_updated\n  ORDER BY p.project_name;"
  },
  {
    "schema": "public",
    "name": "view_section_analytics",
    "sql_definition": " WITH l_by_section AS (\n         SELECT COALESCE(l1.loading_section, t.task_parent_section) AS section_id,\n            sum(COALESCE(l1.loading_rate, (0)::numeric)) AS current_total_rate,\n            count(DISTINCT l1.loading_responsible) AS people_on_loadings\n           FROM (loadings l1\n             LEFT JOIN tasks t ON ((t.task_id = l1.loading_task)))\n          WHERE ((l1.loading_status = 'active'::loading_status_type) AND (CURRENT_DATE >= l1.loading_start) AND (CURRENT_DATE <= l1.loading_finish))\n          GROUP BY COALESCE(l1.loading_section, t.task_parent_section)\n        ), days AS (\n         SELECT (generate_series(((CURRENT_DATE - 9))::timestamp with time zone, (CURRENT_DATE)::timestamp with time zone, '1 day'::interval))::date AS d\n        ), last10_reports AS (\n         SELECT s1.section_id,\n            jsonb_agg(jsonb_build_object('date', to_char((days.d)::timestamp with time zone, 'YYYY-MM-DD'::text), 'entries', COALESCE(( SELECT jsonb_agg(jsonb_build_object('name', t.name, 'hours', t.hours) ORDER BY t.hours DESC) AS jsonb_agg\n                   FROM ( SELECT COALESCE(di.decomposition_item_description, '(без названия)'::text) AS name,\n                            COALESCE(sum(wl.work_log_hours), (0)::numeric) AS hours\n                           FROM (decomposition_items di\n                             LEFT JOIN work_logs wl ON (((wl.decomposition_item_id = di.decomposition_item_id) AND (wl.work_log_date = days.d))))\n                          WHERE (di.decomposition_item_section_id = s1.section_id)\n                          GROUP BY COALESCE(di.decomposition_item_description, '(без названия)'::text)) t), '[]'::jsonb)) ORDER BY days.d) AS reports_last10\n           FROM (sections s1\n             CROSS JOIN days)\n          GROUP BY s1.section_id\n        ), last10_reports_totals AS (\n         SELECT s1.section_id,\n            jsonb_agg(jsonb_build_object('date', to_char((days.d)::timestamp with time zone, 'YYYY-MM-DD'::text), 'total_hours', COALESCE(( SELECT COALESCE(sum(wl.work_log_hours), (0)::numeric) AS \"coalesce\"\n                   FROM (decomposition_items di\n                     LEFT JOIN work_logs wl ON (((wl.decomposition_item_id = di.decomposition_item_id) AND (wl.work_log_date = days.d))))\n                  WHERE (di.decomposition_item_section_id = s1.section_id)), (0)::numeric)) ORDER BY days.d) AS reports_last10_totals\n           FROM (sections s1\n             CROSS JOIN days)\n          GROUP BY s1.section_id\n        ), last10_assign_plan_events AS (\n         SELECT s1.section_id,\n            jsonb_agg(jsonb_build_object('date', to_char((days.d)::timestamp with time zone, 'YYYY-MM-DD'::text), 'events', COALESCE(( SELECT jsonb_agg(t.ev ORDER BY (t.ev ->> 'title'::text)) AS jsonb_agg\n                   FROM ( SELECT jsonb_build_object('assignment_id', a.assignment_id, 'title', a.title, 'kind', 'planned_transfer', 'from_section_name', ( SELECT sections.section_name\n                                   FROM sections\n                                  WHERE (sections.section_id = a.from_section_id)), 'to_section_name', ( SELECT sections.section_name\n                                   FROM sections\n                                  WHERE (sections.section_id = a.to_section_id))) AS ev\n                           FROM assignments a\n                          WHERE (((a.to_section_id = s1.section_id) OR (a.from_section_id = s1.section_id)) AND (a.planned_transmitted_date = days.d))\n                        UNION ALL\n                         SELECT jsonb_build_object('assignment_id', a.assignment_id, 'title', a.title, 'kind', 'planned_completion', 'from_section_name', ( SELECT sections.section_name\n                                   FROM sections\n                                  WHERE (sections.section_id = a.from_section_id)), 'to_section_name', ( SELECT sections.section_name\n                                   FROM sections\n                                  WHERE (sections.section_id = a.to_section_id))) AS ev\n                           FROM assignments a\n                          WHERE (((a.to_section_id = s1.section_id) OR (a.from_section_id = s1.section_id)) AND ((\n                                CASE\n                                    WHEN (a.actual_transmitted_date IS NOT NULL) THEN a.actual_transmitted_date\n                                    ELSE (a.created_at)::date\n                                END + COALESCE(a.planned_duration, 7)) = days.d))) t), '[]'::jsonb)) ORDER BY days.d) AS assignment_plan_events_last10\n           FROM (sections s1\n             CROSS JOIN days)\n          GROUP BY s1.section_id\n        ), in_out AS (\n         SELECT s1.section_id,\n            count(a.assignment_id) FILTER (WHERE (a.to_section_id = s1.section_id)) AS incoming_assignments,\n            count(a.assignment_id) FILTER (WHERE (a.from_section_id = s1.section_id)) AS outgoing_assignments\n           FROM (sections s1\n             LEFT JOIN assignments a ON (((a.to_section_id = s1.section_id) OR (a.from_section_id = s1.section_id))))\n          GROUP BY s1.section_id\n        )\n SELECT s.section_id,\n        CASE\n            WHEN (s.section_end_date IS NULL) THEN NULL::integer\n            ELSE ((s.section_end_date)::date - CURRENT_DATE)\n        END AS days_to_deadline,\n    COALESCE(l.people_on_loadings, (0)::bigint) AS people_on_loadings,\n    COALESCE(l.current_total_rate, (0)::numeric) AS current_total_rate,\n    COALESCE(in_out.incoming_assignments, (0)::bigint) AS incoming_assignments,\n    COALESCE(in_out.outgoing_assignments, (0)::bigint) AS outgoing_assignments,\n    COALESCE(last10_reports.reports_last10, '[]'::jsonb) AS reports_last10,\n    COALESCE(last10_assign_plan_events.assignment_plan_events_last10, '[]'::jsonb) AS assignment_plan_events_last10,\n    COALESCE(last10_reports_totals.reports_last10_totals, '[]'::jsonb) AS reports_last10_totals\n   FROM (((((sections s\n     LEFT JOIN l_by_section l ON ((l.section_id = s.section_id)))\n     LEFT JOIN in_out ON ((in_out.section_id = s.section_id)))\n     LEFT JOIN last10_reports ON ((last10_reports.section_id = s.section_id)))\n     LEFT JOIN last10_assign_plan_events ON ((last10_assign_plan_events.section_id = s.section_id)))\n     LEFT JOIN last10_reports_totals ON ((last10_reports_totals.section_id = s.section_id)));"
  },
  {
    "schema": "public",
    "name": "view_section_checkpoints",
    "sql_definition": " SELECT sc.checkpoint_id,\n    sc.section_id,\n    sc.type_id,\n    ct.type AS type_code,\n    ct.name AS type_name,\n    ct.is_custom,\n    sc.title,\n    sc.description,\n    sc.checkpoint_date,\n    COALESCE(sc.custom_icon, ct.icon) AS icon,\n    COALESCE(sc.custom_color, ct.color) AS color,\n    sc.completed_at,\n    sc.completed_by,\n        CASE\n            WHEN ((sc.completed_at IS NOT NULL) AND ((sc.completed_at)::date <= sc.checkpoint_date)) THEN 'completed'::text\n            WHEN ((sc.completed_at IS NOT NULL) AND ((sc.completed_at)::date > sc.checkpoint_date)) THEN 'completed_late'::text\n            WHEN ((sc.completed_at IS NULL) AND (CURRENT_DATE > sc.checkpoint_date)) THEN 'overdue'::text\n            ELSE 'pending'::text\n        END AS status,\n        CASE\n            WHEN ((sc.completed_at IS NOT NULL) AND ((sc.completed_at)::date <= sc.checkpoint_date)) THEN 'Выполнено'::text\n            WHEN ((sc.completed_at IS NOT NULL) AND ((sc.completed_at)::date > sc.checkpoint_date)) THEN 'Выполнено (просрочено)'::text\n            WHEN (CURRENT_DATE > sc.checkpoint_date) THEN 'Просрочено'::text\n            ELSE 'Ожидает выполнения'::text\n        END AS status_label,\n    sc.created_by,\n    sc.created_at,\n    sc.updated_at,\n    sec.section_responsible,\n    proj.project_manager,\n    COALESCE(( SELECT jsonb_agg(jsonb_build_object('section_id', csl.section_id, 'section_name', s.section_name, 'object_id', s.section_object_id)) AS jsonb_agg\n           FROM (checkpoint_section_links csl\n             JOIN sections s ON ((s.section_id = csl.section_id)))\n          WHERE (csl.checkpoint_id = sc.checkpoint_id)), '[]'::jsonb) AS linked_sections,\n    COALESCE(( SELECT (count(*))::integer AS count\n           FROM checkpoint_section_links\n          WHERE (checkpoint_section_links.checkpoint_id = sc.checkpoint_id)), 0) AS linked_sections_count\n   FROM (((((section_checkpoints sc\n     JOIN checkpoint_types ct ON ((ct.type_id = sc.type_id)))\n     JOIN sections sec ON ((sec.section_id = sc.section_id)))\n     LEFT JOIN objects obj ON ((obj.object_id = sec.section_object_id)))\n     LEFT JOIN stages st ON ((st.stage_id = obj.object_stage_id)))\n     LEFT JOIN projects proj ON ((proj.project_id = st.stage_project_id)));"
  },
  {
    "schema": "public",
    "name": "view_section_comments_enriched",
    "sql_definition": " SELECT sc.comment_id,\n    sc.section_id,\n    sc.author_id,\n    sc.content,\n    sc.mentions,\n    sc.created_at,\n    p.first_name,\n    p.last_name,\n    p.avatar_url,\n    ((COALESCE(p.first_name, ''::text) || ' '::text) || COALESCE(p.last_name, ''::text)) AS author_name\n   FROM (section_comments sc\n     LEFT JOIN profiles p ON ((p.user_id = sc.author_id)));"
  },
  {
    "schema": "public",
    "name": "view_section_decomposition_totals",
    "sql_definition": " SELECT s.section_id,\n    (COALESCE(sum(di.decomposition_item_planned_hours), (0)::numeric))::numeric(10,2) AS planned_hours,\n    (COALESCE(sum(wl.work_log_hours), (0)::numeric))::numeric(10,2) AS actual_hours,\n    (COALESCE(sum(wl.work_log_amount), (0)::numeric))::numeric(14,2) AS actual_amount\n   FROM ((sections s\n     LEFT JOIN decomposition_items di ON ((di.decomposition_item_section_id = s.section_id)))\n     LEFT JOIN work_logs wl ON ((wl.decomposition_item_id = di.decomposition_item_id)))\n  GROUP BY s.section_id;"
  },
  {
    "schema": "public",
    "name": "view_section_hierarchy",
    "sql_definition": " SELECT s.section_id,\n    s.section_name,\n    s.section_description,\n    s.section_type,\n    s.section_start_date,\n    s.section_end_date,\n    s.section_created,\n    s.section_updated,\n    o.object_id,\n    o.object_name,\n    o.object_description,\n    o.object_start_date,\n    o.object_end_date,\n    o.object_created,\n    o.object_updated,\n    st.stage_id,\n    st.stage_name,\n    st.stage_description,\n    p.project_id,\n    p.project_name,\n    p.project_description,\n    p.project_status,\n    p.project_created,\n    p.project_updated,\n    c.client_id,\n    c.client_name,\n    c.client_description,\n    c.client_contact_person,\n    c.client_phone,\n    c.client_email,\n    ple.user_id AS project_lead_engineer_id,\n    ((ple.first_name || ' '::text) || ple.last_name) AS project_lead_engineer_name,\n    pm.user_id AS project_manager_id,\n    ((pm.first_name || ' '::text) || pm.last_name) AS project_manager_name,\n    resp.user_id AS section_responsible_id,\n    ((resp.first_name || ' '::text) || resp.last_name) AS section_responsible_name,\n    resp.email AS section_responsible_email,\n    d.department_id AS responsible_department_id,\n    d.department_name AS responsible_department_name,\n    t.team_id AS responsible_team_id,\n    t.team_name AS responsible_team_name,\n    COALESCE(( SELECT sum(l.loading_rate) AS sum\n           FROM (loadings l\n             LEFT JOIN decomposition_stages ds ON ((ds.decomposition_stage_id = l.loading_stage)))\n          WHERE (((l.loading_stage IS NOT NULL) AND (ds.decomposition_stage_section_id = s.section_id)) OR ((l.loading_stage IS NULL) AND (l.loading_section = s.section_id)))), (0)::numeric) AS total_loading_rate,\n    COALESCE(( SELECT count(*) AS count\n           FROM tasks t_1\n          WHERE (t_1.task_parent_section = s.section_id)), (0)::bigint) AS tasks_count,\n    COALESCE(( SELECT x.plan_loading_status\n           FROM ( SELECT pl.plan_loading_status,\n                    pl.plan_loading_created\n                   FROM (plan_loadings pl\n                     JOIN decomposition_stages ds ON ((ds.decomposition_stage_id = pl.plan_loading_stage)))\n                  WHERE (ds.decomposition_stage_section_id = s.section_id)\n                UNION ALL\n                 SELECT pl.plan_loading_status,\n                    pl.plan_loading_created\n                   FROM plan_loadings pl\n                  WHERE ((pl.plan_loading_stage IS NULL) AND (pl.plan_loading_section = s.section_id))) x\n          ORDER BY x.plan_loading_created DESC NULLS LAST\n         LIMIT 1), 'нет'::character varying) AS latest_plan_loading_status,\n    ple.avatar_url AS project_lead_engineer_avatar,\n    pm.avatar_url AS project_manager_avatar,\n    resp.avatar_url AS section_responsible_avatar,\n    (o.object_stage_id IS NULL) AS object_is_stageless\n   FROM (((((((((sections s\n     LEFT JOIN objects o ON ((s.section_object_id = o.object_id)))\n     LEFT JOIN stages st ON ((o.object_stage_id = st.stage_id)))\n     LEFT JOIN projects p ON ((COALESCE(st.stage_project_id, o.object_project_id) = p.project_id)))\n     LEFT JOIN clients c ON ((p.client_id = c.client_id)))\n     LEFT JOIN profiles resp ON ((s.section_responsible = resp.user_id)))\n     LEFT JOIN profiles ple ON ((p.project_lead_engineer = ple.user_id)))\n     LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n     LEFT JOIN departments d ON ((resp.department_id = d.department_id)))\n     LEFT JOIN teams t ON ((resp.team_id = t.team_id)));"
  },
  {
    "schema": "public",
    "name": "view_section_hierarchy_fixed",
    "sql_definition": " SELECT s.section_id,\n    s.section_name,\n    s.section_description,\n    s.section_type,\n    s.section_start_date,\n    s.section_end_date,\n    s.section_created,\n    s.section_updated,\n    o.object_id,\n    o.object_name,\n    o.object_description,\n    o.object_start_date,\n    o.object_end_date,\n    o.object_created,\n    o.object_updated,\n    st.stage_id,\n    st.stage_name,\n    st.stage_description,\n    p.project_id,\n    p.project_name,\n    p.project_description,\n    p.project_status,\n    p.project_created,\n    p.project_updated,\n    c.client_id,\n    c.client_name,\n    c.client_description,\n    c.client_contact_person,\n    c.client_phone,\n    c.client_email,\n    ple.user_id AS project_lead_engineer_id,\n    ((ple.first_name || ' '::text) || ple.last_name) AS project_lead_engineer_name,\n    pm.user_id AS project_manager_id,\n    ((pm.first_name || ' '::text) || pm.last_name) AS project_manager_name,\n    resp.user_id AS section_responsible_id,\n    ((resp.first_name || ' '::text) || resp.last_name) AS section_responsible_name,\n    resp.email AS section_responsible_email,\n    d.department_id AS responsible_department_id,\n    d.department_name AS responsible_department_name,\n    t.team_id AS responsible_team_id,\n    t.team_name AS responsible_team_name,\n    COALESCE(( SELECT sum(l.loading_rate) AS sum\n           FROM (loadings l\n             LEFT JOIN decomposition_stages ds ON ((ds.decomposition_stage_id = l.loading_stage)))\n          WHERE (((l.loading_stage IS NOT NULL) AND (ds.decomposition_stage_section_id = s.section_id)) OR ((l.loading_stage IS NULL) AND (l.loading_section = s.section_id)))), (0)::numeric) AS total_loading_rate,\n    COALESCE(( SELECT count(*) AS count\n           FROM tasks t_1\n          WHERE (t_1.task_parent_section = s.section_id)), (0)::bigint) AS tasks_count,\n    COALESCE(( SELECT x.plan_loading_status\n           FROM ( SELECT pl.plan_loading_status,\n                    pl.plan_loading_created\n                   FROM (plan_loadings pl\n                     JOIN decomposition_stages ds ON ((ds.decomposition_stage_id = pl.plan_loading_stage)))\n                  WHERE (ds.decomposition_stage_section_id = s.section_id)\n                UNION ALL\n                 SELECT pl.plan_loading_status,\n                    pl.plan_loading_created\n                   FROM plan_loadings pl\n                  WHERE ((pl.plan_loading_stage IS NULL) AND (pl.plan_loading_section = s.section_id))) x\n          ORDER BY x.plan_loading_created DESC NULLS LAST\n         LIMIT 1), 'нет'::character varying) AS latest_plan_loading_status,\n    ple.avatar_url AS project_lead_engineer_avatar,\n    pm.avatar_url AS project_manager_avatar,\n    resp.avatar_url AS section_responsible_avatar,\n    (o.object_stage_id IS NULL) AS object_is_stageless\n   FROM (((((((((sections s\n     LEFT JOIN objects o ON ((s.section_object_id = o.object_id)))\n     LEFT JOIN stages st ON ((o.object_stage_id = st.stage_id)))\n     LEFT JOIN projects p ON ((COALESCE(st.stage_project_id, o.object_project_id) = p.project_id)))\n     LEFT JOIN clients c ON ((p.client_id = c.client_id)))\n     LEFT JOIN profiles resp ON ((s.section_responsible = resp.user_id)))\n     LEFT JOIN profiles ple ON ((p.project_lead_engineer = ple.user_id)))\n     LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n     LEFT JOIN departments d ON ((resp.department_id = d.department_id)))\n     LEFT JOIN teams t ON ((resp.team_id = t.team_id)));"
  },
  {
    "schema": "public",
    "name": "view_section_hierarchy_v2",
    "sql_definition": " SELECT s.section_id,\n    s.section_name,\n    s.section_description,\n    s.section_type,\n    s.section_start_date,\n    s.section_end_date,\n    s.section_created,\n    s.section_updated,\n    o.object_id,\n    o.object_name,\n    o.object_description,\n    o.object_start_date,\n    o.object_end_date,\n    o.object_created,\n    o.object_updated,\n    st.stage_id,\n    st.stage_name,\n    st.stage_description,\n    p.project_id,\n    p.project_name,\n    p.project_description,\n    p.project_status,\n    p.project_created,\n    p.project_updated,\n    c.client_id,\n    c.client_name,\n    c.client_description,\n    c.client_contact_person,\n    c.client_phone,\n    c.client_email,\n    ple.user_id AS project_lead_engineer_id,\n    ((ple.first_name || ' '::text) || ple.last_name) AS project_lead_engineer_name,\n    pm.user_id AS project_manager_id,\n    ((pm.first_name || ' '::text) || pm.last_name) AS project_manager_name,\n    resp.user_id AS section_responsible_id,\n    ((resp.first_name || ' '::text) || resp.last_name) AS section_responsible_name,\n    resp.email AS section_responsible_email,\n    d.department_id AS responsible_department_id,\n    d.department_name AS responsible_department_name,\n    t.team_id AS responsible_team_id,\n    t.team_name AS responsible_team_name,\n    COALESCE(( SELECT sum(l.loading_rate) AS sum\n           FROM (loadings l\n             LEFT JOIN decomposition_stages ds ON ((ds.decomposition_stage_id = l.loading_stage)))\n          WHERE (((l.loading_stage IS NOT NULL) AND (ds.decomposition_stage_section_id = s.section_id)) OR ((l.loading_stage IS NULL) AND (l.loading_section = s.section_id)))), (0)::numeric) AS total_loading_rate,\n    COALESCE(( SELECT count(*) AS count\n           FROM tasks t_1\n          WHERE (t_1.task_parent_section = s.section_id)), (0)::bigint) AS tasks_count,\n    COALESCE(( SELECT x.plan_loading_status\n           FROM ( SELECT pl.plan_loading_status,\n                    pl.plan_loading_created\n                   FROM (plan_loadings pl\n                     JOIN decomposition_stages ds ON ((ds.decomposition_stage_id = pl.plan_loading_stage)))\n                  WHERE (ds.decomposition_stage_section_id = s.section_id)\n                UNION ALL\n                 SELECT pl.plan_loading_status,\n                    pl.plan_loading_created\n                   FROM plan_loadings pl\n                  WHERE ((pl.plan_loading_stage IS NULL) AND (pl.plan_loading_section = s.section_id))) x\n          ORDER BY x.plan_loading_created DESC NULLS LAST\n         LIMIT 1), 'нет'::character varying) AS latest_plan_loading_status,\n    ple.avatar_url AS project_lead_engineer_avatar,\n    pm.avatar_url AS project_manager_avatar,\n    resp.avatar_url AS section_responsible_avatar,\n    (o.object_stage_id IS NULL) AS object_is_stageless\n   FROM (((((((((sections s\n     LEFT JOIN objects o ON ((s.section_object_id = o.object_id)))\n     LEFT JOIN stages st ON ((o.object_stage_id = st.stage_id)))\n     LEFT JOIN projects p ON ((COALESCE(st.stage_project_id, o.object_project_id) = p.project_id)))\n     LEFT JOIN clients c ON ((p.client_id = c.client_id)))\n     LEFT JOIN profiles resp ON ((s.section_responsible = resp.user_id)))\n     LEFT JOIN profiles ple ON ((p.project_lead_engineer = ple.user_id)))\n     LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n     LEFT JOIN departments d ON ((resp.department_id = d.department_id)))\n     LEFT JOIN teams t ON ((resp.team_id = t.team_id)));"
  },
  {
    "schema": "public",
    "name": "view_section_hierarchy_v3",
    "sql_definition": " SELECT s.section_id,\n    s.section_name,\n    s.section_description,\n    s.section_type,\n    s.section_start_date,\n    s.section_end_date,\n    s.section_created,\n    s.section_updated,\n    o.object_id,\n    o.object_name,\n    o.object_description,\n    o.object_start_date,\n    o.object_end_date,\n    o.object_created,\n    o.object_updated,\n    st.stage_id,\n    st.stage_name,\n    st.stage_description,\n    p.project_id,\n    p.project_name,\n    p.project_description,\n    p.project_status,\n    p.project_created,\n    p.project_updated,\n    c.client_id,\n    c.client_name,\n    c.client_description,\n    c.client_contact_person,\n    c.client_phone,\n    c.client_email,\n    ple.user_id AS project_lead_engineer_id,\n    ((ple.first_name || ' '::text) || ple.last_name) AS project_lead_engineer_name,\n    pm.user_id AS project_manager_id,\n    ((pm.first_name || ' '::text) || pm.last_name) AS project_manager_name,\n    resp.user_id AS section_responsible_id,\n    ((resp.first_name || ' '::text) || resp.last_name) AS section_responsible_name,\n    resp.email AS section_responsible_email,\n    d.department_id AS responsible_department_id,\n    d.department_name AS responsible_department_name,\n    t.team_id AS responsible_team_id,\n    t.team_name AS responsible_team_name,\n    COALESCE(( SELECT sum(l.loading_rate) AS sum\n           FROM (loadings l\n             LEFT JOIN decomposition_stages ds ON ((ds.decomposition_stage_id = l.loading_stage)))\n          WHERE (((l.loading_stage IS NOT NULL) AND (ds.decomposition_stage_section_id = s.section_id)) OR ((l.loading_stage IS NULL) AND (l.loading_section = s.section_id)))), (0)::numeric) AS total_loading_rate,\n    COALESCE(( SELECT count(*) AS count\n           FROM tasks t_1\n          WHERE (t_1.task_parent_section = s.section_id)), (0)::bigint) AS tasks_count,\n    COALESCE(( SELECT x.plan_loading_status\n           FROM ( SELECT pl.plan_loading_status,\n                    pl.plan_loading_created\n                   FROM (plan_loadings pl\n                     JOIN decomposition_stages ds ON ((ds.decomposition_stage_id = pl.plan_loading_stage)))\n                  WHERE (ds.decomposition_stage_section_id = s.section_id)\n                UNION ALL\n                 SELECT pl.plan_loading_status,\n                    pl.plan_loading_created\n                   FROM plan_loadings pl\n                  WHERE ((pl.plan_loading_stage IS NULL) AND (pl.plan_loading_section = s.section_id))) x\n          ORDER BY x.plan_loading_created DESC NULLS LAST\n         LIMIT 1), 'нет'::character varying) AS latest_plan_loading_status,\n    ple.avatar_url AS project_lead_engineer_avatar,\n    pm.avatar_url AS project_manager_avatar,\n    resp.avatar_url AS section_responsible_avatar\n   FROM (((((((((sections s\n     LEFT JOIN objects o ON ((s.section_object_id = o.object_id)))\n     LEFT JOIN stages st ON ((o.object_stage_id = st.stage_id)))\n     LEFT JOIN projects p ON ((st.stage_project_id = p.project_id)))\n     LEFT JOIN clients c ON ((p.client_id = c.client_id)))\n     LEFT JOIN profiles resp ON ((s.section_responsible = resp.user_id)))\n     LEFT JOIN profiles ple ON ((p.project_lead_engineer = ple.user_id)))\n     LEFT JOIN profiles pm ON ((p.project_manager = pm.user_id)))\n     LEFT JOIN departments d ON ((resp.department_id = d.department_id)))\n     LEFT JOIN teams t ON ((resp.team_id = t.team_id)));"
  },
  {
    "schema": "public",
    "name": "view_sections_with_loadings",
    "sql_definition": " SELECT s.section_id,\n    s.section_name,\n    s.object_id,\n    s.object_name,\n    s.stage_id,\n    s.stage_name,\n    s.project_id,\n    s.project_name,\n    s.client_id,\n    s.client_name,\n    s.project_lead_engineer_name,\n    s.project_manager_name,\n    s.section_responsible_id,\n    s.section_responsible_name,\n    s.responsible_department_id,\n    s.responsible_department_name,\n    s.responsible_team_id,\n    s.responsible_team_name,\n    s.total_loading_rate,\n    s.tasks_count,\n    s.latest_plan_loading_status,\n    s.section_start_date,\n    s.section_end_date,\n    l.loading_id,\n    l.loading_responsible,\n    l.loading_stage,\n    l.loading_start,\n    l.loading_finish,\n    l.loading_rate,\n    l.loading_status,\n    l.loading_created,\n    l.loading_updated,\n    p.first_name AS responsible_first_name,\n    p.last_name AS responsible_last_name,\n        CASE\n            WHEN (l.loading_id IS NOT NULL) THEN true\n            ELSE false\n        END AS has_loadings,\n    count(l.loading_id) OVER (PARTITION BY s.section_id) AS loadings_count,\n    s.project_lead_engineer_avatar,\n    s.project_manager_avatar,\n    s.section_responsible_avatar,\n    p.avatar_url AS responsible_avatar,\n    l.loading_comment\n   FROM ((view_section_hierarchy s\n     LEFT JOIN loadings l ON ((((l.loading_stage IS NOT NULL) AND (l.loading_stage IN ( SELECT dsx.decomposition_stage_id\n           FROM decomposition_stages dsx\n          WHERE (dsx.decomposition_stage_section_id = s.section_id)))) OR ((l.loading_stage IS NULL) AND (l.loading_section = s.section_id)))))\n     LEFT JOIN profiles p ON ((l.loading_responsible = p.user_id)));"
  },
  {
    "schema": "public",
    "name": "view_sections_with_loadings_v2",
    "sql_definition": " WITH loadings_via_stages AS (\n         SELECT ds.decomposition_stage_section_id AS section_id,\n            l_1.loading_id,\n            l_1.loading_responsible,\n            l_1.loading_stage,\n            l_1.loading_section,\n            l_1.loading_start,\n            l_1.loading_finish,\n            l_1.loading_rate,\n            l_1.loading_status,\n            l_1.loading_created,\n            l_1.loading_updated,\n            l_1.loading_comment\n           FROM (loadings l_1\n             JOIN decomposition_stages ds ON ((l_1.loading_stage = ds.decomposition_stage_id)))\n          WHERE (l_1.loading_stage IS NOT NULL)\n        ), loadings_direct AS (\n         SELECT l_1.loading_section AS section_id,\n            l_1.loading_id,\n            l_1.loading_responsible,\n            l_1.loading_stage,\n            l_1.loading_section,\n            l_1.loading_start,\n            l_1.loading_finish,\n            l_1.loading_rate,\n            l_1.loading_status,\n            l_1.loading_created,\n            l_1.loading_updated,\n            l_1.loading_comment\n           FROM loadings l_1\n          WHERE ((l_1.loading_stage IS NULL) AND (l_1.loading_section IS NOT NULL))\n        ), all_loadings AS (\n         SELECT loadings_via_stages.section_id,\n            loadings_via_stages.loading_id,\n            loadings_via_stages.loading_responsible,\n            loadings_via_stages.loading_stage,\n            loadings_via_stages.loading_section,\n            loadings_via_stages.loading_start,\n            loadings_via_stages.loading_finish,\n            loadings_via_stages.loading_rate,\n            loadings_via_stages.loading_status,\n            loadings_via_stages.loading_created,\n            loadings_via_stages.loading_updated,\n            loadings_via_stages.loading_comment\n           FROM loadings_via_stages\n        UNION ALL\n         SELECT loadings_direct.section_id,\n            loadings_direct.loading_id,\n            loadings_direct.loading_responsible,\n            loadings_direct.loading_stage,\n            loadings_direct.loading_section,\n            loadings_direct.loading_start,\n            loadings_direct.loading_finish,\n            loadings_direct.loading_rate,\n            loadings_direct.loading_status,\n            loadings_direct.loading_created,\n            loadings_direct.loading_updated,\n            loadings_direct.loading_comment\n           FROM loadings_direct\n        )\n SELECT s.section_id,\n    s.section_name,\n    s.object_id,\n    s.object_name,\n    s.stage_id,\n    s.stage_name,\n    s.project_id,\n    s.project_name,\n    s.client_id,\n    s.client_name,\n    s.project_lead_engineer_name,\n    s.project_manager_name,\n    s.section_responsible_id,\n    s.section_responsible_name,\n    s.responsible_department_id,\n    s.responsible_department_name,\n    s.responsible_team_id,\n    s.responsible_team_name,\n    s.total_loading_rate,\n    s.tasks_count,\n    s.latest_plan_loading_status,\n    s.section_start_date,\n    s.section_end_date,\n    s.project_lead_engineer_avatar,\n    s.project_manager_avatar,\n    s.section_responsible_avatar,\n    l.loading_id,\n    l.loading_responsible,\n    l.loading_stage,\n    l.loading_start,\n    l.loading_finish,\n    l.loading_rate,\n    l.loading_status,\n    l.loading_created,\n    l.loading_updated,\n    l.loading_comment,\n    p.first_name AS responsible_first_name,\n    p.last_name AS responsible_last_name,\n    p.avatar_url AS responsible_avatar,\n        CASE\n            WHEN (l.loading_id IS NOT NULL) THEN true\n            ELSE false\n        END AS has_loadings,\n    count(l.loading_id) OVER (PARTITION BY s.section_id) AS loadings_count\n   FROM ((view_section_hierarchy s\n     LEFT JOIN all_loadings l ON ((l.section_id = s.section_id)))\n     LEFT JOIN profiles p ON ((l.loading_responsible = p.user_id)));"
  },
  {
    "schema": "public",
    "name": "view_stage_difficulty_pivot",
    "sql_definition": " WITH base AS (\n         SELECT view_stage_difficulty_stats.stage_id,\n            view_stage_difficulty_stats.difficulty_id,\n            view_stage_difficulty_stats.difficulty_abbr,\n            view_stage_difficulty_stats.difficulty_definition,\n            view_stage_difficulty_stats.difficulty_weight,\n            view_stage_difficulty_stats.items_count,\n            view_stage_difficulty_stats.planned_hours,\n            view_stage_difficulty_stats.weighted_hours\n           FROM view_stage_difficulty_stats\n        )\n SELECT base.stage_id,\n    jsonb_object_agg(base.difficulty_abbr, base.items_count ORDER BY base.difficulty_weight, base.difficulty_abbr) AS counts_by_difficulty,\n    jsonb_object_agg(base.difficulty_abbr, base.planned_hours ORDER BY base.difficulty_weight, base.difficulty_abbr) AS hours_by_difficulty,\n    jsonb_object_agg(base.difficulty_abbr, base.weighted_hours ORDER BY base.difficulty_weight, base.difficulty_abbr) AS weighted_hours_by_difficulty,\n    sum(base.items_count) AS items_total,\n    sum(base.planned_hours) AS planned_hours_total,\n    sum(base.weighted_hours) AS weighted_hours_total\n   FROM base\n  GROUP BY base.stage_id;"
  },
  {
    "schema": "public",
    "name": "view_stage_difficulty_stats",
    "sql_definition": " WITH levels AS (\n         SELECT ddl.difficulty_id,\n            ddl.difficulty_abbr,\n            ddl.difficulty_definition,\n            ddl.difficulty_weight\n           FROM decomposition_difficulty_levels ddl\n        UNION ALL\n         SELECT NULL::uuid AS difficulty_id,\n            'UNK'::text AS difficulty_abbr,\n            'Без уровня сложности'::text AS difficulty_definition,\n            (0)::smallint AS difficulty_weight\n        )\n SELECT s.decomposition_stage_id AS stage_id,\n    l.difficulty_id,\n    l.difficulty_abbr,\n    l.difficulty_definition,\n    l.difficulty_weight,\n    count(di.decomposition_item_id) AS items_count,\n    (COALESCE(sum(di.decomposition_item_planned_hours), (0)::numeric))::numeric(12,2) AS planned_hours,\n    (COALESCE(sum((di.decomposition_item_planned_hours * (l.difficulty_weight)::numeric)), (0)::numeric))::numeric(12,2) AS weighted_hours\n   FROM ((decomposition_stages s\n     CROSS JOIN levels l)\n     LEFT JOIN decomposition_items di ON (((di.decomposition_item_stage_id = s.decomposition_stage_id) AND ((di.decomposition_item_difficulty_id = l.difficulty_id) OR ((di.decomposition_item_difficulty_id IS NULL) AND (l.difficulty_id IS NULL))))))\n  GROUP BY s.decomposition_stage_id, l.difficulty_id, l.difficulty_abbr, l.difficulty_definition, l.difficulty_weight;"
  },
  {
    "schema": "public",
    "name": "view_subdivisions_with_heads",
    "sql_definition": " SELECT s.subdivision_id,\n    s.subdivision_name,\n    s.subdivision_head_id,\n    s.created_at,\n    s.updated_at,\n    concat(p.first_name, ' ', p.last_name) AS head_name,\n    p.email AS head_email,\n    p.avatar_url AS head_avatar_url,\n    ( SELECT count(*) AS count\n           FROM departments d\n          WHERE (d.subdivision_id = s.subdivision_id)) AS departments_count,\n    ( SELECT count(*) AS count\n           FROM profiles pr\n          WHERE (pr.subdivision_id = s.subdivision_id)) AS employees_count\n   FROM (subdivisions s\n     LEFT JOIN profiles p ON ((s.subdivision_head_id = p.user_id)));"
  },
  {
    "schema": "public",
    "name": "view_team_leads",
    "sql_definition": " SELECT t.team_id,\n    t.team_name,\n    d.department_name,\n    t.team_lead_id AS user_id,\n    p.first_name,\n    p.last_name,\n    p.email,\n    p.avatar_url\n   FROM ((teams t\n     JOIN departments d ON ((t.department_id = d.department_id)))\n     LEFT JOIN profiles p ON ((t.team_lead_id = p.user_id)))\n  WHERE ((t.team_name <> 'Без команды'::text) AND (t.team_lead_id IS NOT NULL));"
  },
  {
    "schema": "public",
    "name": "view_teams_with_leads",
    "sql_definition": " SELECT t.team_id,\n    t.team_name,\n    t.department_id,\n    COALESCE(d.department_name, 'Не назначен'::text) AS department_name,\n    t.team_lead_id,\n    p.first_name AS team_lead_first_name,\n    p.last_name AS team_lead_last_name,\n    concat(p.first_name, ' ', p.last_name) AS team_lead_full_name,\n    p.email AS team_lead_email,\n    p.avatar_url AS team_lead_avatar_url\n   FROM ((teams t\n     LEFT JOIN departments d ON ((t.department_id = d.department_id)))\n     LEFT JOIN profiles p ON ((t.team_lead_id = p.user_id)))\n  ORDER BY t.team_name;"
  },
  {
    "schema": "public",
    "name": "view_user_effective_permissions",
    "sql_definition": " WITH user_permissions AS (\n         SELECT ur.user_id,\n            p.name AS permission_name\n           FROM ((user_roles ur\n             JOIN role_permissions rp ON ((ur.role_id = rp.role_id)))\n             JOIN permissions p ON ((rp.permission_id = p.id)))\n        ), admin_users AS (\n         SELECT DISTINCT ur.user_id\n           FROM (user_roles ur\n             JOIN roles r ON ((ur.role_id = r.id)))\n          WHERE (r.name = 'admin'::text)\n        )\n SELECT u.user_id,\n        CASE\n            WHEN (au.user_id IS NOT NULL) THEN ( SELECT array_agg(permissions.name ORDER BY permissions.name) AS array_agg\n               FROM permissions)\n            ELSE COALESCE(array_agg(DISTINCT up.permission_name ORDER BY up.permission_name), ARRAY[]::text[])\n        END AS effective_permissions\n   FROM ((( SELECT DISTINCT user_roles.user_id\n           FROM user_roles) u\n     LEFT JOIN admin_users au ON ((u.user_id = au.user_id)))\n     LEFT JOIN user_permissions up ON ((u.user_id = up.user_id)))\n  GROUP BY u.user_id, au.user_id;"
  },
  {
    "schema": "public",
    "name": "view_user_has_permission",
    "sql_definition": " SELECT ur.user_id,\n    p.name AS permission_name,\n    true AS has_permission\n   FROM ((user_roles ur\n     JOIN role_permissions rp ON ((ur.role_id = rp.role_id)))\n     JOIN permissions p ON ((rp.permission_id = p.id)));"
  },
  {
    "schema": "public",
    "name": "view_user_permissions",
    "sql_definition": " SELECT DISTINCT ur.user_id,\n    p.name AS permission_name\n   FROM ((user_roles ur\n     JOIN role_permissions rp ON ((ur.role_id = rp.role_id)))\n     JOIN permissions p ON ((rp.permission_id = p.id)));"
  },
  {
    "schema": "public",
    "name": "view_user_permissions_fast",
    "sql_definition": " SELECT ur.user_id,\n    array_agg(DISTINCT p.name ORDER BY p.name) AS permissions\n   FROM ((user_roles ur\n     JOIN role_permissions rp ON ((ur.role_id = rp.role_id)))\n     JOIN permissions p ON ((rp.permission_id = p.id)))\n  GROUP BY ur.user_id;"
  },
  {
    "schema": "public",
    "name": "view_user_reports_with_authors",
    "sql_definition": " SELECT ur.user_report_id,\n    ur.user_report_short_description,\n    ur.user_report_detailed_description,\n    ur.user_report_created_by,\n    ur.user_report_created_at,\n    p.first_name AS author_first_name,\n    p.last_name AS author_last_name,\n        CASE\n            WHEN ((p.first_name IS NOT NULL) AND (p.first_name <> ''::text) AND (p.last_name IS NOT NULL) AND (p.last_name <> ''::text)) THEN concat(p.first_name, ' ', p.last_name)\n            WHEN ((p.first_name IS NOT NULL) AND (p.first_name <> ''::text)) THEN p.first_name\n            WHEN ((p.last_name IS NOT NULL) AND (p.last_name <> ''::text)) THEN p.last_name\n            ELSE split_part(p.email, '@'::text, 1)\n        END AS author_full_name,\n    p.email AS author_email,\n    p.avatar_url AS author_avatar_url,\n    pos.position_name AS author_position_name,\n    dept.department_name AS author_department_name,\n    team.team_name AS author_team_name\n   FROM ((((user_reports ur\n     LEFT JOIN profiles p ON ((ur.user_report_created_by = p.user_id)))\n     LEFT JOIN positions pos ON ((p.position_id = pos.position_id)))\n     LEFT JOIN departments dept ON ((p.department_id = dept.department_id)))\n     LEFT JOIN teams team ON ((p.team_id = team.team_id)))\n  ORDER BY ur.user_report_created_at DESC;"
  },
  {
    "schema": "public",
    "name": "view_user_roles",
    "sql_definition": " SELECT ur.user_id,\n    ur.role_id,\n    r.name AS role_name,\n    r.description AS role_description,\n    ur.assigned_at,\n    ur.assigned_by,\n    concat(p_assigned.first_name, ' ', p_assigned.last_name) AS assigned_by_name\n   FROM ((user_roles ur\n     JOIN roles r ON ((ur.role_id = r.id)))\n     LEFT JOIN profiles p_assigned ON ((ur.assigned_by = p_assigned.user_id)))\n  ORDER BY ur.user_id, ur.assigned_at;"
  },
  {
    "schema": "public",
    "name": "view_users",
    "sql_definition": " SELECT p.user_id,\n    p.first_name,\n    p.last_name,\n    p.email,\n    p.created_at,\n    p.work_format,\n    p.employment_rate,\n    p.salary,\n    p.is_hourly,\n    p.avatar_url,\n    p.department_id,\n    d.department_name,\n    p.team_id,\n    t.team_name,\n    p.position_id,\n    pos.position_name,\n    p.category_id,\n    c.category_name,\n    sub.subdivision_id,\n    sub.subdivision_name,\n    NULL::uuid AS role_id,\n        CASE\n            WHEN (EXISTS ( SELECT 1\n               FROM (user_roles ur2\n                 JOIN roles r2 ON ((r2.id = ur2.role_id)))\n              WHERE ((ur2.user_id = p.user_id) AND (r2.name = 'admin'::text)))) THEN 'admin'::text\n            WHEN (EXISTS ( SELECT 1\n               FROM (user_roles ur2\n                 JOIN roles r2 ON ((r2.id = ur2.role_id)))\n              WHERE ((ur2.user_id = p.user_id) AND (r2.name = 'department_head'::text)))) THEN 'department_head'::text\n            WHEN (EXISTS ( SELECT 1\n               FROM (user_roles ur2\n                 JOIN roles r2 ON ((r2.id = ur2.role_id)))\n              WHERE ((ur2.user_id = p.user_id) AND (r2.name = 'team_lead'::text)))) THEN 'team_lead'::text\n            WHEN (EXISTS ( SELECT 1\n               FROM (user_roles ur2\n                 JOIN roles r2 ON ((r2.id = ur2.role_id)))\n              WHERE ((ur2.user_id = p.user_id) AND (r2.name = 'user'::text)))) THEN 'user'::text\n            ELSE NULL::text\n        END AS role_name,\n    NULL::text AS role_description,\n    p.city_id,\n    ci.name AS city_name,\n    co.id AS country_id,\n    co.name AS country_name,\n    concat(p.first_name, ' ', p.last_name) AS full_name,\n        CASE\n            WHEN (p.user_id IS NOT NULL) THEN true\n            ELSE false\n        END AS is_active,\n    string_agg(DISTINCT ur_role.name, ', '::text ORDER BY ur_role.name) AS roles_display_string,\n    count(DISTINCT ur.role_id) AS roles_count,\n    (count(DISTINCT ur.role_id) > 1) AS has_multiple_roles\n   FROM (((((((((profiles p\n     LEFT JOIN departments d ON ((p.department_id = d.department_id)))\n     LEFT JOIN subdivisions sub ON ((d.subdivision_id = sub.subdivision_id)))\n     LEFT JOIN teams t ON ((p.team_id = t.team_id)))\n     LEFT JOIN positions pos ON ((p.position_id = pos.position_id)))\n     LEFT JOIN categories c ON ((p.category_id = c.category_id)))\n     LEFT JOIN cities ci ON ((p.city_id = ci.id)))\n     LEFT JOIN countries co ON ((ci.country_id = co.id)))\n     LEFT JOIN user_roles ur ON ((p.user_id = ur.user_id)))\n     LEFT JOIN roles ur_role ON ((ur.role_id = ur_role.id)))\n  GROUP BY p.user_id, p.first_name, p.last_name, p.email, p.created_at, p.work_format, p.employment_rate, p.salary, p.is_hourly, p.avatar_url, p.department_id, d.department_name, p.team_id, t.team_name, p.position_id, pos.position_name, p.category_id, c.category_name, sub.subdivision_id, sub.subdivision_name, p.city_id, ci.name, co.id, co.name\n  ORDER BY p.last_name, p.first_name;"
  },
  {
    "schema": "public",
    "name": "view_users_with_details",
    "sql_definition": " SELECT p.user_id,\n    p.first_name,\n    p.last_name,\n    p.email,\n    p.avatar_url,\n    p.department_id,\n    p.team_id,\n    d.department_name,\n    t.team_name,\n    pos.position_name,\n    c.category_name\n   FROM ((((profiles p\n     LEFT JOIN departments d ON ((p.department_id = d.department_id)))\n     LEFT JOIN teams t ON ((p.team_id = t.team_id)))\n     LEFT JOIN positions pos ON ((p.position_id = pos.position_id)))\n     LEFT JOIN categories c ON ((p.category_id = c.category_id)))\n  ORDER BY p.last_name, p.first_name;"
  },
  {
    "schema": "public",
    "name": "view_work_logs_enriched",
    "sql_definition": " SELECT wl.work_log_id,\n    wl.work_log_created_at,\n    wl.work_log_date,\n    wl.work_log_hours,\n    wl.work_log_hourly_rate,\n    wl.work_log_amount,\n    wl.work_log_description,\n    wl.decomposition_item_id,\n    di.decomposition_item_description,\n    di.decomposition_item_section_id AS section_id,\n    s.section_name,\n    s.section_object_id AS object_id,\n    o.object_name,\n    o.object_stage_id AS stage_id,\n    st.stage_name,\n    s.section_project_id AS project_id,\n    pr.project_name,\n    di.decomposition_item_work_category_id AS work_category_id,\n    wc.work_category_name,\n    wl.work_log_created_by AS author_id,\n    p.first_name,\n    p.last_name,\n    p.avatar_url,\n    ((COALESCE(p.first_name, ''::text) || ' '::text) || COALESCE(p.last_name, ''::text)) AS author_name,\n    di.decomposition_item_stage_id AS decomposition_stage_id,\n    ds.decomposition_stage_name\n   FROM ((((((((work_logs wl\n     LEFT JOIN decomposition_items di ON ((di.decomposition_item_id = wl.decomposition_item_id)))\n     LEFT JOIN decomposition_stages ds ON ((ds.decomposition_stage_id = di.decomposition_item_stage_id)))\n     LEFT JOIN sections s ON ((s.section_id = di.decomposition_item_section_id)))\n     LEFT JOIN objects o ON ((o.object_id = s.section_object_id)))\n     LEFT JOIN stages st ON ((st.stage_id = o.object_stage_id)))\n     LEFT JOIN projects pr ON ((pr.project_id = s.section_project_id)))\n     LEFT JOIN work_categories wc ON ((wc.work_category_id = di.decomposition_item_work_category_id)))\n     LEFT JOIN profiles p ON ((p.user_id = wl.work_log_created_by)));"
  },
  {
    "schema": "vault",
    "name": "decrypted_secrets",
    "sql_definition": " SELECT s.id,\n    s.name,\n    s.description,\n    s.secret,\n    convert_from(vault._crypto_aead_det_decrypt(message => decode(s.secret, 'base64'::text), additional => convert_to((s.id)::text, 'utf8'::name), key_id => (0)::bigint, context => '\\x7067736f6469756d'::bytea, nonce => s.nonce), 'utf8'::name) AS decrypted_secret,\n    s.key_id,\n    s.nonce,\n    s.created_at,\n    s.updated_at\n   FROM vault.secrets s;"
  }
]