[
  {
    "schema": "auth",
    "function_name": "email",
    "arguments": "",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION auth.email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n$function$\n"
  },
  {
    "schema": "auth",
    "function_name": "jwt",
    "arguments": "",
    "return_type": "jsonb",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION auth.jwt()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n$function$\n"
  },
  {
    "schema": "auth",
    "function_name": "role",
    "arguments": "",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION auth.role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n$function$\n"
  },
  {
    "schema": "auth",
    "function_name": "uid",
    "arguments": "",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION auth.uid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "algorithm_sign",
    "arguments": "signables text, secret text, algorithm text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.algorithm_sign(signables text, secret text, algorithm text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  alg AS (\n    SELECT CASE\n      WHEN algorithm = 'HS256' THEN 'sha256'\n      WHEN algorithm = 'HS384' THEN 'sha384'\n      WHEN algorithm = 'HS512' THEN 'sha512'\n      ELSE '' END AS id)  -- hmac throws error\nSELECT extensions.url_encode(extensions.hmac(signables, secret, alg.id)) FROM alg;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "armor",
    "arguments": "bytea, text[], text[]",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "armor",
    "arguments": "bytea",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.armor(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "bytea_to_text",
    "arguments": "data bytea",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.bytea_to_text(data bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$bytea_to_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "crypt",
    "arguments": "text, text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.crypt(text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_crypt$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "dearmor",
    "arguments": "text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.dearmor(text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_dearmor$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "decrypt",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "decrypt_iv",
    "arguments": "bytea, bytea, bytea, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "digest",
    "arguments": "bytea, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "digest",
    "arguments": "text, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.digest(text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "encrypt",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "encrypt_iv",
    "arguments": "bytea, bytea, bytea, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "gen_random_bytes",
    "arguments": "integer",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_random_bytes$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "gen_random_uuid",
    "arguments": "",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/pgcrypto', $function$pg_random_uuid$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "gen_salt",
    "arguments": "text, integer",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "gen_salt",
    "arguments": "text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "grant_pg_cron_access",
    "arguments": "",
    "return_type": "event_trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "grant_pg_graphql_access",
    "arguments": "",
    "return_type": "event_trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "grant_pg_net_access",
    "arguments": "",
    "return_type": "event_trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    IF NOT EXISTS (\n      SELECT 1\n      FROM pg_roles\n      WHERE rolname = 'supabase_functions_admin'\n    )\n    THEN\n      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n    END IF;\n\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n    IF EXISTS (\n      SELECT FROM pg_extension\n      WHERE extname = 'pg_net'\n      -- all versions in use on existing projects as of 2025-02-20\n      -- version 0.12.0 onwards don't need these applied\n      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')\n    ) THEN\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n    END IF;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "hmac",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "hmac",
    "arguments": "text, text, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http",
    "arguments": "request http_request",
    "return_type": "http_response",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http(request http_request)\n RETURNS http_response\n LANGUAGE c\nAS '$libdir/http', $function$http_request$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_delete",
    "arguments": "uri character varying",
    "return_type": "http_response",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_delete(uri character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT extensions.http(('DELETE', $1, NULL, NULL, NULL)::extensions.http_request) $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_delete",
    "arguments": "uri character varying, content character varying, content_type character varying",
    "return_type": "http_response",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_delete(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT extensions.http(('DELETE', $1, NULL, $3, $2)::extensions.http_request) $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_get",
    "arguments": "uri character varying, data jsonb",
    "return_type": "http_response",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_get(uri character varying, data jsonb)\n RETURNS http_response\n LANGUAGE sql\nAS $function$\n        SELECT extensions.http(('GET', $1 || '?' || extensions.urlencode($2), NULL, NULL, NULL)::extensions.http_request)\n    $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_get",
    "arguments": "uri character varying",
    "return_type": "http_response",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_get(uri character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT extensions.http(('GET', $1, NULL, NULL, NULL)::extensions.http_request) $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_head",
    "arguments": "uri character varying",
    "return_type": "http_response",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_head(uri character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT extensions.http(('HEAD', $1, NULL, NULL, NULL)::extensions.http_request) $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_header",
    "arguments": "field character varying, value character varying",
    "return_type": "http_header",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_header(field character varying, value character varying)\n RETURNS http_header\n LANGUAGE sql\nAS $function$ SELECT $1, $2 $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_list_curlopt",
    "arguments": "",
    "return_type": "TABLE(curlopt text, value text)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_list_curlopt()\n RETURNS TABLE(curlopt text, value text)\n LANGUAGE c\nAS '$libdir/http', $function$http_list_curlopt$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_patch",
    "arguments": "uri character varying, content character varying, content_type character varying",
    "return_type": "http_response",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_patch(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT extensions.http(('PATCH', $1, NULL, $3, $2)::extensions.http_request) $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_post",
    "arguments": "uri character varying, content character varying, content_type character varying",
    "return_type": "http_response",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_post(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT extensions.http(('POST', $1, NULL, $3, $2)::extensions.http_request) $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_post",
    "arguments": "uri character varying, data jsonb",
    "return_type": "http_response",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_post(uri character varying, data jsonb)\n RETURNS http_response\n LANGUAGE sql\nAS $function$\n        SELECT extensions.http(('POST', $1, NULL, 'application/x-www-form-urlencoded', extensions.urlencode($2))::extensions.http_request)\n    $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_put",
    "arguments": "uri character varying, content character varying, content_type character varying",
    "return_type": "http_response",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_put(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT extensions.http(('PUT', $1, NULL, $3, $2)::extensions.http_request) $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_reset_curlopt",
    "arguments": "",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_reset_curlopt()\n RETURNS boolean\n LANGUAGE c\nAS '$libdir/http', $function$http_reset_curlopt$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "http_set_curlopt",
    "arguments": "curlopt character varying, value character varying",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.http_set_curlopt(curlopt character varying, value character varying)\n RETURNS boolean\n LANGUAGE c\nAS '$libdir/http', $function$http_set_curlopt$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pg_stat_statements",
    "arguments": "showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision",
    "return_type": "SETOF record",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision)\n RETURNS SETOF record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_10$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pg_stat_statements_info",
    "arguments": "OUT dealloc bigint, OUT stats_reset timestamp with time zone",
    "return_type": "record",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)\n RETURNS record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pg_stat_statements_reset",
    "arguments": "userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0",
    "return_type": "void",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0)\n RETURNS void\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_7$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_armor_headers",
    "arguments": "text, OUT key text, OUT value text",
    "return_type": "SETOF record",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)\n RETURNS SETOF record\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_armor_headers$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_key_id",
    "arguments": "bytea",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_key_id_w$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea, text, text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea, text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea, text, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_encrypt",
    "arguments": "text, bytea, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_encrypt",
    "arguments": "text, bytea",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_encrypt_bytea",
    "arguments": "bytea, bytea",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_encrypt_bytea",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_decrypt",
    "arguments": "bytea, text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_decrypt",
    "arguments": "bytea, text, text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_decrypt_bytea",
    "arguments": "bytea, text, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_decrypt_bytea",
    "arguments": "bytea, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_encrypt",
    "arguments": "text, text, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_encrypt",
    "arguments": "text, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_encrypt_bytea",
    "arguments": "bytea, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_encrypt_bytea",
    "arguments": "bytea, text, text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgrst_ddl_watch",
    "arguments": "",
    "return_type": "event_trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgrst_drop_watch",
    "arguments": "",
    "return_type": "event_trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "set_graphql_placeholder",
    "arguments": "",
    "return_type": "event_trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "sign",
    "arguments": "payload json, secret text, algorithm text DEFAULT 'HS256'::text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.sign(payload json, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  header AS (\n    SELECT extensions.url_encode(convert_to('{\"alg\":\"' || algorithm || '\",\"typ\":\"JWT\"}', 'utf8')) AS data\n    ),\n  payload AS (\n    SELECT extensions.url_encode(convert_to(payload::text, 'utf8')) AS data\n    ),\n  signables AS (\n    SELECT header.data || '.' || payload.data AS data FROM header, payload\n    )\nSELECT\n    signables.data || '.' ||\n    extensions.algorithm_sign(signables.data, secret, algorithm) FROM signables;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "text_to_bytea",
    "arguments": "data text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.text_to_bytea(data text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$text_to_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "try_cast_double",
    "arguments": "inp text",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.try_cast_double(inp text)\n RETURNS double precision\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n  BEGIN\n    BEGIN\n      RETURN inp::double precision;\n    EXCEPTION\n      WHEN OTHERS THEN RETURN NULL;\n    END;\n  END;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "url_decode",
    "arguments": "data text",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.url_decode(data text)\n RETURNS bytea\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH t AS (SELECT translate(data, '-_', '+/') AS trans),\n     rem AS (SELECT length(t.trans) % 4 AS remainder FROM t) -- compute padding size\n    SELECT decode(\n        t.trans ||\n        CASE WHEN rem.remainder > 0\n           THEN repeat('=', (4 - rem.remainder))\n           ELSE '' END,\n    'base64') FROM t, rem;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "url_encode",
    "arguments": "data bytea",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.url_encode(data bytea)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    SELECT translate(encode(data, 'base64'), E'+/=\\n', '-_');\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "urlencode",
    "arguments": "string character varying",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.urlencode(string character varying)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$urlencode$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "urlencode",
    "arguments": "string bytea",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.urlencode(string bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$urlencode$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "urlencode",
    "arguments": "data jsonb",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.urlencode(data jsonb)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$urlencode_jsonb$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_generate_v1",
    "arguments": "",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_generate_v1mc",
    "arguments": "",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_generate_v3",
    "arguments": "namespace uuid, name text",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_generate_v4",
    "arguments": "",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_generate_v5",
    "arguments": "namespace uuid, name text",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_nil",
    "arguments": "",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.uuid_nil()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_nil$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_ns_dns",
    "arguments": "",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_ns_oid",
    "arguments": "",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_ns_url",
    "arguments": "",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_url$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_ns_x500",
    "arguments": "",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "verify",
    "arguments": "token text, secret text, algorithm text DEFAULT 'HS256'::text",
    "return_type": "TABLE(header json, payload json, valid boolean)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION extensions.verify(token text, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS TABLE(header json, payload json, valid boolean)\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n  SELECT\n    jwt.header AS header,\n    jwt.payload AS payload,\n    jwt.signature_ok AND tstzrange(\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'nbf')),\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'exp'))\n    ) @> CURRENT_TIMESTAMP AS valid\n  FROM (\n    SELECT\n      convert_from(extensions.url_decode(r[1]), 'utf8')::json AS header,\n      convert_from(extensions.url_decode(r[2]), 'utf8')::json AS payload,\n      r[3] = extensions.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS signature_ok\n    FROM regexp_split_to_array(token, '\\.') r\n  ) jwt\n$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "_internal_resolve",
    "arguments": "query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb",
    "return_type": "jsonb",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE c\nAS '$libdir/pg_graphql', $function$resolve_wrapper$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "comment_directive",
    "arguments": "comment_ text",
    "return_type": "jsonb",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "exception",
    "arguments": "message text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION graphql.exception(message text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "get_schema_version",
    "arguments": "",
    "return_type": "integer",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION graphql.get_schema_version()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n    select last_value from graphql.seq_schema_version;\n$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "increment_schema_version",
    "arguments": "",
    "return_type": "event_trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION graphql.increment_schema_version()\n RETURNS event_trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    perform pg_catalog.nextval('graphql.seq_schema_version');\nend;\n$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "resolve",
    "arguments": "query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb",
    "return_type": "jsonb",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n$function$\n"
  },
  {
    "schema": "graphql_public",
    "function_name": "graphql",
    "arguments": "\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb",
    "return_type": "jsonb",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION graphql_public.graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $function$\n"
  },
  {
    "schema": "net",
    "function_name": "_await_response",
    "arguments": "request_id bigint",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION net._await_response(request_id bigint)\n RETURNS boolean\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    rec net._http_response;\nbegin\n    while rec is null loop\n        select *\n        into rec\n        from net._http_response\n        where id = request_id;\n\n        if rec is null then\n            -- Wait 50 ms before checking again\n            perform pg_sleep(0.05);\n        end if;\n    end loop;\n\n    return true;\nend;\n$function$\n"
  },
  {
    "schema": "net",
    "function_name": "_encode_url_with_params_array",
    "arguments": "url text, params_array text[]",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION net._encode_url_with_params_array(url text, params_array text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS 'pg_net', $function$_encode_url_with_params_array$function$\n"
  },
  {
    "schema": "net",
    "function_name": "_http_collect_response",
    "arguments": "request_id bigint, async boolean DEFAULT true",
    "return_type": "net.http_response_result",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION net._http_collect_response(request_id bigint, async boolean DEFAULT true)\n RETURNS net.http_response_result\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    rec net._http_response;\n    req_exists boolean;\nbegin\n\n    if not async then\n        perform net._await_response(request_id);\n    end if;\n\n    select *\n    into rec\n    from net._http_response\n    where id = request_id;\n\n    if rec is null or rec.error_msg is not null then\n        -- The request is either still processing or the request_id provided does not exist\n\n        -- TODO: request in progress is indistinguishable from request that doesn't exist\n\n        -- No request matching request_id found\n        return (\n            'ERROR',\n            coalesce(rec.error_msg, 'request matching request_id not found'),\n            null\n        )::net.http_response_result;\n\n    end if;\n\n    -- Return a valid, populated http_response_result\n    return (\n        'SUCCESS',\n        'ok',\n        (\n            rec.status_code,\n            rec.headers,\n            rec.content\n        )::net.http_response\n    )::net.http_response_result;\nend;\n$function$\n"
  },
  {
    "schema": "net",
    "function_name": "_urlencode_string",
    "arguments": "string character varying",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION net._urlencode_string(string character varying)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS 'pg_net', $function$_urlencode_string$function$\n"
  },
  {
    "schema": "net",
    "function_name": "check_worker_is_up",
    "arguments": "",
    "return_type": "void",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION net.check_worker_is_up()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nbegin\n  if not exists (select pid from pg_stat_activity where backend_type ilike '%pg_net%') then\n    raise exception using\n      message = 'the pg_net background worker is not up'\n    , detail  = 'the pg_net background worker is down due to an internal error and cannot process requests'\n    , hint    = 'make sure that you didn''t modify any of pg_net internal tables';\n  end if;\nend\n$function$\n"
  },
  {
    "schema": "net",
    "function_name": "http_collect_response",
    "arguments": "request_id bigint, async boolean DEFAULT true",
    "return_type": "net.http_response_result",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION net.http_collect_response(request_id bigint, async boolean DEFAULT true)\n RETURNS net.http_response_result\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\nbegin\n  raise notice 'The net.http_collect_response function is deprecated.';\n  select net._http_collect_response(request_id, async);\nend;\n$function$\n"
  },
  {
    "schema": "net",
    "function_name": "http_delete",
    "arguments": "url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000",
    "return_type": "bigint",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION net.http_delete(url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\nbegin\n    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into params_array\n    from jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, timeout_milliseconds)\n    values (\n        'DELETE',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n"
  },
  {
    "schema": "net",
    "function_name": "http_get",
    "arguments": "url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000",
    "return_type": "bigint",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION net.http_get(url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\nbegin\n    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into params_array\n    from jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, timeout_milliseconds)\n    values (\n        'GET',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n"
  },
  {
    "schema": "net",
    "function_name": "http_post",
    "arguments": "url text, body jsonb DEFAULT '{}'::jsonb, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{\"Content-Type\": \"application/json\"}'::jsonb, timeout_milliseconds integer DEFAULT 5000",
    "return_type": "bigint",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION net.http_post(url text, body jsonb DEFAULT '{}'::jsonb, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{\"Content-Type\": \"application/json\"}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\n    content_type text;\nbegin\n\n    -- Exctract the content_type from headers\n    select\n        header_value into content_type\n    from\n        jsonb_each_text(coalesce(headers, '{}'::jsonb)) r(header_name, header_value)\n    where\n        lower(header_name) = 'content-type'\n    limit\n        1;\n\n    -- If the user provided new headers and omitted the content type\n    -- add it back in automatically\n    if content_type is null then\n        select headers || '{\"Content-Type\": \"application/json\"}'::jsonb into headers;\n    end if;\n\n    -- Confirm that the content-type is set as \"application/json\"\n    if content_type <> 'application/json' then\n        raise exception 'Content-Type header must be \"application/json\"';\n    end if;\n\n    select\n        coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into\n        params_array\n    from\n        jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, body, timeout_milliseconds)\n    values (\n        'POST',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        convert_to(body::text, 'UTF8'),\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n"
  },
  {
    "schema": "net",
    "function_name": "worker_restart",
    "arguments": "",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION net.worker_restart()\n RETURNS boolean\n LANGUAGE c\nAS 'pg_net', $function$worker_restart$function$\n"
  },
  {
    "schema": "pgbouncer",
    "function_name": "get_auth",
    "arguments": "p_usename text",
    "return_type": "TABLE(username text, password text)",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)\n RETURNS TABLE(username text, password text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\n  BEGIN\n      RAISE DEBUG 'PgBouncer auth request: %', p_usename;\n\n      RETURN QUERY\n      SELECT\n          rolname::text,\n          CASE WHEN rolvaliduntil < now()\n              THEN null\n              ELSE rolpassword::text\n          END\n      FROM pg_authid\n      WHERE rolname=$1 and rolcanlogin;\n  END;\n  $function$\n"
  },
  {
    "schema": "public",
    "function_name": "archive_old_loadings",
    "arguments": "days_threshold integer DEFAULT 30",
    "return_type": "TABLE(archived_count integer, message text)",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.archive_old_loadings(days_threshold integer DEFAULT 30)\n RETURNS TABLE(archived_count integer, message text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    updated_count INTEGER;\nBEGIN\n    --  ,   N  \n    UPDATE loadings \n    SET \n        loading_status = 'archived',\n        loading_updated = NOW()\n    WHERE loading_finish < (CURRENT_DATE - INTERVAL '1 day' * days_threshold)\n    AND loading_status = 'active';\n    \n    GET DIAGNOSTICS updated_count = ROW_COUNT;\n    \n    RETURN QUERY SELECT \n        updated_count,\n        CASE \n            WHEN updated_count > 0 THEN \n                ' ' || updated_count || '   ' || days_threshold || ' '\n            ELSE \n                '   '\n        END;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_halfvec",
    "arguments": "integer[], integer, boolean",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(integer[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_halfvec",
    "arguments": "real[], integer, boolean",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(real[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_halfvec",
    "arguments": "double precision[], integer, boolean",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(double precision[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_halfvec",
    "arguments": "numeric[], integer, boolean",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(numeric[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_sparsevec",
    "arguments": "numeric[], integer, boolean",
    "return_type": "sparsevec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(numeric[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_sparsevec",
    "arguments": "double precision[], integer, boolean",
    "return_type": "sparsevec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(double precision[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_sparsevec",
    "arguments": "real[], integer, boolean",
    "return_type": "sparsevec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(real[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_sparsevec",
    "arguments": "integer[], integer, boolean",
    "return_type": "sparsevec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(integer[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_vector",
    "arguments": "double precision[], integer, boolean",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_vector(double precision[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_vector",
    "arguments": "integer[], integer, boolean",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_vector(integer[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_vector",
    "arguments": "real[], integer, boolean",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_vector(real[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n"
  },
  {
    "schema": "public",
    "function_name": "array_to_vector",
    "arguments": "numeric[], integer, boolean",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.array_to_vector(numeric[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n"
  },
  {
    "schema": "public",
    "function_name": "assign_department_head",
    "arguments": "p_department_id uuid, p_user_id uuid",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.assign_department_head(p_department_id uuid, p_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  user_dept_id UUID;\n  current_head_id UUID;\nBEGIN\n  --    \n  IF NOT EXISTS(SELECT 1 FROM profiles WHERE user_id = p_user_id) THEN\n    RAISE EXCEPTION '  : %', p_user_id;\n  END IF;\n  \n  --    \n  IF NOT EXISTS(SELECT 1 FROM departments WHERE department_id = p_department_id) THEN\n    RAISE EXCEPTION '  : %', p_department_id;\n  END IF;\n  \n  --   \n  SELECT department_id INTO user_dept_id FROM profiles WHERE user_id = p_user_id;\n  \n  --      \n  IF user_dept_id != p_department_id THEN\n    RAISE EXCEPTION '       ';\n  END IF;\n  \n  --   \n  SELECT department_head_id INTO current_head_id FROM departments WHERE department_id = p_department_id;\n  \n  --   \n  UPDATE departments \n  SET department_head_id = p_user_id\n  WHERE department_id = p_department_id;\n  \n  --   department_head  \n  INSERT INTO user_roles (user_id, role_id, is_primary)\n  SELECT p_user_id, r.id, false\n  FROM roles r \n  WHERE r.name = 'department_head'\n  ON CONFLICT (user_id, role_id) DO NOTHING;\n  \n  --      ( )\n  IF current_head_id IS NOT NULL AND current_head_id != p_user_id THEN\n    DELETE FROM user_roles \n    WHERE user_id = current_head_id \n      AND role_id = (SELECT id FROM roles WHERE name = 'department_head');\n  END IF;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "assign_department_heads_from_positions",
    "arguments": "",
    "return_type": "TABLE(department_id uuid, department_name text, assigned_head_id uuid, head_name text, success boolean)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.assign_department_heads_from_positions()\n RETURNS TABLE(department_id uuid, department_name text, assigned_head_id uuid, head_name text, success boolean)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  dept_record RECORD;\n  head_record RECORD;\nBEGIN\n  --      \n  FOR dept_record IN\n    SELECT \n      d.department_id,\n      d.department_name\n    FROM departments d\n    WHERE d.department_head_id IS NULL\n      AND d.department_name != ' '\n  LOOP\n    --      \" \"   \n    SELECT \n      p.user_id,\n      CONCAT(p.first_name, ' ', p.last_name) as full_name\n    INTO head_record\n    FROM profiles p\n    JOIN positions pos ON p.position_id = pos.position_id\n    WHERE p.department_id = dept_record.department_id  --    !\n      AND pos.position_name = ' '\n    ORDER BY RANDOM()  --  \n    LIMIT 1;\n    \n    --   ,  \n    IF head_record.user_id IS NOT NULL THEN\n      --    \n      PERFORM assign_department_head(dept_record.department_id, head_record.user_id);\n      \n      RETURN QUERY SELECT\n        dept_record.department_id,\n        dept_record.department_name,\n        head_record.user_id,\n        head_record.full_name,\n        TRUE;\n    ELSE\n      --    ,  NULL\n      RETURN QUERY SELECT\n        dept_record.department_id,\n        dept_record.department_name,\n        NULL::UUID,\n        '   '::TEXT,\n        FALSE;\n    END IF;\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "assign_team_lead",
    "arguments": "p_team_id uuid, p_user_id uuid",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.assign_team_lead(p_team_id uuid, p_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  user_team_id UUID;\n  current_lead_id UUID;\nBEGIN\n  --    \n  IF NOT EXISTS(SELECT 1 FROM profiles WHERE user_id = p_user_id) THEN\n    RAISE EXCEPTION '  : %', p_user_id;\n  END IF;\n  \n  --    \n  IF NOT EXISTS(SELECT 1 FROM teams WHERE team_id = p_team_id) THEN\n    RAISE EXCEPTION '  : %', p_team_id;\n  END IF;\n  \n  --   \n  SELECT team_id INTO user_team_id FROM profiles WHERE user_id = p_user_id;\n  \n  --      \n  IF user_team_id != p_team_id THEN\n    RAISE EXCEPTION '       ';\n  END IF;\n  \n  --   \n  SELECT team_lead_id INTO current_lead_id FROM teams WHERE team_id = p_team_id;\n  \n  --   \n  UPDATE teams \n  SET team_lead_id = p_user_id\n  WHERE team_id = p_team_id;\n  \n  --   team_lead  \n  INSERT INTO user_roles (user_id, role_id, is_primary)\n  SELECT p_user_id, r.id, false\n  FROM roles r \n  WHERE r.name = 'team_lead'\n  ON CONFLICT (user_id, role_id) DO NOTHING;\n  \n  --      ( )\n  IF current_lead_id IS NOT NULL AND current_lead_id != p_user_id THEN\n    DELETE FROM user_roles \n    WHERE user_id = current_head_id \n      AND role_id = (SELECT id FROM roles WHERE name = 'team_lead');\n  END IF;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "assign_team_leads_from_positions",
    "arguments": "",
    "return_type": "TABLE(team_id uuid, team_name text, department_name text, assigned_lead_id uuid, lead_name text, success boolean)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.assign_team_leads_from_positions()\n RETURNS TABLE(team_id uuid, team_name text, department_name text, assigned_lead_id uuid, lead_name text, success boolean)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  team_record RECORD;\n  lead_record RECORD;\nBEGIN\n  --      \n  FOR team_record IN\n    SELECT \n      t.team_id,\n      t.team_name,\n      d.department_name\n    FROM teams t\n    JOIN departments d ON t.department_id = d.department_id\n    WHERE t.team_lead_id IS NULL\n      AND t.team_name != ' '\n  LOOP\n    --      \"\"   \n    SELECT \n      p.user_id,\n      CONCAT(p.first_name, ' ', p.last_name) as full_name\n    INTO lead_record\n    FROM profiles p\n    JOIN positions pos ON p.position_id = pos.position_id\n    WHERE p.team_id = team_record.team_id  --    !\n      AND pos.position_name = ''\n    ORDER BY RANDOM()  --  \n    LIMIT 1;\n    \n    --   ,  \n    IF lead_record.user_id IS NOT NULL THEN\n      --    \n      PERFORM assign_team_lead(team_record.team_id, lead_record.user_id);\n      \n      RETURN QUERY SELECT\n        team_record.team_id,\n        team_record.team_name,\n        team_record.department_name,\n        lead_record.user_id,\n        lead_record.full_name,\n        TRUE;\n    ELSE\n      --    ,  NULL\n      RETURN QUERY SELECT\n        team_record.team_id,\n        team_record.team_name,\n        team_record.department_name,\n        NULL::UUID,\n        '   '::TEXT,\n        FALSE;\n    END IF;\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "binary_quantize",
    "arguments": "halfvec",
    "return_type": "bit",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.binary_quantize(halfvec)\n RETURNS bit\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_binary_quantize$function$\n"
  },
  {
    "schema": "public",
    "function_name": "binary_quantize",
    "arguments": "vector",
    "return_type": "bit",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.binary_quantize(vector)\n RETURNS bit\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$binary_quantize$function$\n"
  },
  {
    "schema": "public",
    "function_name": "can_view_project_budget",
    "arguments": "project_uuid uuid",
    "return_type": "boolean",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.can_view_project_budget(project_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 FROM projects pr\n    WHERE pr.project_id = project_uuid\n    AND (pr.project_manager = auth.uid() OR pr.project_lead_engineer = auth.uid())\n  );\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "can_view_section_budget",
    "arguments": "section_uuid uuid",
    "return_type": "boolean",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.can_view_section_budget(section_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN (\n    -- 1.   \n    EXISTS (\n      SELECT 1 FROM sections s\n      WHERE s.section_id = section_uuid\n      AND s.section_responsible = auth.uid()\n    )\n    -- 2.     \n    OR EXISTS (\n      SELECT 1 FROM loadings l\n      JOIN profiles p ON l.loading_responsible = p.user_id\n      JOIN departments d ON p.department_id = d.department_id\n      WHERE l.loading_section = section_uuid\n      AND d.department_head_id = auth.uid()\n    )\n    -- 3.    \n    OR EXISTS (\n      SELECT 1 FROM sections s\n      JOIN projects pr ON pr.project_id = s.section_project_id\n      WHERE s.section_id = section_uuid\n      AND (pr.project_manager = auth.uid() OR pr.project_lead_engineer = auth.uid())\n    )\n  );\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "check_department_can_be_deleted",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.check_department_can_be_deleted()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  employee_count INTEGER;\r\nBEGIN\r\n  --     \r\n  SELECT COUNT(*) INTO employee_count\r\n  FROM profiles\r\n  WHERE department_id = OLD.department_id;\r\n  \r\n  --       -  \r\n  IF employee_count > 0 THEN\r\n    RAISE EXCEPTION '   \"%\".    : %.      .', \r\n      OLD.department_name, employee_count;\r\n  END IF;\r\n  \r\n  --    -  \r\n  RETURN OLD;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "check_departments_integrity",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.check_departments_integrity()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  conflict_count INTEGER;\nBEGIN\n  --        \n  IF NEW.department_head_id IS NOT NULL THEN\n    SELECT COUNT(*) INTO conflict_count\n    FROM profiles p\n    WHERE p.user_id = NEW.department_head_id \n      AND p.department_id = NEW.department_id;\n    \n    IF conflict_count = 0 THEN\n      RAISE EXCEPTION '       . department_head_id: %, department_id: %', \n        NEW.department_head_id, NEW.department_id;\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "check_organizational_integrity",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.check_organizational_integrity()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  conflict_count INTEGER;\nBEGIN\n  --   department_id   department_id \n  IF TG_TABLE_NAME = 'profiles' AND (NEW.team_id IS NOT NULL AND NEW.department_id IS NOT NULL) THEN\n    SELECT COUNT(*) INTO conflict_count\n    FROM teams t\n    WHERE t.team_id = NEW.team_id \n      AND t.department_id != NEW.department_id;\n    \n    IF conflict_count > 0 THEN\n      RAISE EXCEPTION '       . team_id: %, department_id: %', \n        NEW.team_id, NEW.department_id;\n    END IF;\n  END IF;\n  \n  --         \n  IF TG_TABLE_NAME = 'departments' AND NEW.department_head_id IS NOT NULL THEN\n    SELECT COUNT(*) INTO conflict_count\n    FROM profiles p\n    WHERE p.user_id = NEW.department_head_id \n      AND p.department_id = NEW.department_id;\n    \n    IF conflict_count > 0 THEN\n      RAISE EXCEPTION '        . department_head_id: %, department_id: %', \n        NEW.department_head_id, NEW.department_id;\n    END IF;\n  END IF;\n  \n  --        \n  IF TG_TABLE_NAME = 'teams' AND NEW.team_lead_id IS NOT NULL THEN\n    SELECT COUNT(*) INTO conflict_count\n    FROM profiles p\n    WHERE p.user_id = NEW.team_lead_id \n      AND p.team_id = NEW.team_id;\n    \n    IF conflict_count > 0 THEN\n      RAISE EXCEPTION '        . team_lead_id: %, team_id: %', \n        NEW.team_lead_id, NEW.team_id;\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "check_profiles_integrity",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.check_profiles_integrity()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\ndeclare\r\n  conflict_count integer;\r\nbegin\r\n  -- 1)  ,    \r\n  if new.team_id is not null and new.department_id is null then\r\n    raise exception '       . team_id: %, department_id: NULL',\r\n      new.team_id;\r\n  end if;\r\n\r\n  -- 2)     \r\n  if new.team_id is not null and new.department_id is not null then\r\n    select count(*) into conflict_count\r\n    from public.teams t\r\n    where t.team_id = new.team_id\r\n      and t.department_id is not null\r\n      and t.department_id <> new.department_id;\r\n\r\n    if conflict_count > 0 then\r\n      raise exception '       . team_id: %, department_id: %',\r\n        new.team_id, new.department_id;\r\n    end if;\r\n  end if;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "check_stage_responsibles_fk",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.check_stage_responsibles_fk()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    --         NULL\n    IF NEW.decomposition_stage_responsibles IS NOT NULL\n       AND array_length(NEW.decomposition_stage_responsibles, 1) > 0 THEN\n\n        --    user_id    profiles\n        IF EXISTS (\n            SELECT 1\n            FROM unnest(NEW.decomposition_stage_responsibles) AS user_id\n            WHERE user_id NOT IN (SELECT user_id FROM profiles)\n        ) THEN\n            RAISE EXCEPTION ' user_id  decomposition_stage_responsibles';\n        END IF;\n    END IF;\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "check_teams_integrity",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.check_teams_integrity()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  conflict_count INTEGER;\nBEGIN\n  --       \n  IF NEW.team_lead_id IS NOT NULL THEN\n    SELECT COUNT(*) INTO conflict_count\n    FROM profiles p\n    WHERE p.user_id = NEW.team_lead_id \n      AND p.team_id = NEW.team_id;\n    \n    IF conflict_count = 0 THEN\n      RAISE EXCEPTION '       . team_lead_id: %, team_id: %', \n        NEW.team_lead_id, NEW.team_id;\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "compute_user_permissions",
    "arguments": "p_user_id uuid",
    "return_type": "jsonb",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.compute_user_permissions(p_user_id uuid)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\n  with perms as (\r\n    select distinct p.name\r\n    from public.user_roles ur\r\n    join public.role_permissions rp on rp.role_id = ur.role_id\r\n    join public.permissions p on p.id = rp.permission_id\r\n    where ur.user_id = p_user_id\r\n  )\r\n  select coalesce(\r\n           jsonb_agg(perms.name order by perms.name),\r\n           '[]'::jsonb\r\n         )\r\n  from perms;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "cosine_distance",
    "arguments": "halfvec, halfvec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.cosine_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_cosine_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "cosine_distance",
    "arguments": "vector, vector",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.cosine_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$cosine_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "cosine_distance",
    "arguments": "sparsevec, sparsevec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.cosine_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_cosine_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_default_team_for_department",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.create_default_team_for_department()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  --     \"{_}-\"\r\n  INSERT INTO teams (\r\n    team_id,\r\n    team_name,\r\n    department_id,\r\n    team_lead_id\r\n  )\r\n  VALUES (\r\n    gen_random_uuid(),\r\n    NEW.department_name || '-',\r\n    NEW.department_id,\r\n    NULL\r\n  );\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_profile_on_signup",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.create_profile_on_signup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\ndeclare\r\n  default_department uuid := '42c93225-0ac5-41fe-820a-5ecbe33b5e2d';\r\n  default_team       uuid := '983b9ae6-6bcf-472d-ba26-eee2e4673787';\r\n  default_position   uuid := '90ecd7f2-b969-4a0d-bba7-226cf0cb8e7b';\r\n  default_category   uuid := '7b20a482-b5e0-40b4-9cb8-bf5e3f1a0e3f';\r\n  default_role       uuid := '3ac4f27e-c94c-4b0d-b750-9fb6366b85bc';\r\n\r\n  --     \r\n  form_subdivision_id uuid;\r\n  form_department_id  uuid;\r\n  form_team_id        uuid;\r\n  form_position_id    uuid;\r\n  form_category_id    uuid;\r\n\r\n  user_name         text := '';\r\n  first_name_value  text := '';\r\n  last_name_value   text := '';\r\n  name_parts        text[];\r\nbegin\r\n  --    user_metadata (  )\r\n  if new.raw_user_meta_data ? 'subdivision_id' then\r\n    form_subdivision_id := (new.raw_user_meta_data->>'subdivision_id')::uuid;\r\n  end if;\r\n  \r\n  if new.raw_user_meta_data ? 'department_id' then\r\n    form_department_id := (new.raw_user_meta_data->>'department_id')::uuid;\r\n  end if;\r\n  \r\n  if new.raw_user_meta_data ? 'team_id' then\r\n    form_team_id := (new.raw_user_meta_data->>'team_id')::uuid;\r\n  end if;\r\n  \r\n  if new.raw_user_meta_data ? 'position_id' then\r\n    form_position_id := (new.raw_user_meta_data->>'position_id')::uuid;\r\n  end if;\r\n  \r\n  if new.raw_user_meta_data ? 'category_id' then\r\n    form_category_id := (new.raw_user_meta_data->>'category_id')::uuid;\r\n  end if;\r\n\r\n  --    raw_user_meta_data\r\n  if new.raw_user_meta_data ? 'name' then\r\n    user_name := new.raw_user_meta_data->>'name';\r\n    if user_name is not null and user_name <> '' then\r\n      name_parts := string_to_array(trim(user_name), ' ');\r\n      if array_length(name_parts, 1) >= 1 then\r\n        first_name_value := name_parts[1];\r\n        if array_length(name_parts, 1) >= 2 then\r\n          last_name_value := array_to_string(name_parts[2:], ' ');\r\n        end if;\r\n      end if;\r\n    end if;\r\n  end if;\r\n\r\n  --       ( )  \r\n  insert into public.profiles (\r\n    user_id, first_name, last_name, subdivision_id, department_id, team_id,\r\n    position_id, email, created_at, category_id, employment_rate, salary, is_hourly\r\n  ) values (\r\n    new.id,\r\n    first_name_value,\r\n    last_name_value,\r\n    coalesce(form_subdivision_id, null),  --      NULL\r\n    coalesce(form_department_id, default_department),\r\n    coalesce(form_team_id, default_team),\r\n    coalesce(form_position_id, default_position),\r\n    new.email,\r\n    timezone('utc', now()),\r\n    coalesce(form_category_id, default_category),\r\n    1, 0, true\r\n  );\r\n\r\n  --  \r\n  if exists (select 1 from public.roles r where r.id = default_role) then\r\n    insert into public.user_roles (user_id, role_id, assigned_by)\r\n    values (new.id, default_role, null)\r\n    on conflict (user_id, role_id) do nothing;\r\n  end if;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "delete_project_cascade",
    "arguments": "project_id_param uuid",
    "return_type": "void",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.delete_project_cascade(project_id_param uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  stage_ids UUID[];\n  section_ids UUID[];\n  task_ids UUID[];\nBEGIN\n  --  \n  BEGIN\n    --  ID   \n    SELECT ARRAY(\n      SELECT stage_id \n      FROM stages \n      WHERE stage_project_id = project_id_param\n    ) INTO stage_ids;\n    \n    --  ID   \n    SELECT ARRAY(\n      SELECT section_id \n      FROM sections \n      WHERE section_project_id = project_id_param\n    ) INTO section_ids;\n    \n    --  ID     \n    SELECT ARRAY(\n      SELECT task_id \n      FROM tasks \n      WHERE task_parent_section = ANY(section_ids)\n    ) INTO task_ids;\n    \n    -- 1.    \n    DELETE FROM decomposition_items \n    WHERE decomposition_item_section_id = ANY(section_ids);\n    \n    -- 2.    \n    DELETE FROM loadings \n    WHERE loading_task = ANY(task_ids);\n    \n    -- 3.    \n    DELETE FROM loadings \n    WHERE loading_section = ANY(section_ids);\n    \n    -- 4.   \n    DELETE FROM plan_loadings \n    WHERE plan_loading_section = ANY(section_ids);\n    \n    -- 5.  \n    DELETE FROM tasks \n    WHERE task_parent_section = ANY(section_ids);\n    \n    -- 6.  \n    DELETE FROM assignments \n    WHERE project_id = project_id_param;\n    \n    -- 7.  \n    DELETE FROM sections \n    WHERE section_project_id = project_id_param;\n    \n    -- 8.    \n    DELETE FROM objects \n    WHERE object_stage_id = ANY(stage_ids);\n    \n    -- 9.    \n    DELETE FROM stages \n    WHERE stage_project_id = project_id_param;\n    \n    -- 10.  \n    DELETE FROM contracts \n    WHERE contract_project_id = project_id_param;\n    \n    -- 11. ,   \n    DELETE FROM projects \n    WHERE project_id = project_id_param;\n    \n    --    ,    \n    RAISE NOTICE ' %  ', project_id_param;\n    \n  EXCEPTION\n    WHEN OTHERS THEN\n      --     \n      RAISE EXCEPTION '   : %', SQLERRM;\n  END;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "delete_role_with_permissions",
    "arguments": "role_id_param uuid",
    "return_type": "jsonb",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.delete_role_with_permissions(role_id_param uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  role_name TEXT;\n  permissions_deleted INTEGER := 0;\n  result JSONB;\nBEGIN\n  --     \n  SELECT name INTO role_name FROM roles WHERE id = role_id_param;\n  \n  IF role_name IS NULL THEN\n    RETURN jsonb_build_object(\n      'success', false,\n      'error', 'Role not found',\n      'error_code', 'ROLE_NOT_FOUND'\n    );\n  END IF;\n  \n  --      \n  DELETE FROM role_permissions WHERE role_id = role_id_param;\n  GET DIAGNOSTICS permissions_deleted = ROW_COUNT;\n  \n  --   \n  DELETE FROM roles WHERE id = role_id_param;\n  \n  -- ,    \n  IF NOT FOUND THEN\n    RETURN jsonb_build_object(\n      'success', false,\n      'error', 'Failed to delete role',\n      'error_code', 'DELETE_FAILED'\n    );\n  END IF;\n  \n  RETURN jsonb_build_object(\n    'success', true,\n    'role_name', role_name,\n    'permissions_deleted', permissions_deleted\n  );\n  \nEXCEPTION\n  WHEN OTHERS THEN\n    --       \n    RETURN jsonb_build_object(\n      'success', false,\n      'error', SQLERRM,\n      'error_code', SQLSTATE\n    );\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "execute_sql",
    "arguments": "sql_query text",
    "return_type": "json",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.execute_sql(sql_query text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    result json;\nBEGIN\n    --   -  SELECT \n    IF sql_query !~* '^\\s*SELECT\\s+' THEN\n        RAISE EXCEPTION 'Only SELECT queries are allowed';\n    END IF;\n    \n    --    \n    IF sql_query ~* '\\b(DROP|DELETE|UPDATE|INSERT|CREATE|ALTER|TRUNCATE|MERGE|CALL)\\b' THEN\n        RAISE EXCEPTION 'Dangerous SQL commands are not allowed';\n    END IF;\n    \n    --       JSON\n    EXECUTE 'SELECT json_agg(row_to_json(t)) FROM (' || sql_query || ') t' INTO result;\n    \n    --   NULL ( ),   \n    IF result IS NULL THEN\n        result := '[]'::json;\n    END IF;\n    \n    RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "fix_entire_organizational_system",
    "arguments": "",
    "return_type": "TABLE(step text, details text, records_affected integer, success boolean)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.fix_entire_organizational_system()\n RETURNS TABLE(step text, details text, records_affected integer, success boolean)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  violations_count INTEGER;\n  heads_assigned INTEGER;\n  leads_assigned INTEGER;\nBEGIN\n  --  1:   \n  SELECT COUNT(*) INTO violations_count\n  FROM view_integrity_violations\n  WHERE violation_type = 'employee_wrong_department';\n  \n  --  \n  PERFORM fix_integrity_violations();\n  \n  RETURN QUERY SELECT\n    '  '::TEXT,\n    ' ' || violations_count || ' '::TEXT,\n    violations_count,\n    TRUE;\n  \n  --  2:   \n  SELECT COUNT(*) INTO heads_assigned\n  FROM assign_department_heads_from_positions();\n  \n  RETURN QUERY SELECT\n    '  '::TEXT,\n    ' ' || heads_assigned || ' '::TEXT,\n    heads_assigned,\n    TRUE;\n  \n  --  3:   \n  SELECT COUNT(*) INTO leads_assigned\n  FROM assign_team_leads_from_positions();\n  \n  RETURN QUERY SELECT\n    '  '::TEXT,\n    ' ' || leads_assigned || ' '::TEXT,\n    leads_assigned,\n    TRUE;\n  \n  --  4:   \n  REFRESH MATERIALIZED VIEW mv_user_permissions;\n  \n  RETURN QUERY SELECT\n    '  '::TEXT,\n    '  '::TEXT,\n    1,\n    TRUE;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "fix_integrity_violations",
    "arguments": "",
    "return_type": "TABLE(user_id uuid, user_name text, old_team_id uuid, new_team_id uuid, old_department_id uuid, new_department_id uuid, action text, success boolean)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.fix_integrity_violations()\n RETURNS TABLE(user_id uuid, user_name text, old_team_id uuid, new_team_id uuid, old_department_id uuid, new_department_id uuid, action text, success boolean)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  violation_record RECORD;\n  correct_team_id UUID;\n  correct_department_id UUID;\n  team_record RECORD;\nBEGIN\n  --    \n  FOR violation_record IN \n    SELECT \n      v.user_id,\n      v.details,\n      p.team_id as current_team_id,\n      p.department_id as current_department_id\n    FROM view_integrity_violations v\n    JOIN profiles p ON v.user_id = p.user_id\n    WHERE v.violation_type = 'employee_wrong_department'\n  LOOP\n    --      \n    SELECT \n      t.team_id,\n      t.department_id\n    INTO team_record\n    FROM teams t\n    WHERE t.department_id = violation_record.current_department_id\n      AND t.team_name != ' '\n    ORDER BY t.team_name\n    LIMIT 1;\n    \n    --   ,  \n    IF team_record.team_id IS NOT NULL THEN\n      correct_team_id := team_record.team_id;\n      correct_department_id := team_record.department_id;\n      \n      --   ( )\n      UPDATE profiles \n      SET \n        team_id = correct_team_id,\n        department_id = correct_department_id\n      WHERE profiles.user_id = violation_record.user_id;\n      \n      --  \n      RETURN QUERY SELECT\n        violation_record.user_id,\n        violation_record.details::TEXT,\n        violation_record.current_team_id,\n        correct_team_id,\n        violation_record.current_department_id,\n        correct_department_id,\n        '   '::TEXT,\n        TRUE;\n    ELSE\n      --   ,   ,   \n      UPDATE profiles \n      SET team_id = NULL\n      WHERE profiles.user_id = violation_record.user_id;\n      \n      RETURN QUERY SELECT\n        violation_record.user_id,\n        violation_record.details::TEXT,\n        violation_record.current_team_id,\n        NULL::UUID,\n        violation_record.current_department_id,\n        violation_record.current_department_id,\n        '   ( )'::TEXT,\n        TRUE;\n    END IF;\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "fn_loadings_sync_section_from_stage",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.fn_loadings_sync_section_from_stage()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_section uuid;\r\nBEGIN\r\n  SELECT ds.decomposition_stage_section_id\r\n    INTO v_section\r\n  FROM public.decomposition_stages ds\r\n  WHERE ds.decomposition_stage_id = NEW.loading_stage;\r\n\r\n  IF v_section IS NULL THEN\r\n    RAISE EXCEPTION 'Invalid loading_stage %: no such stage', NEW.loading_stage;\r\n  END IF;\r\n\r\n  --  section,    stage\r\n  NEW.loading_section := v_section;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "fn_notify_on_section_comment",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.fn_notify_on_section_comment()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_entity_type_id uuid;\n  v_section_name text;\n  v_section_responsible uuid;\n  v_author_name text;\n  v_recipients uuid[];\n  v_comment_preview text;\n  v_notification_id uuid;\nbegin\n  -- Ensure entity type id\n  select id into v_entity_type_id\n  from public.entity_types\n  where entity_name = 'section_comment';\n\n  if v_entity_type_id is null then\n    insert into public.entity_types(entity_name)\n    values ('section_comment')\n    returning id into v_entity_type_id;\n  end if;\n\n  -- Get section data\n  select s.section_name, s.section_responsible\n    into v_section_name, v_section_responsible\n  from public.sections s\n  where s.section_id = new.section_id;\n\n  -- Author name\n  select trim(coalesce(nullif(concat_ws(' ', p.first_name, p.last_name), ''), ''))\n    into v_author_name\n  from public.profiles p\n  where p.user_id = new.author_id;\n\n  if v_author_name is null or v_author_name = '' then\n    v_author_name := '';\n  end if;\n\n  -- Recipients: mentions  {responsible} \\ {author}\n  v_recipients := coalesce(new.mentions, array[]::uuid[]);\n  if v_section_responsible is not null then\n    v_recipients := array_append(v_recipients, v_section_responsible);\n  end if;\n  v_recipients := (\n    select array_agg(distinct u)\n    from unnest(v_recipients) as u\n    where u is distinct from new.author_id\n  );\n\n  if v_recipients is null or array_length(v_recipients, 1) is null then\n    return new;\n  end if;\n\n  -- Comment preview (strip HTML, max 100 chars)\n  v_comment_preview := substr(regexp_replace(new.content, '<[^>]*>', '', 'g'), 1, 100);\n\n  -- If notification already exists for this comment, reuse id\n  select n.id into v_notification_id\n  from public.notifications n\n  where n.source_comment_id = new.comment_id\n  limit 1;\n\n  if v_notification_id is null then\n    insert into public.notifications (entity_type_id, payload, rendered_text, source_comment_id)\n    values (\n      v_entity_type_id,\n      jsonb_build_object(\n        'title', format('   \"%s\"', v_section_name),\n        'message', format('%s: \"%s%s\"', v_author_name, v_comment_preview, case when length(v_comment_preview) = 100 then '...' else '' end),\n        'type', 'info',\n        'action', jsonb_build_object('type', 'navigate', 'url', format('/dashboard/projects?section=%s&tab=comments', new.section_id)),\n        'section_comment', jsonb_build_object(\n          'section_id', new.section_id,\n          'section_name', v_section_name,\n          'author_name', v_author_name,\n          'comment_preview', v_comment_preview\n        )\n      ),\n      null,\n      new.comment_id\n    )\n    returning id into v_notification_id;\n  end if;\n\n  -- Insert user notifications\n  insert into public.user_notifications (notification_id, user_id)\n  select v_notification_id, uid\n  from unnest(v_recipients) as uid;\n\n  return new;\nend;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "fn_track_loading_changes",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.fn_track_loading_changes()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_old_team_id UUID;\n  v_new_team_id UUID;\nBEGIN\n  --     \n  --  loading_responsible  (  )\n  IF OLD.loading_responsible != NEW.loading_responsible \n     AND NEW.loading_status = 'active' THEN\n    \n    --  team_id  \n    SELECT team_id INTO v_old_team_id\n    FROM profiles\n    WHERE user_id = OLD.loading_responsible;\n    \n    --      \n    IF v_old_team_id IS NOT NULL THEN\n      INSERT INTO teams_activity (\n        team_id,\n        confirmed_by,\n        activity_type,\n        confirmed_at\n      )\n      VALUES (\n        v_old_team_id,\n        OLD.loading_responsible,\n        'loading_transferred',\n        NOW()\n      );\n      \n      RAISE NOTICE '  %   % ( : %)', \n        NEW.loading_id, v_old_team_id, OLD.loading_responsible;\n    END IF;\n    \n    --  team_id   ( )\n    SELECT team_id INTO v_new_team_id\n    FROM profiles\n    WHERE user_id = NEW.loading_responsible;\n    \n    IF v_new_team_id IS NOT NULL THEN\n      RAISE NOTICE ' %    % ( : %)', \n        NEW.loading_id, v_new_team_id, NEW.loading_responsible;\n    END IF;\n    \n    --      loading_updated \n  END IF;\n\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "fn_track_loading_deletion",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.fn_track_loading_deletion()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_team_id UUID;\nBEGIN\n  --  team_id ,   \n  SELECT team_id INTO v_team_id\n  FROM profiles\n  WHERE user_id = OLD.loading_responsible;\n  \n  --     ( NULL)\n  IF v_team_id IS NOT NULL THEN\n    --    teams_activity   \n    INSERT INTO teams_activity (\n      team_id,\n      confirmed_by,\n      activity_type,\n      confirmed_at\n    )\n    VALUES (\n      v_team_id,\n      OLD.loading_responsible,\n      'loading_deleted',\n      NOW()\n    );\n  END IF;\n  \n  --  OLD   \n  RETURN OLD;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_decomposition_bootstrap",
    "arguments": "p_section_id uuid",
    "return_type": "jsonb",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.get_decomposition_bootstrap(p_section_id uuid)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\nwith cats as (\n  select jsonb_agg(jsonb_build_object(\n    'work_category_id', work_category_id,\n    'work_category_name', work_category_name\n  ) order by work_category_name) as data\n  from public.work_categories\n),\nstatuses as (\n  select jsonb_agg(jsonb_build_object(\n    'id', id,\n    'name', name,\n    'color', color,\n    'description', description\n  ) order by name) as data\n  from public.section_statuses\n),\nprofiles as (\n  select jsonb_agg(jsonb_build_object(\n    'user_id', user_id,\n    'first_name', first_name,\n    'last_name', last_name,\n    'email', email\n  ) order by first_name, last_name) as data\n  from public.profiles\n),\ndifficulty as (\n  select jsonb_agg(jsonb_build_object(\n    'difficulty_id', difficulty_id,\n    'difficulty_abbr', difficulty_abbr,\n    'difficulty_definition', difficulty_definition,\n    'difficulty_weight', difficulty_weight\n  ) order by difficulty_weight) as data\n  from public.decomposition_difficulty_levels\n),\nstages as (\n  select jsonb_agg(jsonb_build_object(\n    'decomposition_stage_id', ds.decomposition_stage_id,\n    'decomposition_stage_name', ds.decomposition_stage_name,\n    'decomposition_stage_start', ds.decomposition_stage_start,\n    'decomposition_stage_finish', ds.decomposition_stage_finish,\n    'decomposition_stage_description', ds.decomposition_stage_description,\n    'decomposition_stage_status_id', ds.decomposition_stage_status_id,\n    'decomposition_stage_responsibles', ds.decomposition_stage_responsibles,\n    'decomposition_stage_order', ds.decomposition_stage_order\n  ) order by ds.decomposition_stage_order) as data\n  from public.decomposition_stages ds\n  where ds.decomposition_stage_section_id = p_section_id\n),\nitems_raw as (\n  select di.decomposition_item_id,\n         di.decomposition_item_description,\n         di.decomposition_item_work_category_id,\n         di.decomposition_item_planned_hours,\n         di.decomposition_item_planned_due_date,\n         di.decomposition_item_order,\n         di.decomposition_item_responsible,\n         di.decomposition_item_status_id,\n         di.decomposition_item_progress,\n         di.decomposition_item_stage_id,\n         di.decomposition_item_difficulty_id,\n         pr.user_id as prof_user_id,\n         pr.first_name as prof_first_name,\n         pr.last_name as prof_last_name,\n         pr.email as prof_email,\n         ss.id as st_id,\n         ss.name as st_name,\n         ss.color as st_color,\n         ss.description as st_desc,\n         di.decomposition_item_created_at\n  from public.decomposition_items di\n  left join public.profiles pr on pr.user_id = di.decomposition_item_responsible\n  left join public.section_statuses ss on ss.id = di.decomposition_item_status_id\n  where di.decomposition_item_section_id = p_section_id\n),\nitems as (\n  select jsonb_agg(\n    jsonb_build_object(\n      'decomposition_item_id', decomposition_item_id,\n      'decomposition_item_description', decomposition_item_description,\n      'decomposition_item_work_category_id', decomposition_item_work_category_id,\n      'decomposition_item_planned_hours', decomposition_item_planned_hours,\n      'decomposition_item_planned_due_date', decomposition_item_planned_due_date,\n      'decomposition_item_order', decomposition_item_order,\n      'decomposition_item_responsible', decomposition_item_responsible,\n      'decomposition_item_status_id', decomposition_item_status_id,\n      'decomposition_item_progress', decomposition_item_progress,\n      'decomposition_item_stage_id', decomposition_item_stage_id,\n      'decomposition_item_difficulty_id', decomposition_item_difficulty_id,\n      'profiles', case when prof_user_id is not null then jsonb_build_object(\n        'user_id', prof_user_id,\n        'first_name', prof_first_name,\n        'last_name', prof_last_name,\n        'email', prof_email\n      ) else null end,\n      'section_statuses', case when st_id is not null then jsonb_build_object(\n        'id', st_id,\n        'name', st_name,\n        'color', st_color,\n        'description', st_desc\n      ) else null end\n    )\n    order by decomposition_item_order, decomposition_item_created_at\n  ) as data\n  from items_raw\n),\nactuals_agg as (\n  select di.decomposition_item_id,\n         coalesce(sum(wl.work_log_hours),0)::numeric as actual_hours,\n         count(wl.work_log_id)::bigint as logs_count\n  from public.decomposition_items di\n  left join public.work_logs wl on wl.decomposition_item_id = di.decomposition_item_id\n  where di.decomposition_item_section_id = p_section_id\n  group by di.decomposition_item_id\n),\nactuals as (\n  select jsonb_agg(\n    jsonb_build_object(\n      'decomposition_item_id', decomposition_item_id,\n      'actual_hours', actual_hours,\n      'logs_count', logs_count\n    )\n    order by decomposition_item_id\n  ) as data\n  from actuals_agg\n),\nsection_totals as (\n  select to_jsonb(t) as data from public.get_section_decomposition_totals(p_section_id) t\n),\nsection_meta as (\n  select jsonb_build_object(\n    'section_start_date', s.section_start_date,\n    'responsible_department_id', resp.department_id\n  ) as data\n  from public.sections s\n  left join public.profiles resp on resp.user_id = s.section_responsible\n  where s.section_id = p_section_id\n)\nselect jsonb_build_object(\n  'categories', (select data from cats),\n  'profiles', (select data from profiles),\n  'statuses', (select data from statuses),\n  'difficultyLevels', (select data from difficulty),\n  'stages', (select data from stages),\n  'items', (select data from items),\n  'actuals', coalesce((select data from actuals), '[]'::jsonb),\n  'totals', coalesce((select data from section_totals), '{}'::jsonb),\n  'sectionMeta', coalesce((select data from section_meta), '{}'::jsonb)\n);\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_detailed_project_stats",
    "arguments": "project_id_param uuid",
    "return_type": "TABLE(project_info jsonb, stages_info jsonb, objects_info jsonb, sections_info jsonb, tasks_info jsonb, loadings_info jsonb, assignments_info jsonb, contracts_info jsonb, decomposition_info jsonb, total_records integer)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.get_detailed_project_stats(project_id_param uuid)\n RETURNS TABLE(project_info jsonb, stages_info jsonb, objects_info jsonb, sections_info jsonb, tasks_info jsonb, loadings_info jsonb, assignments_info jsonb, contracts_info jsonb, decomposition_info jsonb, total_records integer)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  project_data JSONB;\n  stages_data JSONB;\n  objects_data JSONB;\n  sections_data JSONB;\n  tasks_data JSONB;\n  loadings_data JSONB;\n  assignments_data JSONB;\n  contracts_data JSONB;\n  decomposition_data JSONB;\n  total_count INTEGER;\nBEGIN\n  --   \n  SELECT json_build_object(\n    'project_id', p.project_id,\n    'project_name', p.project_name,\n    'project_description', p.project_description,\n    'project_status', p.project_status,\n    'project_created', p.project_created,\n    'project_updated', p.project_updated\n  ) INTO project_data\n  FROM projects p\n  WHERE p.project_id = project_id_param;\n  \n  --   \n  SELECT json_build_object(\n    'count', COUNT(*),\n    'stages', COALESCE(json_agg(json_build_object(\n      'stage_id', s.stage_id,\n      'stage_name', s.stage_name,\n      'stage_description', s.stage_description\n    )), '[]'::json)\n  ) INTO stages_data\n  FROM stages s\n  WHERE s.stage_project_id = project_id_param;\n  \n  --   \n  SELECT json_build_object(\n    'count', COUNT(*),\n    'objects', COALESCE(json_agg(json_build_object(\n      'object_id', o.object_id,\n      'object_name', o.object_name,\n      'object_description', o.object_description\n    )), '[]'::json)\n  ) INTO objects_data\n  FROM objects o\n  WHERE o.object_stage_id IN (\n    SELECT stage_id FROM stages WHERE stage_project_id = project_id_param\n  );\n  \n  --   \n  SELECT json_build_object(\n    'count', COUNT(*),\n    'sections', COALESCE(json_agg(json_build_object(\n      'section_id', s.section_id,\n      'section_name', s.section_name,\n      'section_description', s.section_description\n    )), '[]'::json)\n  ) INTO sections_data\n  FROM sections s\n  WHERE s.section_project_id = project_id_param;\n  \n  --   \n  SELECT json_build_object(\n    'count', COUNT(*),\n    'tasks', COALESCE(json_agg(json_build_object(\n      'task_id', t.task_id,\n      'task_name', t.task_name,\n      'task_description', t.task_description\n    )), '[]'::json)\n  ) INTO tasks_data\n  FROM tasks t\n  WHERE t.task_parent_section IN (\n    SELECT section_id FROM sections WHERE section_project_id = project_id_param\n  );\n  \n  --   \n  SELECT json_build_object(\n    'count', COUNT(*),\n    'loadings', COALESCE(json_agg(json_build_object(\n      'loading_id', l.loading_id,\n      'loading_start', l.loading_start,\n      'loading_finish', l.loading_finish\n    )), '[]'::json)\n  ) INTO loadings_data\n  FROM loadings l\n  WHERE l.loading_section IN (\n    SELECT section_id FROM sections WHERE section_project_id = project_id_param\n  );\n  \n  --   \n  SELECT json_build_object(\n    'count', COUNT(*),\n    'assignments', COALESCE(json_agg(json_build_object(\n      'assignment_id', a.assignment_id,\n      'title', a.title,\n      'status', a.status\n    )), '[]'::json)\n  ) INTO assignments_data\n  FROM assignments a\n  WHERE a.project_id = project_id_param;\n  \n  --   \n  SELECT json_build_object(\n    'count', COUNT(*),\n    'contracts', COALESCE(json_agg(json_build_object(\n      'contract_id', c.contract_id,\n      'contract_number', c.contract_number,\n      'contract_name', c.contract_name\n    )), '[]'::json)\n  ) INTO contracts_data\n  FROM contracts c\n  WHERE c.contract_project_id = project_id_param;\n  \n  --   \n  SELECT json_build_object(\n    'count', COUNT(*),\n    'decomposition_items', COALESCE(json_agg(json_build_object(\n      'decomposition_item_id', di.decomposition_item_id,\n      'description', di.decomposition_item_description,\n      'planned_hours', di.decomposition_item_planned_hours\n    )), '[]'::json)\n  ) INTO decomposition_data\n  FROM decomposition_items di\n  WHERE di.decomposition_item_section_id IN (\n    SELECT section_id FROM sections WHERE section_project_id = project_id_param\n  );\n  \n  --   \n  total_count := COALESCE((stages_data->>'count')::integer, 0) +\n                 COALESCE((objects_data->>'count')::integer, 0) +\n                 COALESCE((sections_data->>'count')::integer, 0) +\n                 COALESCE((tasks_data->>'count')::integer, 0) +\n                 COALESCE((loadings_data->>'count')::integer, 0) +\n                 COALESCE((assignments_data->>'count')::integer, 0) +\n                 COALESCE((contracts_data->>'count')::integer, 0) +\n                 COALESCE((decomposition_data->>'count')::integer, 0);\n  \n  RETURN QUERY SELECT \n    project_data,\n    stages_data,\n    objects_data,\n    sections_data,\n    tasks_data,\n    loadings_data,\n    assignments_data,\n    contracts_data,\n    decomposition_data,\n    total_count;\n    \nEXCEPTION\n  WHEN OTHERS THEN\n    --      \n    RETURN QUERY SELECT \n      '{}'::jsonb,\n      '{}'::jsonb,\n      '{}'::jsonb,\n      '{}'::jsonb,\n      '{}'::jsonb,\n      '{}'::jsonb,\n      '{}'::jsonb,\n      '{}'::jsonb,\n      '{}'::jsonb,\n      0;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_employee_vacations_daily",
    "arguments": "p_start date, p_end date, p_department uuid DEFAULT NULL::uuid, p_team uuid DEFAULT NULL::uuid",
    "return_type": "TABLE(user_id uuid, department_id uuid, team_id uuid, vacation_date date)",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.get_employee_vacations_daily(p_start date, p_end date, p_department uuid DEFAULT NULL::uuid, p_team uuid DEFAULT NULL::uuid)\n RETURNS TABLE(user_id uuid, department_id uuid, team_id uuid, vacation_date date)\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n  SELECT\n    v.user_id,\n    v.department_id,\n    v.team_id,\n    gs::date AS vacation_date\n  FROM public.view_employee_vacations v\n  CROSS JOIN LATERAL generate_series(v.date_start, v.date_end, interval '1 day') AS gs\n  WHERE (gs::date BETWEEN p_start AND p_end)\n    AND (p_department IS NULL OR v.department_id = p_department)\n    AND (p_team IS NULL OR v.team_id = p_team);\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_notification_type_counts",
    "arguments": "p_user_id uuid, p_include_archived boolean DEFAULT false",
    "return_type": "TABLE(type_name text, count bigint)",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.get_notification_type_counts(p_user_id uuid, p_include_archived boolean DEFAULT false)\n RETURNS TABLE(type_name text, count bigint)\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT\n    et.name AS type_name,\n    COUNT(*)::BIGINT AS count\n  FROM user_notifications un\n  INNER JOIN notifications n ON n.id = un.notification_id\n  INNER JOIN entity_types et ON et.id = n.entity_type_id\n  WHERE\n    un.user_id = p_user_id\n    AND (p_include_archived = TRUE OR un.is_archived = FALSE)\n  GROUP BY et.name\n  ORDER BY et.name;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_project_delete_stats",
    "arguments": "project_id_param uuid",
    "return_type": "TABLE(stages_count bigint, objects_count bigint, sections_count bigint, tasks_count bigint, loadings_count bigint, assignments_count bigint, contracts_count bigint, decompositions_count bigint)",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.get_project_delete_stats(project_id_param uuid)\n RETURNS TABLE(stages_count bigint, objects_count bigint, sections_count bigint, tasks_count bigint, loadings_count bigint, assignments_count bigint, contracts_count bigint, decompositions_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\ndeclare\n  v_stages_ids   uuid[] := array[]::uuid[];\n  v_sections_ids uuid[] := array[]::uuid[];\n  v_tmp bigint;\nbegin\n  -- stages\n  select coalesce(array_agg(s.stage_id), array[]::uuid[])\n  into v_stages_ids\n  from public.stages s\n  where s.stage_project_id = project_id_param;\n\n  -- sections\n  select coalesce(array_agg(sec.section_id), array[]::uuid[])\n  into v_sections_ids\n  from public.sections sec\n  where sec.section_project_id = project_id_param;\n\n  -- counts\n  select count(*) into stages_count from public.stages s where s.stage_project_id = project_id_param;\n\n  select count(*) into objects_count\n  from public.objects o\n  where (o.object_project_id = project_id_param)\n     or (cardinality(v_stages_ids) > 0 and o.object_stage_id = any(v_stages_ids));\n\n  select count(*) into sections_count from public.sections sec where sec.section_project_id = project_id_param;\n\n  -- tasks\n  tasks_count := 0;\n  if cardinality(v_sections_ids) > 0 and to_regclass('public.tasks') is not null then\n    execute 'select count(*) from public.tasks where task_parent_section = any($1)'\n      into v_tmp using v_sections_ids;\n    tasks_count := coalesce(v_tmp, 0);\n  end if;\n\n  -- loadings\n  loadings_count := 0;\n  if cardinality(v_sections_ids) > 0 and to_regclass('public.loadings') is not null then\n    execute 'select count(*) from public.loadings where loading_section = any($1)'\n      into v_tmp using v_sections_ids;\n    loadings_count := coalesce(v_tmp, 0);\n  end if;\n\n  -- assignments (     from/to)\n  assignments_count := 0;\n  if to_regclass('public.assignments') is not null then\n    select count(*) into assignments_count\n    from public.assignments a\n    where a.project_id = project_id_param\n       or (cardinality(v_sections_ids) > 0 and (a.from_section_id = any(v_sections_ids) or a.to_section_id = any(v_sections_ids)));\n  end if;\n\n  -- contracts\n  contracts_count := 0;\n  if to_regclass('public.contracts') is not null then\n    select count(*) into contracts_count from public.contracts c where c.contract_project_id = project_id_param;\n  end if;\n\n  -- decomposition_items\n  decompositions_count := 0;\n  if cardinality(v_sections_ids) > 0 and to_regclass('public.decomposition_items') is not null then\n    select count(*) into decompositions_count from public.decomposition_items di where di.decomposition_item_section_id = any(v_sections_ids);\n  end if;\n\n  return next;\nend;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_project_deletion_logs",
    "arguments": "limit_count integer DEFAULT 50, offset_count integer DEFAULT 0, success_filter boolean DEFAULT NULL::boolean",
    "return_type": "TABLE(id uuid, project_id uuid, project_name text, deleted_by uuid, deleted_at timestamp with time zone, deletion_stats jsonb, success boolean, error_message text, deleted_counts jsonb)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.get_project_deletion_logs(limit_count integer DEFAULT 50, offset_count integer DEFAULT 0, success_filter boolean DEFAULT NULL::boolean)\n RETURNS TABLE(id uuid, project_id uuid, project_name text, deleted_by uuid, deleted_at timestamp with time zone, deletion_stats jsonb, success boolean, error_message text, deleted_counts jsonb)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    pdl.id,\n    pdl.project_id,\n    pdl.project_name,\n    pdl.deleted_by,\n    pdl.deleted_at,\n    pdl.deletion_stats,\n    pdl.success,\n    pdl.error_message,\n    pdl.deleted_counts\n  FROM project_deletion_log pdl\n  WHERE (success_filter IS NULL OR pdl.success = success_filter)\n  ORDER BY pdl.deleted_at DESC\n  LIMIT limit_count\n  OFFSET offset_count;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_section_decomposition_totals",
    "arguments": "p_section_id uuid",
    "return_type": "TABLE(planned_hours numeric, actual_hours numeric, actual_amount numeric)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.get_section_decomposition_totals(p_section_id uuid)\n RETURNS TABLE(planned_hours numeric, actual_hours numeric, actual_amount numeric)\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(sum(di.decomposition_item_planned_hours), 0)::numeric(10,2) as planned_hours,\n    coalesce(sum(wl.work_log_hours), 0)::numeric(10,2)            as actual_hours,\n    coalesce(sum(wl.work_log_amount), 0)::numeric(14,2)          as actual_amount\n  from public.decomposition_items di\n  left join public.work_logs wl\n    on wl.decomposition_item_id = di.decomposition_item_id\n  where di.decomposition_item_section_id = p_section_id;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_user_id_by_email",
    "arguments": "email_param text",
    "return_type": "uuid",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.get_user_id_by_email(email_param text)\n RETURNS uuid\n LANGUAGE plpgsql\n SET search_path TO ''\nAS $function$\nDECLARE\n  user_id_var UUID;\nBEGIN\n  SELECT public.profiles.user_id INTO user_id_var\n  FROM public.profiles\n  WHERE public.profiles.email = email_param;\n  \n  RETURN user_id_var;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_user_notifications_filtered",
    "arguments": "p_user_id uuid, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_only_unread boolean DEFAULT false, p_include_archived boolean DEFAULT false, p_types text[] DEFAULT NULL::text[]",
    "return_type": "TABLE(id uuid, notification_id uuid, user_id uuid, is_read boolean, is_archived boolean, created_at timestamp with time zone, updated_at timestamp with time zone, n_entity_type_id uuid, n_payload jsonb, n_rendered_text text, n_created_at timestamp with time zone, n_source_comment_id uuid, entity_type_name character varying, total_count bigint)",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.get_user_notifications_filtered(p_user_id uuid, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_only_unread boolean DEFAULT false, p_include_archived boolean DEFAULT false, p_types text[] DEFAULT NULL::text[])\n RETURNS TABLE(id uuid, notification_id uuid, user_id uuid, is_read boolean, is_archived boolean, created_at timestamp with time zone, updated_at timestamp with time zone, n_entity_type_id uuid, n_payload jsonb, n_rendered_text text, n_created_at timestamp with time zone, n_source_comment_id uuid, entity_type_name character varying, total_count bigint)\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT\n    un.id,\n    un.notification_id,\n    un.user_id,\n    un.is_read,\n    un.is_archived,\n    un.created_at,\n    un.updated_at,\n\n    n.entity_type_id AS n_entity_type_id,\n    n.payload AS n_payload,\n    n.rendered_text AS n_rendered_text,\n    n.created_at AS n_created_at,\n    n.source_comment_id AS n_source_comment_id,\n\n    et.entity_name AS entity_type_name,\n\n    -- Window function  count -  CTE!\n    COUNT(*) OVER() AS total_count\n\n  FROM user_notifications un\n  INNER JOIN notifications n ON n.id = un.notification_id\n  INNER JOIN entity_types et ON et.id = n.entity_type_id\n\n  WHERE un.user_id = p_user_id\n    --   \n    AND (NOT p_only_unread OR un.is_read = FALSE)\n\n    --   \n    AND (p_include_archived OR un.is_archived = FALSE)\n\n    --    (NULL =  )\n    AND (p_types IS NULL OR et.entity_name = ANY(p_types))\n\n  ORDER BY un.created_at DESC\n  LIMIT p_limit\n  OFFSET p_offset;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_user_permissions",
    "arguments": "p_user_id uuid",
    "return_type": "text[]",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.get_user_permissions(p_user_id uuid)\n RETURNS text[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  user_permissions text[];\nBEGIN\n  SELECT ARRAY_AGG(DISTINCT p.name ORDER BY p.name)\n  INTO user_permissions\n  FROM public.user_roles ur\n  JOIN public.role_permissions rp ON ur.role_id = rp.role_id\n  JOIN public.permissions p ON rp.permission_id = p.id\n  WHERE ur.user_id = p_user_id;\n\n  RETURN COALESCE(user_permissions, ARRAY[]::text[]);\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_work_logs_agg_for_items",
    "arguments": "p_item_ids uuid[]",
    "return_type": "TABLE(decomposition_item_id uuid, actual_hours numeric, logs_count bigint, actual_amount numeric)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.get_work_logs_agg_for_items(p_item_ids uuid[])\n RETURNS TABLE(decomposition_item_id uuid, actual_hours numeric, logs_count bigint, actual_amount numeric)\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    wl.decomposition_item_id,\n    coalesce(sum(wl.work_log_hours), 0)::numeric          as actual_hours,\n    count(*)::bigint                                      as logs_count,\n    coalesce(sum(wl.work_log_amount), 0)::numeric         as actual_amount\n  from public.work_logs wl\n  where wl.decomposition_item_id = any(p_item_ids)\n  group by wl.decomposition_item_id;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec",
    "arguments": "halfvec, integer, boolean",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec(halfvec, integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_accum",
    "arguments": "double precision[], halfvec",
    "return_type": "double precision[]",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_accum(double precision[], halfvec)\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_accum$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_add",
    "arguments": "halfvec, halfvec",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_add(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_add$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_avg",
    "arguments": "double precision[]",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_avg(double precision[])\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_avg$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_cmp",
    "arguments": "halfvec, halfvec",
    "return_type": "integer",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_cmp(halfvec, halfvec)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_cmp$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_combine",
    "arguments": "double precision[], double precision[]",
    "return_type": "double precision[]",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_combine(double precision[], double precision[])\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_combine$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_concat",
    "arguments": "halfvec, halfvec",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_concat(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_concat$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_eq",
    "arguments": "halfvec, halfvec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_eq(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_eq$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_ge",
    "arguments": "halfvec, halfvec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_ge(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_ge$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_gt",
    "arguments": "halfvec, halfvec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_gt(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_gt$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_in",
    "arguments": "cstring, oid, integer",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_in(cstring, oid, integer)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_in$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_l2_squared_distance",
    "arguments": "halfvec, halfvec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_l2_squared_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_squared_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_le",
    "arguments": "halfvec, halfvec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_le(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_le$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_lt",
    "arguments": "halfvec, halfvec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_lt(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_lt$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_mul",
    "arguments": "halfvec, halfvec",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_mul(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_mul$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_ne",
    "arguments": "halfvec, halfvec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_ne(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_ne$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_negative_inner_product",
    "arguments": "halfvec, halfvec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_negative_inner_product(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_negative_inner_product$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_out",
    "arguments": "halfvec",
    "return_type": "cstring",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_out(halfvec)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_out$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_recv",
    "arguments": "internal, oid, integer",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_recv(internal, oid, integer)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_recv$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_send",
    "arguments": "halfvec",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_send(halfvec)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_send$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_spherical_distance",
    "arguments": "halfvec, halfvec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_spherical_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_spherical_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_sub",
    "arguments": "halfvec, halfvec",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_sub(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_sub$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_to_float4",
    "arguments": "halfvec, integer, boolean",
    "return_type": "real[]",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_to_float4(halfvec, integer, boolean)\n RETURNS real[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_to_float4$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_to_sparsevec",
    "arguments": "halfvec, integer, boolean",
    "return_type": "sparsevec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_to_sparsevec(halfvec, integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_to_vector",
    "arguments": "halfvec, integer, boolean",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_to_vector(halfvec, integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_to_vector$function$\n"
  },
  {
    "schema": "public",
    "function_name": "halfvec_typmod_in",
    "arguments": "cstring[]",
    "return_type": "integer",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.halfvec_typmod_in(cstring[])\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_typmod_in$function$\n"
  },
  {
    "schema": "public",
    "function_name": "hamming_distance",
    "arguments": "bit, bit",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.hamming_distance(bit, bit)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$hamming_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "has_budget_permission",
    "arguments": "permission_name text",
    "return_type": "boolean",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.has_budget_permission(permission_name text)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 \n    FROM profiles p\n    JOIN role_permissions rp ON rp.role_id = p.role_id\n    JOIN permissions perm ON perm.id = rp.permission_id\n    WHERE p.user_id = auth.uid() \n    AND perm.name = permission_name\n  );\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "hnsw_bit_support",
    "arguments": "internal",
    "return_type": "internal",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.hnsw_bit_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$hnsw_bit_support$function$\n"
  },
  {
    "schema": "public",
    "function_name": "hnsw_halfvec_support",
    "arguments": "internal",
    "return_type": "internal",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.hnsw_halfvec_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$hnsw_halfvec_support$function$\n"
  },
  {
    "schema": "public",
    "function_name": "hnsw_sparsevec_support",
    "arguments": "internal",
    "return_type": "internal",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.hnsw_sparsevec_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$hnsw_sparsevec_support$function$\n"
  },
  {
    "schema": "public",
    "function_name": "hnswhandler",
    "arguments": "internal",
    "return_type": "index_am_handler",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.hnswhandler(internal)\n RETURNS index_am_handler\n LANGUAGE c\nAS '$libdir/vector', $function$hnswhandler$function$\n"
  },
  {
    "schema": "public",
    "function_name": "inner_product",
    "arguments": "sparsevec, sparsevec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.inner_product(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_inner_product$function$\n"
  },
  {
    "schema": "public",
    "function_name": "inner_product",
    "arguments": "vector, vector",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.inner_product(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$inner_product$function$\n"
  },
  {
    "schema": "public",
    "function_name": "inner_product",
    "arguments": "halfvec, halfvec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.inner_product(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_inner_product$function$\n"
  },
  {
    "schema": "public",
    "function_name": "ivfflat_bit_support",
    "arguments": "internal",
    "return_type": "internal",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.ivfflat_bit_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$ivfflat_bit_support$function$\n"
  },
  {
    "schema": "public",
    "function_name": "ivfflat_halfvec_support",
    "arguments": "internal",
    "return_type": "internal",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.ivfflat_halfvec_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$ivfflat_halfvec_support$function$\n"
  },
  {
    "schema": "public",
    "function_name": "ivfflathandler",
    "arguments": "internal",
    "return_type": "index_am_handler",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.ivfflathandler(internal)\n RETURNS index_am_handler\n LANGUAGE c\nAS '$libdir/vector', $function$ivfflathandler$function$\n"
  },
  {
    "schema": "public",
    "function_name": "jaccard_distance",
    "arguments": "bit, bit",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.jaccard_distance(bit, bit)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$jaccard_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "l1_distance",
    "arguments": "halfvec, halfvec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.l1_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l1_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "l1_distance",
    "arguments": "vector, vector",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.l1_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$l1_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "l1_distance",
    "arguments": "sparsevec, sparsevec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.l1_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l1_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "l2_distance",
    "arguments": "sparsevec, sparsevec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.l2_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "l2_distance",
    "arguments": "halfvec, halfvec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.l2_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "l2_distance",
    "arguments": "vector, vector",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.l2_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$l2_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "l2_norm",
    "arguments": "sparsevec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.l2_norm(sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_norm$function$\n"
  },
  {
    "schema": "public",
    "function_name": "l2_norm",
    "arguments": "halfvec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.l2_norm(halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_norm$function$\n"
  },
  {
    "schema": "public",
    "function_name": "l2_normalize",
    "arguments": "halfvec",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.l2_normalize(halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_normalize$function$\n"
  },
  {
    "schema": "public",
    "function_name": "l2_normalize",
    "arguments": "vector",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.l2_normalize(vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$l2_normalize$function$\n"
  },
  {
    "schema": "public",
    "function_name": "l2_normalize",
    "arguments": "sparsevec",
    "return_type": "sparsevec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.l2_normalize(sparsevec)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_normalize$function$\n"
  },
  {
    "schema": "public",
    "function_name": "match_documents",
    "arguments": "query_embedding vector, match_count integer DEFAULT NULL::integer, filter jsonb DEFAULT '{}'::jsonb",
    "return_type": "TABLE(id bigint, content text, metadata jsonb, similarity double precision)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.match_documents(query_embedding vector, match_count integer DEFAULT NULL::integer, filter jsonb DEFAULT '{}'::jsonb)\n RETURNS TABLE(id bigint, content text, metadata jsonb, similarity double precision)\n LANGUAGE plpgsql\nAS $function$\r\n#variable_conflict use_column\r\nbegin\r\n  return query\r\n  select\r\n    id,\r\n    content,\r\n    metadata,\r\n    1 - (documents.embedding <=> query_embedding) as similarity\r\n  from documents\r\n  where metadata @> filter\r\n  order by documents.embedding <=> query_embedding\r\n  limit match_count;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "match_vect_documents",
    "arguments": "query_embedding vector, match_count integer DEFAULT NULL::integer, filter jsonb DEFAULT '{}'::jsonb",
    "return_type": "TABLE(id bigint, content text, metadata jsonb, similarity double precision)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.match_vect_documents(query_embedding vector, match_count integer DEFAULT NULL::integer, filter jsonb DEFAULT '{}'::jsonb)\n RETURNS TABLE(id bigint, content text, metadata jsonb, similarity double precision)\n LANGUAGE plpgsql\nAS $function$\r\n#variable_conflict use_column\r\nbegin\r\n  return query\r\n  select\r\n    id,\r\n    content,\r\n    metadata,\r\n    1 - (documents.embedding <=> query_embedding) as similarity\r\n  from documents\r\n  where metadata @> filter\r\n  order by documents.embedding <=> query_embedding\r\n  limit match_count;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "notify_python_agent",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.notify_python_agent()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  webhook_url text := 'https://ai-bot.eneca.work/webhook';\r\nBEGIN\r\n  --  net.http_post  pg_net extension\r\n  PERFORM net.http_post(\r\n    url := webhook_url,\r\n    headers := '{\"Content-Type\": \"application/json\"}'::jsonb,\r\n    body := jsonb_build_object(\r\n      'message_id', NEW.id,\r\n      'conversation_id', NEW.conversation_id,\r\n      'user_id', NEW.user_id,\r\n      'content', NEW.content,\r\n      'created_at', NEW.created_at\r\n    )\r\n  );\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "prevent_delete_last_department",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.prevent_delete_last_department()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  dept_count INTEGER;\r\n  subdiv_exists BOOLEAN;\r\nBEGIN\r\n  --    subdivision_id = NULL\r\n  IF OLD.subdivision_id IS NULL THEN\r\n    RETURN OLD;\r\n  END IF;\r\n  \r\n  -- ,    \r\n  SELECT EXISTS(\r\n    SELECT 1 FROM subdivisions WHERE subdivision_id = OLD.subdivision_id\r\n  ) INTO subdiv_exists;\r\n  \r\n  --      ,   \r\n  IF NOT subdiv_exists THEN\r\n    RETURN OLD;\r\n  END IF;\r\n  \r\n  --     \r\n  SELECT COUNT(*) INTO dept_count\r\n  FROM departments\r\n  WHERE subdivision_id = OLD.subdivision_id;\r\n  \r\n  --        ,  \r\n  IF dept_count = 1 THEN\r\n    RAISE EXCEPTION '     .      .';\r\n  END IF;\r\n  \r\n  RETURN OLD;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "prevent_delete_last_team",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.prevent_delete_last_team()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  team_count INTEGER;\r\n  dept_exists BOOLEAN;\r\nBEGIN\r\n  -- ,    \r\n  --   ,    -  \r\n  SELECT EXISTS(\r\n    SELECT 1 FROM departments WHERE department_id = OLD.department_id\r\n  ) INTO dept_exists;\r\n  \r\n  --      ,   \r\n  IF NOT dept_exists THEN\r\n    RETURN OLD;\r\n  END IF;\r\n  \r\n  --     \r\n  SELECT COUNT(*) INTO team_count\r\n  FROM teams\r\n  WHERE department_id = OLD.department_id;\r\n  \r\n  --        ,  \r\n  IF team_count = 1 THEN\r\n    RAISE EXCEPTION '     .      .';\r\n  END IF;\r\n  \r\n  RETURN OLD;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "prevent_sections_duplicates",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.prevent_sections_duplicates()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n  if new.external_id is not null then\n    if exists (\n      select 1\n      from public.sections s\n      where s.section_project_id = new.section_project_id\n        and s.external_source is not distinct from new.external_source\n        and s.external_id = new.external_id\n        and s.section_id <> new.section_id\n    ) then\n      raise exception using\n        errcode = '23505',\n        message = format('Duplicate section by (project, source, external_id): (%s, %s, %s)', new.section_project_id::text, coalesce(new.external_source, 'NULL'), new.external_id);\n    end if;\n  end if;\n  return new;\nend;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "propagate_auth_email_to_profile",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.propagate_auth_email_to_profile()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  --  email    \n  update public.profiles\n  set email = new.email\n  where user_id = new.id;\n\n  return null; -- AFTER ROW trigger   null\nend;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "refresh_user_permissions_cache",
    "arguments": "",
    "return_type": "void",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.refresh_user_permissions_cache()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_user_permissions;\n  RAISE NOTICE '   ';\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "refresh_user_permissions_for_user",
    "arguments": "p_user_id uuid",
    "return_type": "void",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.refresh_user_permissions_for_user(p_user_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nbegin\r\n  insert into public.user_permissions_cache as upc (user_id, permissions, updated_at)\r\n  values (\r\n    p_user_id,\r\n    public.compute_user_permissions(p_user_id),\r\n    now()\r\n  )\r\n  on conflict (user_id) do update\r\n    set permissions = excluded.permissions,\r\n        updated_at = excluded.updated_at;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "refresh_user_permissions_for_users",
    "arguments": "p_user_ids uuid[]",
    "return_type": "void",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.refresh_user_permissions_for_users(p_user_ids uuid[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nbegin\r\n  insert into public.user_permissions_cache as upc (user_id, permissions, updated_at)\r\n  select u, public.compute_user_permissions(u), now()\r\n  from unnest(p_user_ids) as u\r\n  on conflict (user_id) do update\r\n    set permissions = excluded.permissions,\r\n        updated_at = excluded.updated_at;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "restore_loading_from_archive",
    "arguments": "loading_uuid uuid",
    "return_type": "TABLE(success boolean, message text)",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.restore_loading_from_archive(loading_uuid uuid)\n RETURNS TABLE(success boolean, message text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    loading_exists BOOLEAN;\nBEGIN\n    --   \n    SELECT EXISTS(\n        SELECT 1 FROM loadings \n        WHERE loading_id = loading_uuid\n    ) INTO loading_exists;\n    \n    IF NOT loading_exists THEN\n        RETURN QUERY SELECT FALSE, '  ID ' || loading_uuid || '  ';\n        RETURN;\n    END IF;\n    \n    --  \n    UPDATE loadings \n    SET \n        loading_status = 'active',\n        loading_updated = NOW()\n    WHERE loading_id = loading_uuid\n    AND loading_status = 'archived';\n    \n    IF FOUND THEN\n        RETURN QUERY SELECT TRUE, '    ';\n    ELSE\n        RETURN QUERY SELECT FALSE, '       ';\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "safe_delete_project",
    "arguments": "project_id_param uuid",
    "return_type": "TABLE(success boolean, message text, deleted_counts jsonb)",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.safe_delete_project(project_id_param uuid)\n RETURNS TABLE(success boolean, message text, deleted_counts jsonb)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\ndeclare\n  v_deleted jsonb := '{}'::jsonb;\n  v_cnt bigint := 0;\n\n  v_stages_ids      uuid[] := array[]::uuid[];\n  v_objects_ids     uuid[] := array[]::uuid[];\n  v_sections_ids    uuid[] := array[]::uuid[];\n  v_decomp_ids      uuid[] := array[]::uuid[];\n  v_assignment_ids  uuid[] := array[]::uuid[];\nbegin\n  --  ID  \n  select coalesce(array_agg(s.stage_id), array[]::uuid[])\n  into v_stages_ids\n  from public.stages s\n  where s.stage_project_id = project_id_param;\n\n  select coalesce(array_agg(o.object_id), array[]::uuid[])\n  into v_objects_ids\n  from public.objects o\n  where (o.object_project_id = project_id_param)\n     or (cardinality(v_stages_ids) > 0 and o.object_stage_id = any(v_stages_ids));\n\n  select coalesce(array_agg(sec.section_id), array[]::uuid[])\n  into v_sections_ids\n  from public.sections sec\n  where sec.section_project_id = project_id_param;\n\n  --   \n  if to_regclass('public.section_comments') is not null and cardinality(v_sections_ids) > 0 then\n    delete from public.section_comments sc where sc.section_id = any(v_sections_ids);\n    get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('section_comments', coalesce(v_cnt,0));\n  end if;\n\n  --  \n  if to_regclass('public.plan_loadings') is not null and cardinality(v_sections_ids) > 0 then\n    delete from public.plan_loadings pl where pl.plan_loading_section = any(v_sections_ids);\n    get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('plan_loadings', coalesce(v_cnt,0));\n  end if;\n\n  --  \n  if to_regclass('public.loadings') is not null and cardinality(v_sections_ids) > 0 then\n    delete from public.loadings l where l.loading_section = any(v_sections_ids);\n    get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('loadings', coalesce(v_cnt,0));\n  end if;\n\n  -- Assignments ( ->  ).       \n  if to_regclass('public.assignments') is not null then\n    select coalesce(array_agg(a.assignment_id), array[]::uuid[])\n    into v_assignment_ids\n    from public.assignments a\n    where a.project_id = project_id_param\n       or (cardinality(v_sections_ids) > 0 and (a.from_section_id = any(v_sections_ids) or a.to_section_id = any(v_sections_ids)));\n\n    if to_regclass('public.assignment_audit') is not null and cardinality(v_assignment_ids) > 0 then\n      delete from public.assignment_audit aa where aa.assignment_id = any(v_assignment_ids);\n      get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('assignment_audit', coalesce(v_cnt,0));\n    end if;\n\n    if cardinality(v_assignment_ids) > 0 then\n      delete from public.assignments a where a.assignment_id = any(v_assignment_ids);\n      get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('assignments', coalesce(v_cnt,0));\n    end if;\n  end if;\n\n  --  ( )\n  if to_regclass('public.tasks') is not null and cardinality(v_sections_ids) > 0 then\n    delete from public.tasks t where t.task_parent_section = any(v_sections_ids);\n    get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('tasks', coalesce(v_cnt,0));\n  end if;\n\n  -- Work logs -> Decomposition items ( ,   )\n  if to_regclass('public.decomposition_items') is not null and cardinality(v_sections_ids) > 0 then\n    select coalesce(array_agg(di.decomposition_item_id), array[]::uuid[])\n    into v_decomp_ids\n    from public.decomposition_items di\n    where di.decomposition_item_section_id = any(v_sections_ids);\n\n    if to_regclass('public.work_logs') is not null and cardinality(v_decomp_ids) > 0 then\n      delete from public.work_logs wl where wl.decomposition_item_id = any(v_decomp_ids);\n      get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('work_logs', coalesce(v_cnt,0));\n    end if;\n\n    if cardinality(v_decomp_ids) > 0 then\n      delete from public.decomposition_items di where di.decomposition_item_id = any(v_decomp_ids);\n      get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('decomposition_items', coalesce(v_cnt,0));\n    end if;\n  end if;\n\n  -- Sections\n  if cardinality(v_sections_ids) > 0 then\n    delete from public.sections sec where sec.section_id = any(v_sections_ids);\n    get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('sections', coalesce(v_cnt,0));\n  end if;\n\n  -- Objects\n  if cardinality(v_objects_ids) > 0 then\n    delete from public.objects o where o.object_id = any(v_objects_ids);\n    get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('objects', coalesce(v_cnt,0));\n  end if;\n\n  -- Stages\n  if cardinality(v_stages_ids) > 0 then\n    delete from public.stages s where s.stage_id = any(v_stages_ids);\n    get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('stages', coalesce(v_cnt,0));\n  end if;\n\n  -- Contracts\n  if to_regclass('public.contracts') is not null then\n    delete from public.contracts c where c.contract_project_id = project_id_param;\n    get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('contracts', coalesce(v_cnt,0));\n  end if;\n\n  --   \n  delete from public.projects p where p.project_id = project_id_param;\n  get diagnostics v_cnt = row_count; v_deleted := v_deleted || jsonb_build_object('projects', coalesce(v_cnt,0));\n\n  return query select true, '     '::text, v_deleted;\nexception when others then\n  return query select false, ('   : ' || sqlerrm)::text, v_deleted;\nend;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "safe_fix_entire_organizational_system",
    "arguments": "",
    "return_type": "TABLE(step text, details text, records_affected integer, success boolean)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.safe_fix_entire_organizational_system()\n RETURNS TABLE(step text, details text, records_affected integer, success boolean)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  violations_count INTEGER;\n  heads_assigned INTEGER;\n  leads_assigned INTEGER;\nBEGIN\n  --  1:    ()\n  SELECT COUNT(*) INTO violations_count\n  FROM view_integrity_violations\n  WHERE violation_type = 'employee_wrong_department';\n  \n  --  \n  PERFORM safe_fix_integrity_violations();\n  \n  RETURN QUERY SELECT\n    '  '::TEXT,\n    ' ' || violations_count || ' '::TEXT,\n    violations_count,\n    TRUE;\n  \n  --  2:   \n  SELECT COUNT(*) INTO heads_assigned\n  FROM assign_department_heads_from_positions();\n  \n  RETURN QUERY SELECT\n    '  '::TEXT,\n    ' ' || heads_assigned || ' '::TEXT,\n    heads_assigned,\n    TRUE;\n  \n  --  3:   \n  SELECT COUNT(*) INTO leads_assigned\n  FROM assign_team_leads_from_positions();\n  \n  RETURN QUERY SELECT\n    '  '::TEXT,\n    ' ' || leads_assigned || ' '::TEXT,\n    leads_assigned,\n    TRUE;\n  \n  --  4:   \n  REFRESH MATERIALIZED VIEW mv_user_permissions;\n  \n  RETURN QUERY SELECT\n    '  '::TEXT,\n    '  '::TEXT,\n    1,\n    TRUE;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "safe_fix_integrity_violations",
    "arguments": "",
    "return_type": "TABLE(user_id uuid, user_name text, old_team_id uuid, new_team_id uuid, old_department_id uuid, new_department_id uuid, action text, success boolean)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.safe_fix_integrity_violations()\n RETURNS TABLE(user_id uuid, user_name text, old_team_id uuid, new_team_id uuid, old_department_id uuid, new_department_id uuid, action text, success boolean)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  violation_record RECORD;\n  correct_team_id UUID;\n  correct_department_id UUID;\n  team_record RECORD;\n  no_team_id UUID;\nBEGIN\n  --     \n  ALTER TABLE profiles DISABLE TRIGGER trigger_check_profiles_integrity;\n  ALTER TABLE profiles DISABLE TRIGGER trigger_sync_department_from_team;\n  \n  --    \n  FOR violation_record IN \n    SELECT \n      v.user_id,\n      v.details,\n      p.team_id as current_team_id,\n      p.department_id as current_department_id\n    FROM view_integrity_violations v\n    JOIN profiles p ON v.user_id = p.user_id\n    WHERE v.violation_type = 'employee_wrong_department'\n  LOOP\n    --      \n    SELECT \n      t.team_id,\n      t.department_id\n    INTO team_record\n    FROM teams t\n    WHERE t.department_id = violation_record.current_department_id\n      AND t.team_name != ' '\n    ORDER BY t.team_name\n    LIMIT 1;\n    \n    --   ,  \n    IF team_record.team_id IS NOT NULL THEN\n      correct_team_id := team_record.team_id;\n      correct_department_id := team_record.department_id;\n      \n      --  \n      UPDATE profiles \n      SET \n        team_id = correct_team_id,\n        department_id = correct_department_id\n      WHERE profiles.user_id = violation_record.user_id;\n      \n      --  \n      RETURN QUERY SELECT\n        violation_record.user_id,\n        violation_record.details::TEXT,\n        violation_record.current_team_id,\n        correct_team_id,\n        violation_record.current_department_id,\n        correct_department_id,\n        '   '::TEXT,\n        TRUE;\n    ELSE\n      --   ,   \" \"  \n      SELECT team_id INTO no_team_id\n      FROM teams \n      WHERE department_id = violation_record.current_department_id \n        AND team_name = ' ';\n      \n      --   \" \" ,  \n      IF no_team_id IS NULL THEN\n        INSERT INTO teams (team_name, department_id, team_lead_id)\n        VALUES (' ', violation_record.current_department_id, NULL)\n        RETURNING team_id INTO no_team_id;\n      END IF;\n      \n      --    \" \"\n      UPDATE profiles \n      SET team_id = no_team_id\n      WHERE profiles.user_id = violation_record.user_id;\n      \n      RETURN QUERY SELECT\n        violation_record.user_id,\n        violation_record.details::TEXT,\n        violation_record.current_team_id,\n        no_team_id,\n        violation_record.current_department_id,\n        violation_record.current_department_id,\n        '   \" \"'::TEXT,\n        TRUE;\n    END IF;\n  END LOOP;\n  \n  --   \n  ALTER TABLE profiles ENABLE TRIGGER trigger_check_profiles_integrity;\n  ALTER TABLE profiles ENABLE TRIGGER trigger_sync_department_from_team;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "set_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.set_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "set_updated_at_timestamp",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.set_updated_at_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n  new.decomposition_template_updated_at = timezone('utc'::text, now());\n  return new;\nend;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec",
    "arguments": "sparsevec, integer, boolean",
    "return_type": "sparsevec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec(sparsevec, integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_cmp",
    "arguments": "sparsevec, sparsevec",
    "return_type": "integer",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_cmp(sparsevec, sparsevec)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_cmp$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_eq",
    "arguments": "sparsevec, sparsevec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_eq(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_eq$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_ge",
    "arguments": "sparsevec, sparsevec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_ge(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_ge$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_gt",
    "arguments": "sparsevec, sparsevec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_gt(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_gt$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_in",
    "arguments": "cstring, oid, integer",
    "return_type": "sparsevec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_in(cstring, oid, integer)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_in$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_l2_squared_distance",
    "arguments": "sparsevec, sparsevec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_l2_squared_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_squared_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_le",
    "arguments": "sparsevec, sparsevec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_le(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_le$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_lt",
    "arguments": "sparsevec, sparsevec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_lt(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_lt$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_ne",
    "arguments": "sparsevec, sparsevec",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_ne(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_ne$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_negative_inner_product",
    "arguments": "sparsevec, sparsevec",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_negative_inner_product(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_negative_inner_product$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_out",
    "arguments": "sparsevec",
    "return_type": "cstring",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_out(sparsevec)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_out$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_recv",
    "arguments": "internal, oid, integer",
    "return_type": "sparsevec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_recv(internal, oid, integer)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_recv$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_send",
    "arguments": "sparsevec",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_send(sparsevec)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_send$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_to_halfvec",
    "arguments": "sparsevec, integer, boolean",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_to_halfvec(sparsevec, integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_to_vector",
    "arguments": "sparsevec, integer, boolean",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_to_vector(sparsevec, integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_to_vector$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sparsevec_typmod_in",
    "arguments": "cstring[]",
    "return_type": "integer",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sparsevec_typmod_in(cstring[])\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_typmod_in$function$\n"
  },
  {
    "schema": "public",
    "function_name": "subvector",
    "arguments": "vector, integer, integer",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.subvector(vector, integer, integer)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$subvector$function$\n"
  },
  {
    "schema": "public",
    "function_name": "subvector",
    "arguments": "halfvec, integer, integer",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.subvector(halfvec, integer, integer)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_subvector$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sync_all_data",
    "arguments": "",
    "return_type": "void",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sync_all_data()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    --      ( ,  ,  )\n    PERFORM public.sync_all_ws_projects();\n    PERFORM public.sync_all_ws_tasks();\n    PERFORM public.sync_all_ws_subtasks();\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sync_employee_subdivision",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sync_employee_subdivision()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF (TG_OP = 'UPDATE' AND OLD.subdivision_id IS DISTINCT FROM NEW.subdivision_id) THEN\r\n        UPDATE public.profiles\r\n        SET subdivision_id = NEW.subdivision_id\r\n        WHERE department_id = NEW.department_id;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sync_employee_subdivision_on_assignment",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sync_employee_subdivision_on_assignment()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF (NEW.department_id IS NOT NULL) THEN\r\n        SELECT subdivision_id INTO NEW.subdivision_id\r\n        FROM public.departments\r\n        WHERE department_id = NEW.department_id;\r\n    ELSE\r\n        NEW.subdivision_id = NULL;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sync_profile_email_from_auth",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.sync_profile_email_from_auth()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  --       auth.users,   email \n  select u.email into new.email\n  from auth.users u\n  where u.id = new.user_id;\n\n  return new;\nend;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "transfer_employee_to_team",
    "arguments": "p_user_id uuid, p_new_team_id uuid",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.transfer_employee_to_team(p_user_id uuid, p_new_team_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  new_dept_id UUID;\n  old_team_id UUID;\nBEGIN\n  --    \n  SELECT department_id INTO new_dept_id FROM teams WHERE team_id = p_new_team_id;\n  \n  IF new_dept_id IS NULL THEN\n    RAISE EXCEPTION '  : %', p_new_team_id;\n  END IF;\n  \n  --    \n  SELECT team_id INTO old_team_id FROM profiles WHERE user_id = p_user_id;\n  \n  --   (department_id    )\n  UPDATE profiles \n  SET team_id = p_new_team_id\n  WHERE user_id = p_user_id;\n  \n  RAISE NOTICE ' %    %   % ( %)', \n    p_user_id, old_team_id, p_new_team_id, new_dept_id;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "trg_permissions_rename_refresh",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.trg_permissions_rename_refresh()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  v_perm uuid := coalesce(new.id, old.id);\r\nbegin\r\n  if tg_op = 'UPDATE' and new.name is distinct from old.name then\r\n    perform public.refresh_user_permissions_for_users(\r\n      array(\r\n        select distinct ur.user_id\r\n        from public.role_permissions rp\r\n        join public.user_roles ur on ur.role_id = rp.role_id\r\n        where rp.permission_id = v_perm\r\n      )\r\n    );\r\n  end if;\r\n  return null;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "trg_role_permissions_cache_refresh",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.trg_role_permissions_cache_refresh()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  v_role uuid := coalesce(new.role_id, old.role_id);\r\nbegin\r\n  --  ,    \r\n  perform public.refresh_user_permissions_for_users(\r\n    array(\r\n      select ur.user_id\r\n      from public.user_roles ur\r\n      where ur.role_id = v_role\r\n    )\r\n  );\r\n  return null;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "trg_user_roles_cache_refresh",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.trg_user_roles_cache_refresh()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  v_user uuid;\r\nbegin\r\n  --  insert/update  NEW.user_id,  delete  OLD.user_id\r\n  v_user := coalesce(new.user_id, old.user_id);\r\n  perform public.refresh_user_permissions_for_user(v_user);\r\n  return null;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "trigger_refresh_user_permissions",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.trigger_refresh_user_permissions()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  --    (  )\n  PERFORM pg_notify('refresh_permissions_cache', 'true');\n  RETURN COALESCE(NEW, OLD);\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_budgets_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.update_budgets_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_loadings_loading_updated",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.update_loadings_loading_updated()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.loading_updated = now();\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_loadings_updated_at",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.update_loadings_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_role_permissions",
    "arguments": "inserts jsonb DEFAULT '[]'::jsonb, deletes jsonb DEFAULT '[]'::jsonb",
    "return_type": "jsonb",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION public.update_role_permissions(inserts jsonb DEFAULT '[]'::jsonb, deletes jsonb DEFAULT '[]'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  insert_record JSONB;\n  delete_record JSONB;\n  result JSONB := '{\"success\": true, \"inserted\": 0, \"deleted\": 0}'::JSONB;\n  inserted_count INTEGER := 0;\n  deleted_count INTEGER := 0;\nBEGIN\n  --   (    )\n  \n  --  \n  FOR delete_record IN SELECT * FROM jsonb_array_elements(deletes)\n  LOOP\n    DELETE FROM role_permissions \n    WHERE role_id = (delete_record->>'role_id')::UUID \n      AND permission_id = (delete_record->>'permission_id')::UUID;\n    \n    --    \n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\n    result := jsonb_set(result, '{deleted}', (COALESCE((result->>'deleted')::INTEGER, 0) + deleted_count)::TEXT::JSONB);\n  END LOOP;\n  \n  --  \n  FOR insert_record IN SELECT * FROM jsonb_array_elements(inserts)\n  LOOP\n    -- ,     \n    IF NOT EXISTS (\n      SELECT 1 FROM role_permissions \n      WHERE role_id = (insert_record->>'role_id')::UUID \n        AND permission_id = (insert_record->>'permission_id')::UUID\n    ) THEN\n      INSERT INTO role_permissions (role_id, permission_id, created_at)\n      VALUES (\n        (insert_record->>'role_id')::UUID,\n        (insert_record->>'permission_id')::UUID,\n        NOW()\n      );\n      \n      inserted_count := inserted_count + 1;\n    END IF;\n  END LOOP;\n  \n  --  \n  result := jsonb_set(result, '{inserted}', inserted_count::TEXT::JSONB);\n  \n  RETURN result;\n  \nEXCEPTION\n  WHEN OTHERS THEN\n    --       \n    RETURN jsonb_build_object(\n      'success', false,\n      'error', SQLERRM,\n      'error_code', SQLSTATE\n    );\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_sections_field_timestamps",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.update_sections_field_timestamps()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF OLD.section_responsible IS DISTINCT FROM NEW.section_responsible THEN\n        NEW.last_responsible_updated := NOW();\n    END IF;\n\n    IF OLD.section_status_id IS DISTINCT FROM NEW.section_status_id THEN\n        NEW.last_status_updated := NOW();\n    END IF;\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_updated_at_column",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "user_has_permission",
    "arguments": "p_user_id uuid, p_permission_name text",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.user_has_permission(p_user_id uuid, p_permission_name text)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN EXISTS(\n    SELECT 1\n    FROM user_roles ur\n    JOIN role_permissions rp ON ur.role_id = rp.role_id\n    JOIN permissions p ON rp.permission_id = p.id\n    WHERE ur.user_id = p_user_id AND p.name = p_permission_name\n  );\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector",
    "arguments": "vector, integer, boolean",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector(vector, integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_accum",
    "arguments": "double precision[], vector",
    "return_type": "double precision[]",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_accum(double precision[], vector)\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_accum$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_add",
    "arguments": "vector, vector",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_add(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_add$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_avg",
    "arguments": "double precision[]",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_avg(double precision[])\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_avg$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_cmp",
    "arguments": "vector, vector",
    "return_type": "integer",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_cmp(vector, vector)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_cmp$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_combine",
    "arguments": "double precision[], double precision[]",
    "return_type": "double precision[]",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_combine(double precision[], double precision[])\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_combine$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_concat",
    "arguments": "vector, vector",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_concat(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_concat$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_dims",
    "arguments": "vector",
    "return_type": "integer",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_dims(vector)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_dims$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_dims",
    "arguments": "halfvec",
    "return_type": "integer",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_dims(halfvec)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_vector_dims$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_eq",
    "arguments": "vector, vector",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_eq(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_eq$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_ge",
    "arguments": "vector, vector",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_ge(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_ge$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_gt",
    "arguments": "vector, vector",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_gt(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_gt$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_in",
    "arguments": "cstring, oid, integer",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_in(cstring, oid, integer)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_in$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_l2_squared_distance",
    "arguments": "vector, vector",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_l2_squared_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_l2_squared_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_le",
    "arguments": "vector, vector",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_le(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_le$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_lt",
    "arguments": "vector, vector",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_lt(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_lt$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_mul",
    "arguments": "vector, vector",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_mul(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_mul$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_ne",
    "arguments": "vector, vector",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_ne(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_ne$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_negative_inner_product",
    "arguments": "vector, vector",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_negative_inner_product(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_negative_inner_product$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_norm",
    "arguments": "vector",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_norm(vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_norm$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_out",
    "arguments": "vector",
    "return_type": "cstring",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_out(vector)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_out$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_recv",
    "arguments": "internal, oid, integer",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_recv(internal, oid, integer)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_recv$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_send",
    "arguments": "vector",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_send(vector)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_send$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_spherical_distance",
    "arguments": "vector, vector",
    "return_type": "double precision",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_spherical_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_spherical_distance$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_sub",
    "arguments": "vector, vector",
    "return_type": "vector",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_sub(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_sub$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_to_float4",
    "arguments": "vector, integer, boolean",
    "return_type": "real[]",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_to_float4(vector, integer, boolean)\n RETURNS real[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_to_float4$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_to_halfvec",
    "arguments": "vector, integer, boolean",
    "return_type": "halfvec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_to_halfvec(vector, integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_to_sparsevec",
    "arguments": "vector, integer, boolean",
    "return_type": "sparsevec",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_to_sparsevec(vector, integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "function_name": "vector_typmod_in",
    "arguments": "cstring[]",
    "return_type": "integer",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.vector_typmod_in(cstring[])\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_typmod_in$function$\n"
  },
  {
    "schema": "public",
    "function_name": "verify_project_deleted",
    "arguments": "project_id_param uuid",
    "return_type": "TABLE(project_exists boolean, remaining_dependencies jsonb)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION public.verify_project_deleted(project_id_param uuid)\n RETURNS TABLE(project_exists boolean, remaining_dependencies jsonb)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  project_count INTEGER;\n  dependencies JSONB;\nBEGIN\n  --    \n  SELECT COUNT(*) INTO project_count \n  FROM projects \n  WHERE project_id = project_id_param;\n  \n  --      \n  SELECT json_build_object(\n    'stages', (SELECT COUNT(*) FROM stages WHERE stage_project_id = project_id_param),\n    'objects', (SELECT COUNT(*) FROM objects WHERE object_stage_id IN (\n      SELECT stage_id FROM stages WHERE stage_project_id = project_id_param\n    )),\n    'sections', (SELECT COUNT(*) FROM sections WHERE section_project_id = project_id_param),\n    'tasks', (SELECT COUNT(*) FROM tasks WHERE task_parent_section IN (\n      SELECT section_id FROM sections WHERE section_project_id = project_id_param\n    )),\n    'loadings', (SELECT COUNT(*) FROM loadings WHERE loading_section IN (\n      SELECT section_id FROM sections WHERE section_project_id = project_id_param\n    )),\n    'assignments', (SELECT COUNT(*) FROM assignments WHERE project_id = project_id_param),\n    'contracts', (SELECT COUNT(*) FROM contracts WHERE contract_project_id = project_id_param),\n    'decomposition_items', (SELECT COUNT(*) FROM decomposition_items WHERE decomposition_item_section_id IN (\n      SELECT section_id FROM sections WHERE section_project_id = project_id_param\n    ))\n  ) INTO dependencies;\n  \n  RETURN QUERY SELECT \n    (project_count > 0) as project_exists,\n    dependencies as remaining_dependencies;\nEND;\n$function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "apply_rls",
    "arguments": "wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024)",
    "return_type": "SETOF realtime.wal_rls",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))\n RETURNS SETOF realtime.wal_rls\n LANGUAGE plpgsql\nAS $function$\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n$function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "broadcast_changes",
    "arguments": "topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text",
    "return_type": "void",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n$function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "build_prepared_statement_sql",
    "arguments": "prepared_statement_name text, entity regclass, columns realtime.wal_column[]",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])\n RETURNS text\n LANGUAGE sql\nAS $function$\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "cast",
    "arguments": "val text, type_ regtype",
    "return_type": "jsonb",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.\"cast\"(val text, type_ regtype)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "check_equality_op",
    "arguments": "op realtime.equality_op, type_ regtype, val_1 text, val_2 text",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "is_visible_through_filters",
    "arguments": "columns realtime.wal_column[], filters realtime.user_defined_filter[]",
    "return_type": "boolean",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "list_changes",
    "arguments": "publication name, slot_name name, max_changes integer, max_record_bytes integer",
    "return_type": "SETOF realtime.wal_rls",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)\n RETURNS SETOF realtime.wal_rls\n LANGUAGE sql\n SET log_min_messages TO 'fatal'\nAS $function$\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "quote_wal2json",
    "arguments": "entity regclass",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "send",
    "arguments": "payload jsonb, event text, topic text, private boolean DEFAULT true",
    "return_type": "void",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  generated_id uuid;\n  final_payload jsonb;\nBEGIN\n  BEGIN\n    -- Generate a new UUID for the id\n    generated_id := gen_random_uuid();\n\n    -- Check if payload has an 'id' key, if not, add the generated UUID\n    IF payload ? 'id' THEN\n      final_payload := payload;\n    ELSE\n      final_payload := jsonb_set(payload, '{id}', to_jsonb(generated_id));\n    END IF;\n\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (id, payload, event, topic, private, extension)\n    VALUES (generated_id, final_payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;\n  END;\nEND;\n$function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "subscription_check_filters",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "to_regrole",
    "arguments": "role_name text",
    "return_type": "regrole",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)\n RETURNS regrole\n LANGUAGE sql\n IMMUTABLE\nAS $function$ select role_name::regrole $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "topic",
    "arguments": "",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION realtime.topic()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect nullif(current_setting('realtime.topic', true), '')::text;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "add_prefixes",
    "arguments": "_bucket_id text, _name text",
    "return_type": "void",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.add_prefixes(_bucket_id text, _name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    prefixes text[];\nBEGIN\n    prefixes := \"storage\".\"get_prefixes\"(\"_name\");\n\n    IF array_length(prefixes, 1) > 0 THEN\n        INSERT INTO storage.prefixes (name, bucket_id)\n        SELECT UNNEST(prefixes) as name, \"_bucket_id\" ON CONFLICT DO NOTHING;\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "can_insert_object",
    "arguments": "bucketid text, name text, owner uuid, metadata jsonb",
    "return_type": "void",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "delete_leaf_prefixes",
    "arguments": "bucket_ids text[], names text[]",
    "return_type": "void",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_rows_deleted integer;\nBEGIN\n    LOOP\n        WITH candidates AS (\n            SELECT DISTINCT\n                t.bucket_id,\n                unnest(storage.get_prefixes(t.name)) AS name\n            FROM unnest(bucket_ids, names) AS t(bucket_id, name)\n        ),\n        uniq AS (\n             SELECT\n                 bucket_id,\n                 name,\n                 storage.get_level(name) AS level\n             FROM candidates\n             WHERE name <> ''\n             GROUP BY bucket_id, name\n        ),\n        leaf AS (\n             SELECT\n                 p.bucket_id,\n                 p.name,\n                 p.level\n             FROM storage.prefixes AS p\n                  JOIN uniq AS u\n                       ON u.bucket_id = p.bucket_id\n                           AND u.name = p.name\n                           AND u.level = p.level\n             WHERE NOT EXISTS (\n                 SELECT 1\n                 FROM storage.objects AS o\n                 WHERE o.bucket_id = p.bucket_id\n                   AND o.level = p.level + 1\n                   AND o.name COLLATE \"C\" LIKE p.name || '/%'\n             )\n             AND NOT EXISTS (\n                 SELECT 1\n                 FROM storage.prefixes AS c\n                 WHERE c.bucket_id = p.bucket_id\n                   AND c.level = p.level + 1\n                   AND c.name COLLATE \"C\" LIKE p.name || '/%'\n             )\n        )\n        DELETE\n        FROM storage.prefixes AS p\n            USING leaf AS l\n        WHERE p.bucket_id = l.bucket_id\n          AND p.name = l.name\n          AND p.level = l.level;\n\n        GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;\n        EXIT WHEN v_rows_deleted = 0;\n    END LOOP;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "delete_prefix",
    "arguments": "_bucket_id text, _name text",
    "return_type": "boolean",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.delete_prefix(_bucket_id text, _name text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if we can delete the prefix\n    IF EXISTS(\n        SELECT FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"prefixes\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    )\n    OR EXISTS(\n        SELECT FROM \"storage\".\"objects\"\n        WHERE \"objects\".\"bucket_id\" = \"_bucket_id\"\n          AND \"storage\".\"get_level\"(\"objects\".\"name\") = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"objects\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    ) THEN\n    -- There are sub-objects, skip deletion\n    RETURN false;\n    ELSE\n        DELETE FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\")\n          AND \"prefixes\".\"name\" = \"_name\";\n        RETURN true;\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "delete_prefix_hierarchy_trigger",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.delete_prefix_hierarchy_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    prefix text;\nBEGIN\n    prefix := \"storage\".\"get_prefix\"(OLD.\"name\");\n\n    IF coalesce(prefix, '') != '' THEN\n        PERFORM \"storage\".\"delete_prefix\"(OLD.\"bucket_id\", prefix);\n    END IF;\n\n    RETURN OLD;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "enforce_bucket_name_length",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n    if length(new.name) > 100 then\n        raise exception 'bucket name \"%\" is too long (% characters). Max is 100.', new.name, length(new.name);\n    end if;\n    return new;\nend;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "extension",
    "arguments": "name text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.extension(name text)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\n    _filename text;\nBEGIN\n    SELECT string_to_array(name, '/') INTO _parts;\n    SELECT _parts[array_length(_parts,1)] INTO _filename;\n    RETURN reverse(split_part(reverse(_filename), '.', 1));\nEND\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "filename",
    "arguments": "name text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.filename(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "foldername",
    "arguments": "name text",
    "return_type": "text[]",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.foldername(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\nBEGIN\n    -- Split on \"/\" to get path segments\n    SELECT string_to_array(name, '/') INTO _parts;\n    -- Return everything except the last segment\n    RETURN _parts[1 : array_length(_parts,1) - 1];\nEND\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "get_level",
    "arguments": "name text",
    "return_type": "integer",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.get_level(name text)\n RETURNS integer\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT array_length(string_to_array(\"name\", '/'), 1);\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "get_prefix",
    "arguments": "name text",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.get_prefix(name text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT\n    CASE WHEN strpos(\"name\", '/') > 0 THEN\n             regexp_replace(\"name\", '[\\/]{1}[^\\/]+\\/?$', '')\n         ELSE\n             ''\n        END;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "get_prefixes",
    "arguments": "name text",
    "return_type": "text[]",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE STRICT\nAS $function$\nDECLARE\n    parts text[];\n    prefixes text[];\n    prefix text;\nBEGIN\n    -- Split the name into parts by '/'\n    parts := string_to_array(\"name\", '/');\n    prefixes := '{}';\n\n    -- Construct the prefixes, stopping one level below the last part\n    FOR i IN 1..array_length(parts, 1) - 1 LOOP\n            prefix := array_to_string(parts[1:i], '/');\n            prefixes := array_append(prefixes, prefix);\n    END LOOP;\n\n    RETURN prefixes;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "get_size_by_bucket",
    "arguments": "",
    "return_type": "TABLE(size bigint, bucket_id text)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()\n RETURNS TABLE(size bigint, bucket_id text)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    return query\n        select sum((metadata->>'size')::bigint) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "list_multipart_uploads_with_delimiter",
    "arguments": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text",
    "return_type": "TABLE(key text, id text, created_at timestamp with time zone)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)\n RETURNS TABLE(key text, id text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "list_objects_with_delimiter",
    "arguments": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text",
    "return_type": "TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)\n RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "lock_top_prefixes",
    "arguments": "bucket_ids text[], names text[]",
    "return_type": "void",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.lock_top_prefixes(bucket_ids text[], names text[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_bucket text;\n    v_top text;\nBEGIN\n    FOR v_bucket, v_top IN\n        SELECT DISTINCT t.bucket_id,\n            split_part(t.name, '/', 1) AS top\n        FROM unnest(bucket_ids, names) AS t(bucket_id, name)\n        WHERE t.name <> ''\n        ORDER BY 1, 2\n        LOOP\n            PERFORM pg_advisory_xact_lock(hashtextextended(v_bucket || '/' || v_top, 0));\n        END LOOP;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "objects_delete_cleanup",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.objects_delete_cleanup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_bucket_ids text[];\n    v_names      text[];\nBEGIN\n    IF current_setting('storage.gc.prefixes', true) = '1' THEN\n        RETURN NULL;\n    END IF;\n\n    PERFORM set_config('storage.gc.prefixes', '1', true);\n\n    SELECT COALESCE(array_agg(d.bucket_id), '{}'),\n           COALESCE(array_agg(d.name), '{}')\n    INTO v_bucket_ids, v_names\n    FROM deleted AS d\n    WHERE d.name <> '';\n\n    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);\n    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);\n\n    RETURN NULL;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "objects_insert_prefix_trigger",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.objects_insert_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    NEW.level := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "objects_update_cleanup",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.objects_update_cleanup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    -- NEW - OLD (destinations to create prefixes for)\n    v_add_bucket_ids text[];\n    v_add_names      text[];\n\n    -- OLD - NEW (sources to prune)\n    v_src_bucket_ids text[];\n    v_src_names      text[];\nBEGIN\n    IF TG_OP <> 'UPDATE' THEN\n        RETURN NULL;\n    END IF;\n\n    -- 1) Compute NEWOLD (added paths) and OLDNEW (moved-away paths)\n    WITH added AS (\n        SELECT n.bucket_id, n.name\n        FROM new_rows n\n        WHERE n.name <> '' AND position('/' in n.name) > 0\n        EXCEPT\n        SELECT o.bucket_id, o.name FROM old_rows o WHERE o.name <> ''\n    ),\n    moved AS (\n         SELECT o.bucket_id, o.name\n         FROM old_rows o\n         WHERE o.name <> ''\n         EXCEPT\n         SELECT n.bucket_id, n.name FROM new_rows n WHERE n.name <> ''\n    )\n    SELECT\n        -- arrays for ADDED (dest) in stable order\n        COALESCE( (SELECT array_agg(a.bucket_id ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),\n        COALESCE( (SELECT array_agg(a.name      ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),\n        -- arrays for MOVED (src) in stable order\n        COALESCE( (SELECT array_agg(m.bucket_id ORDER BY m.bucket_id, m.name) FROM moved m), '{}' ),\n        COALESCE( (SELECT array_agg(m.name      ORDER BY m.bucket_id, m.name) FROM moved m), '{}' )\n    INTO v_add_bucket_ids, v_add_names, v_src_bucket_ids, v_src_names;\n\n    -- Nothing to do?\n    IF (array_length(v_add_bucket_ids, 1) IS NULL) AND (array_length(v_src_bucket_ids, 1) IS NULL) THEN\n        RETURN NULL;\n    END IF;\n\n    -- 2) Take per-(bucket, top) locks: ALL prefixes in consistent global order to prevent deadlocks\n    DECLARE\n        v_all_bucket_ids text[];\n        v_all_names text[];\n    BEGIN\n        -- Combine source and destination arrays for consistent lock ordering\n        v_all_bucket_ids := COALESCE(v_src_bucket_ids, '{}') || COALESCE(v_add_bucket_ids, '{}');\n        v_all_names := COALESCE(v_src_names, '{}') || COALESCE(v_add_names, '{}');\n\n        -- Single lock call ensures consistent global ordering across all transactions\n        IF array_length(v_all_bucket_ids, 1) IS NOT NULL THEN\n            PERFORM storage.lock_top_prefixes(v_all_bucket_ids, v_all_names);\n        END IF;\n    END;\n\n    -- 3) Create destination prefixes (NEWOLD) BEFORE pruning sources\n    IF array_length(v_add_bucket_ids, 1) IS NOT NULL THEN\n        WITH candidates AS (\n            SELECT DISTINCT t.bucket_id, unnest(storage.get_prefixes(t.name)) AS name\n            FROM unnest(v_add_bucket_ids, v_add_names) AS t(bucket_id, name)\n            WHERE name <> ''\n        )\n        INSERT INTO storage.prefixes (bucket_id, name)\n        SELECT c.bucket_id, c.name\n        FROM candidates c\n        ON CONFLICT DO NOTHING;\n    END IF;\n\n    -- 4) Prune source prefixes bottom-up for OLDNEW\n    IF array_length(v_src_bucket_ids, 1) IS NOT NULL THEN\n        -- re-entrancy guard so DELETE on prefixes won't recurse\n        IF current_setting('storage.gc.prefixes', true) <> '1' THEN\n            PERFORM set_config('storage.gc.prefixes', '1', true);\n        END IF;\n\n        PERFORM storage.delete_leaf_prefixes(v_src_bucket_ids, v_src_names);\n    END IF;\n\n    RETURN NULL;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "objects_update_level_trigger",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.objects_update_level_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Ensure this is an update operation and the name has changed\n    IF TG_OP = 'UPDATE' AND (NEW.\"name\" <> OLD.\"name\" OR NEW.\"bucket_id\" <> OLD.\"bucket_id\") THEN\n        -- Set the new level\n        NEW.\"level\" := \"storage\".\"get_level\"(NEW.\"name\");\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "objects_update_prefix_trigger",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.objects_update_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    old_prefixes TEXT[];\nBEGIN\n    -- Ensure this is an update operation and the name has changed\n    IF TG_OP = 'UPDATE' AND (NEW.\"name\" <> OLD.\"name\" OR NEW.\"bucket_id\" <> OLD.\"bucket_id\") THEN\n        -- Retrieve old prefixes\n        old_prefixes := \"storage\".\"get_prefixes\"(OLD.\"name\");\n\n        -- Remove old prefixes that are only used by this object\n        WITH all_prefixes as (\n            SELECT unnest(old_prefixes) as prefix\n        ),\n        can_delete_prefixes as (\n             SELECT prefix\n             FROM all_prefixes\n             WHERE NOT EXISTS (\n                 SELECT 1 FROM \"storage\".\"objects\"\n                 WHERE \"bucket_id\" = OLD.\"bucket_id\"\n                   AND \"name\" <> OLD.\"name\"\n                   AND \"name\" LIKE (prefix || '%')\n             )\n         )\n        DELETE FROM \"storage\".\"prefixes\" WHERE name IN (SELECT prefix FROM can_delete_prefixes);\n\n        -- Add new prefixes\n        PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    END IF;\n    -- Set the new level\n    NEW.\"level\" := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "operation",
    "arguments": "",
    "return_type": "text",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.operation()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "prefixes_delete_cleanup",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.prefixes_delete_cleanup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_bucket_ids text[];\n    v_names      text[];\nBEGIN\n    IF current_setting('storage.gc.prefixes', true) = '1' THEN\n        RETURN NULL;\n    END IF;\n\n    PERFORM set_config('storage.gc.prefixes', '1', true);\n\n    SELECT COALESCE(array_agg(d.bucket_id), '{}'),\n           COALESCE(array_agg(d.name), '{}')\n    INTO v_bucket_ids, v_names\n    FROM deleted AS d\n    WHERE d.name <> '';\n\n    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);\n    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);\n\n    RETURN NULL;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "prefixes_insert_trigger",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.prefixes_insert_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "search",
    "arguments": "prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text",
    "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    can_bypass_rls BOOLEAN;\nbegin\n    SELECT rolbypassrls\n    INTO can_bypass_rls\n    FROM pg_roles\n    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);\n\n    IF can_bypass_rls THEN\n        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    ELSE\n        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    END IF;\nend;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "search_legacy_v1",
    "arguments": "prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text",
    "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select path_tokens[$1] as folder\n           from storage.objects\n             where objects.name ilike $2 || $3 || ''%''\n               and bucket_id = $4\n               and array_length(objects.path_tokens, 1) <> $1\n           group by folder\n           order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "search_v1_optimised",
    "arguments": "prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text",
    "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select (string_to_array(name, ''/''))[level] as name\n           from storage.prefixes\n             where lower(prefixes.name) like lower($2 || $3) || ''%''\n               and bucket_id = $4\n               and level = $1\n           order by name ' || v_sort_order || '\n     )\n     (select name,\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[level] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where lower(objects.name) like lower($2 || $3) || ''%''\n       and bucket_id = $4\n       and level = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "search_v2",
    "arguments": "prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text",
    "return_type": "TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text)\n RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nDECLARE\n    sort_col text;\n    sort_ord text;\n    cursor_op text;\n    cursor_expr text;\n    sort_expr text;\nBEGIN\n    -- Validate sort_order\n    sort_ord := lower(sort_order);\n    IF sort_ord NOT IN ('asc', 'desc') THEN\n        sort_ord := 'asc';\n    END IF;\n\n    -- Determine cursor comparison operator\n    IF sort_ord = 'asc' THEN\n        cursor_op := '>';\n    ELSE\n        cursor_op := '<';\n    END IF;\n    \n    sort_col := lower(sort_column);\n    -- Validate sort column  \n    IF sort_col IN ('updated_at', 'created_at') THEN\n        cursor_expr := format(\n            '($5 = '''' OR ROW(date_trunc(''milliseconds'', %I), name COLLATE \"C\") %s ROW(COALESCE(NULLIF($6, '''')::timestamptz, ''epoch''::timestamptz), $5))',\n            sort_col, cursor_op\n        );\n        sort_expr := format(\n            'COALESCE(date_trunc(''milliseconds'', %I), ''epoch''::timestamptz) %s, name COLLATE \"C\" %s',\n            sort_col, sort_ord, sort_ord\n        );\n    ELSE\n        cursor_expr := format('($5 = '''' OR name COLLATE \"C\" %s $5)', cursor_op);\n        sort_expr := format('name COLLATE \"C\" %s', sort_ord);\n    END IF;\n\n    RETURN QUERY EXECUTE format(\n        $sql$\n        SELECT * FROM (\n            (\n                SELECT\n                    split_part(name, '/', $4) AS key,\n                    name,\n                    NULL::uuid AS id,\n                    updated_at,\n                    created_at,\n                    NULL::timestamptz AS last_accessed_at,\n                    NULL::jsonb AS metadata\n                FROM storage.prefixes\n                WHERE name COLLATE \"C\" LIKE $1 || '%%'\n                    AND bucket_id = $2\n                    AND level = $4\n                    AND %s\n                ORDER BY %s\n                LIMIT $3\n            )\n            UNION ALL\n            (\n                SELECT\n                    split_part(name, '/', $4) AS key,\n                    name,\n                    id,\n                    updated_at,\n                    created_at,\n                    last_accessed_at,\n                    metadata\n                FROM storage.objects\n                WHERE name COLLATE \"C\" LIKE $1 || '%%'\n                    AND bucket_id = $2\n                    AND level = $4\n                    AND %s\n                ORDER BY %s\n                LIMIT $3\n            )\n        ) obj\n        ORDER BY %s\n        LIMIT $3\n        $sql$,\n        cursor_expr,    -- prefixes WHERE\n        sort_expr,      -- prefixes ORDER BY\n        cursor_expr,    -- objects WHERE\n        sort_expr,      -- objects ORDER BY\n        sort_expr       -- final ORDER BY\n    )\n    USING prefix, bucket_name, limits, levels, start_after, sort_column_after;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "update_updated_at_column",
    "arguments": "",
    "return_type": "trigger",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n"
  },
  {
    "schema": "teams_surveys",
    "function_name": "submit_weekly_allocation_survey",
    "arguments": "p_user_external_id text, p_survey_sent_at timestamp with time zone, p_hours_overtime numeric, p_hours_undertime numeric, p_projects_count integer, p_workload_clarity smallint",
    "return_type": "teams_surveys.weekly_allocation_survey_responses",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION teams_surveys.submit_weekly_allocation_survey(p_user_external_id text, p_survey_sent_at timestamp with time zone, p_hours_overtime numeric, p_hours_undertime numeric, p_projects_count integer, p_workload_clarity smallint)\n RETURNS teams_surveys.weekly_allocation_survey_responses\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp', 'teams_surveys'\nAS $function$\r\ndeclare\r\n  v_row teams_surveys.weekly_allocation_survey_responses;\r\nbegin\r\n  --   \r\n  if coalesce(trim(p_user_external_id), '') = '' then\r\n    raise exception 'user_external_id is required' using errcode = '22023';\r\n  end if;\r\n\r\n  if p_survey_sent_at is null then\r\n    raise exception 'survey_sent_at is required' using errcode = '22023';\r\n  end if;\r\n\r\n  if p_hours_overtime is null or p_hours_overtime < 0 or p_hours_overtime > 100 then\r\n    raise exception 'hours_overtime must be number in [0,100]' using errcode = '22023';\r\n  end if;\r\n\r\n  if p_hours_undertime is null or p_hours_undertime < 0 or p_hours_undertime > 100 then\r\n    raise exception 'hours_undertime must be number in [0,100]' using errcode = '22023';\r\n  end if;\r\n\r\n  if p_projects_count is null or p_projects_count < 0 or p_projects_count > 50 then\r\n    raise exception 'projects_count must be integer in [0,50]' using errcode = '22023';\r\n  end if;\r\n\r\n  if p_workload_clarity is null or p_workload_clarity < 1 or p_workload_clarity > 5 then\r\n    raise exception 'workload_clarity must be integer in [1,5]' using errcode = '22023';\r\n  end if;\r\n\r\n  -- Upsert  (user_external_id, survey_week_start_minsk)\r\n  insert into teams_surveys.weekly_allocation_survey_responses as t (\r\n    user_external_id,\r\n    survey_sent_at,\r\n    hours_overtime,\r\n    hours_undertime,\r\n    projects_count,\r\n    workload_clarity\r\n  )\r\n  values (\r\n    p_user_external_id,\r\n    p_survey_sent_at,\r\n    round(p_hours_overtime::numeric, 2),\r\n    round(p_hours_undertime::numeric, 2),\r\n    p_projects_count,\r\n    p_workload_clarity\r\n  )\r\n  on conflict (user_external_id, survey_week_start_minsk)\r\n  do update set\r\n    survey_sent_at   = excluded.survey_sent_at,\r\n    submitted_at     = now(),\r\n    hours_overtime   = excluded.hours_overtime,\r\n    hours_undertime  = excluded.hours_undertime,\r\n    projects_count   = excluded.projects_count,\r\n    workload_clarity = excluded.workload_clarity\r\n  returning * into v_row;\r\n\r\n  return v_row;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "vault",
    "function_name": "_crypto_aead_det_decrypt",
    "arguments": "message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$\n"
  },
  {
    "schema": "vault",
    "function_name": "_crypto_aead_det_encrypt",
    "arguments": "message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$\n"
  },
  {
    "schema": "vault",
    "function_name": "_crypto_aead_det_noncegen",
    "arguments": "",
    "return_type": "bytea",
    "security_definer": false,
    "function_sql": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_noncegen()\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_noncegen$function$\n"
  },
  {
    "schema": "vault",
    "function_name": "create_secret",
    "arguments": "new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid",
    "return_type": "uuid",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  rec record;\nBEGIN\n  INSERT INTO vault.secrets (secret, name, description)\n  VALUES (\n    new_secret,\n    new_name,\n    new_description\n  )\n  RETURNING * INTO rec;\n  UPDATE vault.secrets s\n  SET secret = encode(vault._crypto_aead_det_encrypt(\n    message := convert_to(rec.secret, 'utf8'),\n    additional := convert_to(s.id::text, 'utf8'),\n    key_id := 0,\n    context := 'pgsodium'::bytea,\n    nonce := rec.nonce\n  ), 'base64')\n  WHERE id = rec.id;\n  RETURN rec.id;\nEND\n$function$\n"
  },
  {
    "schema": "vault",
    "function_name": "update_secret",
    "arguments": "secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid",
    "return_type": "void",
    "security_definer": true,
    "function_sql": "CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);\nBEGIN\n  UPDATE vault.secrets s\n  SET\n    secret = CASE WHEN new_secret IS NULL THEN s.secret\n                  ELSE encode(vault._crypto_aead_det_encrypt(\n                    message := convert_to(new_secret, 'utf8'),\n                    additional := convert_to(s.id::text, 'utf8'),\n                    key_id := 0,\n                    context := 'pgsodium'::bytea,\n                    nonce := s.nonce\n                  ), 'base64') END,\n    name = coalesce(new_name, s.name),\n    description = coalesce(new_description, s.description),\n    updated_at = now()\n  WHERE s.id = secret_id;\nEND\n$function$\n"
  }
]