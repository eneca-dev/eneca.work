# Чекпоинты-проблемы: Визуальный прототип

## Цель

Создать визуальный прототип функционала "чекпоинт-проблема" для тестирования гипотезы на проекте "Демопроект1". Прототип включает:
- Визуальное выделение проблемных чекпоинтов (красный, увеличенный маркер 22px)
- UI для решения проблем с аудитом (комментарий, сдвиг сроков)

**Важно:** Это чисто UI-прототип без изменений в БД. Все данные моковые, хардкоженные в коде.

---

## Этапы реализации

### Этап 1: Моковые данные и типы

**Описание:**
Создать моковые данные для демонстрации функционала и расширить TypeScript типы для поддержки новых полей.

**Затрагиваемые файлы:**
- `modules/checkpoints/mocks/mock-checkpoint-data.ts` (новый)
- `modules/checkpoints/actions/checkpoints.ts` (обновить интерфейс `Checkpoint`)

**Что делать:**
1. Создать файл с моковыми данными:
   - Массив `mockCheckpoints` — 7-10 чекпоинтов с флагом `is_problem`
   - Массив `mockResolutions` — история решений проблем
2. Расширить интерфейс `Checkpoint`:
   ```typescript
   interface Checkpoint {
     // ... existing fields
     is_problem?: boolean
     problem_resolutions?: ProblemResolution[]
   }

   interface ProblemResolution {
     resolution_id: string
     resolved_by: string
     resolved_by_name: string
     resolved_at: string
     comment: string
     deadline_shift_days: number
   }
   ```

**Зависимости:** нет

---

### Этап 2: Визуальное отличие проблемных чекпоинтов

**Описание:**
Обновить компонент маркера чекпоинта для визуального выделения проблем.

**Затрагиваемые файлы:**
- `modules/checkpoints/components/CheckpointMarker.tsx`
- `modules/checkpoints/constants/checkpoint-constants.ts` (если нужны новые константы)

**Что делать:**
1. Добавить логику для `is_problem` флага:
   - Если `is_problem: true`:
     - Радиус маркера: **11px** (диаметр 22px) вместо 8px
     - Цвет фона: `#fecaca` (red-200)
     - Цвет обводки: `#ef4444` (red-500)
     - Иконка: `AlertTriangle` из lucide-react
     - Анимация: пульсация (animate-pulse-subtle)
2. В тултипе добавить красный бейдж:
   ```tsx
   {checkpoint.is_problem && (
     <span className="px-2 py-1 bg-red-500/20 text-red-400 text-xs rounded">
       ⚠️ ПРОБЛЕМА
     </span>
   )}
   ```
3. Добавить кнопку "Решить проблему" в тултип (открывает модалку)

**Зависимости:** Этап 1

---

### Этап 3: Фильтры чекпоинтов

**Описание:**
Создать UI для фильтрации чекпоинтов по типам и по флагу проблемы.

**Затрагиваемые файлы:**
- `modules/checkpoints/components/CheckpointFilters.tsx` (новый)
- `modules/checkpoints/stores/checkpoint-filter-store.ts` (новый)
- Родительский компонент, рендерящий чекпоинты (добавить логику фильтрации)

**Что делать:**
1. Создать Zustand store для фильтров:
   ```typescript
   interface CheckpointFilterStore {
     selectedTypeIds: string[]
     showProblemsOnly: boolean
     setSelectedTypes: (typeIds: string[]) => void
     toggleProblemsOnly: () => void
     resetFilters: () => void
   }
   ```
2. Создать компонент `CheckpointFilters`:
   - Мультиселект типов чекпоинтов (показывать иконку и название типа)
   - Чекбокс "Только проблемные" с иконкой AlertTriangle
   - Кнопка "Сбросить фильтры" (если есть активные фильтры)
   - Счетчик отфильтрованных/всего чекпоинтов
3. Добавить логику фильтрации в компоненте который рендерит CheckpointMarker:
   ```typescript
   const filteredCheckpoints = checkpoints.filter(cp => {
     // Фильтр по типу
     if (selectedTypeIds.length > 0 && !selectedTypeIds.includes(cp.type_id)) {
       return false
     }
     // Фильтр по проблемам
     if (showProblemsOnly && !cp.is_problem) {
       return false
     }
     return true
   })
   ```
4. Разместить компонент над timeline чекпоинтов

**Зависимости:** Этап 1

---

### Этап 4: Модалка решения проблемы

**Описание:**
Создать модальное окно для решения проблемного чекпоинта.

**Затрагиваемые файлы:**
- `modules/checkpoints/components/ResolveProblemModal.tsx` (новый)
- `modules/modals/hooks/use-modals.ts` (регистрация новой модалки)

**Что делать:**
1. Создать компонент модалки:
   - Заголовок с иконкой `AlertTriangle` и красным акцентом
   - Поля формы:
     - `Textarea` — "Комментарий к решению" (обязательное)
     - `Input[number]` — "Сдвиг сроков (дней)" (опциональное, может быть отрицательным)
   - Секция "История решений" (если есть `problem_resolutions`):
     - Список карточек с данными: кто, когда, комментарий, сдвиг
   - Кнопки: "Отмена", "Решить проблему"
2. При клике "Решить проблему":
   - Показать toast: "✅ Проблема решена (мок)"
   - В реальной версии здесь будет вызов Server Action
3. Зарегистрировать модалку в `use-modals.ts`:
   ```typescript
   openResolveProblemModal: (checkpointId: string) => void
   ```

**Зависимости:** Этап 2

---

### Этап 5: Интеграция и полировка

**Описание:**
Интегрировать все компоненты, добавить моковые данные в нужные места, проверить UX.

**Затрагиваемые файлы:**
- `modules/checkpoints/mocks/mock-checkpoint-data.ts` (финализация данных)
- Место рендера чекпоинтов (проверка интеграции)

**Что делать:**
1. Добавить в моки разнообразные кейсы:
   - Проблемный чекпоинт без решений
   - Проблемный чекпоинт с 2-3 решениями
   - Обычные чекпоинты
2. Проверить анимации и transitions
3. Добавить комментарии в коде: `// MOCK DATA - not connected to DB`
4. Убедиться что модалка открывается из маркера
5. Убедиться что фильтры работают корректно

**Зависимости:** Этапы 2-4

---

## Критерии готовности (Definition of Done)

- [ ] Моковые данные созданы для "Демопроект1"
- [ ] Чекпоинт-проблема визуально отличается (красный, 22px диаметр, иконка AlertTriangle)
- [ ] Фильтры работают (по типам и "только проблемные")
- [ ] Счетчик показывает количество отфильтрованных чекпоинтов
- [ ] Модалка "Решить проблему" открывается и показывает форму
- [ ] В модалке видна история решений (если есть)
- [ ] Все изменения работают в браузере без ошибок
- [ ] `npm run build` проходит без ошибок
- [ ] Код помечен комментариями "MOCK DATA"

---

## Примечания

**Не реализуется в прототипе:**
- Сохранение данных в БД
- Server Actions для CRUD решений
- Реальная система permissions
- Система веток чекпоинтов (отложено)
- Связи между чекпоинтами разных разделов
- Карта всех чекпоинтов проекта

**После тестирования гипотезы:**
- Если прототип одобрен → создать Full Pipeline план для реальной реализации с БД
- Если нужны изменения → итеративно доработать прототип
