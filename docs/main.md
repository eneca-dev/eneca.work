# eneca.work — материнский проект

## Что уже реализовано

- **Next.js**: современная структура приложения (app router, layout, страницы)
- **Supabase**: интеграция для аутентификации (utils/supabase, middleware, client/server)
- **Tailwind CSS**: стилизация, кастомные темы, глобальные стили
- **Большая библиотека UI-компонентов**: кнопки, формы, меню, карточки, таблицы, алерты и др. (components/ui)
- **Компоненты для аутентификации**: формы входа, регистрации, восстановления пароля, подтверждения email
- **Sidebar и меню**: реализован Sidebar для dashboard
- **Dashboard**: базовая страница с приветствием и заготовкой под модули
- **Папки для будущих модулей**: planning, tasks, settings (внутри dashboard)
- **Документация**: начата структура docs (auth.md, main.md)
- **Middleware**: реализована синхронизация сессии через Supabase
- **Базовые хуки**: use-toast, use-mobile
- **Утилиты**: lib/utils.ts
- **Конфиги**: tailwind, postcss, tsconfig, next.config.mjs
- **Готовая структура для auth**: отдельные страницы и layout для аутентификации

---

## Чего не хватает для полноценного материнского проекта

1. **Глобальное управление состоянием (Redux/Redux Toolkit):**
   - Нет store, слайсов для user, ui, settings
   - Нет интеграции redux-persist (если нужно сохранять состояние)

2. **Механизма подключения модулей:**
   - Нет структуры modules/ и документации/примера, как добавить новый модуль

3. **Глобального меню и навигации:**
   - Sidebar реализован, но нет универсального механизма расширения меню модулями

4. **Глобальных хуков для аутентификации и пользователя:**
   - Нет хуков useAuth, useUser, usePermissions для работы с auth и правами

5. **Главной страницы (welcome/dashboard):**
   - Сейчас главная страница просто редиректит на /auth/login. Лучше сделать welcome/dashboard с описанием платформы и ссылками на модули

6. **Документации по архитектуре и интеграции модулей:**
   - Нет подробного описания, как разрабатывать и интегрировать модули, как устроен роутинг, как расширять меню и т.д.

---

## Глобальное состояние приложения

### Зачем нужно глобальное состояние

Глобальное состояние позволяет централизованно управлять данными, которые нужны во многих частях приложения: информация о пользователе, настройки, уведомления, состояние загрузки и т.д. Это делает код более предсказуемым, упрощает обмен данными между модулями и облегчает масштабирование.

### Как реализовать глобальное состояние

Для управления глобальным состоянием рекомендуется использовать **Redux Toolkit**:

1. Установить зависимости:
   ```sh
   pnpm add @reduxjs/toolkit react-redux
   ```
2. Создать папку `store/` в корне проекта.
3. Внутри `store/` создать слайсы:
   - `userSlice.ts` — данные пользователя, токены, права
   - `uiSlice.ts` — глобальные уведомления, лоадеры
   - `settingsSlice.ts` — настройки приложения
4. Собрать все слайсы в `store/index.ts` и создать store:
   ```ts
   import { configureStore } from '@reduxjs/toolkit'
   import userReducer from './userSlice'
   import uiReducer from './uiSlice'
   import settingsReducer from './settingsSlice'

   export const store = configureStore({
     reducer: {
       user: userReducer,
       ui: uiReducer,
       settings: settingsReducer,
     },
   })
   ```
5. Обернуть приложение в `<Provider store={store}>` в app/layout.tsx:
   ```tsx
   import { Provider } from 'react-redux'
   import { store } from '@/store'
   // ...
   <Provider store={store}>
     {children}
   </Provider>
   ```

### Как модули могут использовать глобальное состояние

- Каждый модуль может создавать свой redux-слайс (например, calendarSlice) и вручную добавлять его в store.
- Для доступа к состоянию использовать хуки `useSelector` и `useDispatch` из `react-redux`.
- Общие хуки (например, useUser, useAuth) можно реализовать в папке hooks/ и использовать во всех модулях.

### Пример структуры store

```
store/
├── index.ts
├── userSlice.ts
├── uiSlice.ts
└── settingsSlice.ts
```

### Рекомендации
- Не хранить большие объёмы данных (например, списки задач) в глобальном состоянии — только то, что действительно нужно глобально.
- Для асинхронных запросов использовать createAsyncThunk из Redux Toolkit.
- Если нужно сохранять часть состояния между сессиями — использовать redux-persist.
- Документировать структуру store и правила добавления новых слайсов.

---

## Самый простой вариант модульной системы: ручная интеграция

### Суть подхода

Каждый модуль — это отдельная папка (например, в modules/), содержащая компоненты, страницы и пункты меню. Интеграция модулей в приложение происходит вручную: через импорт компонентов, страниц и меню в нужные места (Sidebar, роутинг и т.д.).

### Пример структуры

```
eneca.work/
├── app/
│   ├── layout.tsx
│   ├── page.tsx
│   ├── dashboard/
│   ├── auth/
│   └── ...
├── modules/
│   ├── calendar/
│   │   ├── CalendarPage.tsx
│   │   ├── CalendarMenu.tsx
│   │   └── ...
│   ├── tasks/
│   │   ├── TasksPage.tsx
│   │   ├── TasksMenu.tsx
│   │   └── ...
│   └── analytics/
│       ├── AnalyticsPage.tsx
│       └── AnalyticsMenu.tsx
└── ...
```

### Минимальная структура папки модуля

```
modules/
└── example/
    ├── ExamplePage.tsx
    ├── ExampleMenu.tsx
    └── (опционально) store.ts
```

### Как добавить новый модуль

1. Создай папку в modules/, например modules/calendar.
2. В ней создай компоненты страницы (CalendarPage.tsx) и меню (CalendarMenu.tsx).
3. Импортируй CalendarMenu в Sidebar и CalendarPage в роутинг dashboard.
4. (Опционально) Если нужен redux-слайс — добавь его вручную в store.

### Как происходит интеграция

- В Sidebar (или другом меню) вручную импортируются и добавляются пункты меню из модулей:
  ```tsx
  import { CalendarMenu } from '@/modules/calendar/CalendarMenu'
  import { TasksMenu } from '@/modules/tasks/TasksMenu'
  // ...
  <Sidebar>
    <CalendarMenu />
    <TasksMenu />
    {/* другие пункты */}
  </Sidebar>
  ```
- В роутинге (например, в app/dashboard/page.tsx) вручную импортируются и добавляются страницы модулей:
  ```tsx
  import CalendarPage from '@/modules/calendar/CalendarPage'
  // ...
  <Route path="/dashboard/calendar" element={<CalendarPage />} />
  ```
- Если модулю нужно глобальное состояние — он может создать свой redux-слайс и вручную добавить его в store.

### Рекомендации по именованию и структуре
- Используй единый стиль именования: CalendarPage, CalendarMenu, TasksPage и т.д.
- Все общие хуки и утилиты выноси в core (lib/hooks, lib/utils).
- Документируй процесс добавления нового модуля.

### Типовые ошибки и как их избежать
- Не забывай импортировать новый пункт меню и страницу в Sidebar и роутинг.
- Не дублируй хуки — выноси их в lib/hooks.
- Старайся придерживаться единой структуры папки модуля.

### Как временно отключить модуль
- Просто закомментируй импорт и использование компонента меню/страницы в Sidebar и роутинге.

### Плюсы
- Минимум архитектурных сложностей, всё делается через обычные импорты.
- Быстро и понятно, легко начать.
- Легко копировать и дорабатывать модули — просто копируешь папку, меняешь код, интегрируешь обратно.

### Минусы
- Возможное дублирование кода, если не вынести общие хуки/утилиты.
- Ручная интеграция: каждый раз нужно руками добавлять меню, роуты, слайсы.
- Нет динамики: нельзя легко подключать/отключать модули без правки кода core.
- Сложнее поддерживать стандарты, если не договориться о структуре модулей.

### Когда этот вариант оправдан
- На старте проекта, когда важна скорость и простота.
- Если команда небольшая и все понимают структуру.
- Если модули не слишком сложные и не требуют сложной интеграции.

---

## Итог

Текущий проект — отличная основа, уже реализованы:
- Аутентификация, Supabase, UI, базовые страницы, структура для модулей

Для полноценного материнского проекта не хватает:
- Глобального состояния (Redux)
- Механизма интеграции модулей
- Документации по архитектуре и интеграции
- Глобальных хуков для auth и пользователя
- Главной страницы с описанием платформы и ссылками на модули
